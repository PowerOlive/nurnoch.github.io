<!DOCTYPE html>
<html lang="zh">
<head>

        <title>选择问题及复杂度分析</title>
        <meta charset="utf-8" />
        <link href="http://www.wengweitao.com/feeds\all.atom.xml" type="application/atom+xml" rel="alternate" title="wwt's blog Full Atom Feed" />
        <link href="http://www.wengweitao.com/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="wwt's blog Full RSS Feed" />
        <link href="http://www.wengweitao.com/feeds/suan-fa-yu-shu-ju-jie-gou.rss.xml" type="application/atom+xml" rel="alternate" title="wwt's blog Categories Atom Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">
        <meta name="google-site-verification" content="pEViDEEJCicDD__DfnOAQ7xKtjtxJhVDoGDAOahOWy0" />

        <meta name="sogou_site_verification" content="ia8yXdZS0p"/>

        <link rel="stylesheet" type="text/css" href="http://www.wengweitao.com/theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="http://www.wengweitao.com/theme/style.css" />
        <link rel="stylesheet" type="text/css" href="http://www.wengweitao.com/theme/pygment.css" />


        <script src="http://www.wengweitao.com/theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="http://www.wengweitao.com/">wwt's blog <strong></strong></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="http://www.wengweitao.com/">首页</a></li>

                <li><a href="/categories.html">分类</a></li>
                <li><a href="/tags.html">标签</a></li>
                <li><a href="/archives.html">归档</a></li>
                <li><a href="/pages/about-me.html">关于我</a></li>

              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="http://www.wengweitao.com/xuan-ze-wen-ti-ji-fu-za-du-fen-xi.html" rel="bookmark"
                   title="Permalink to 选择问题及复杂度分析">选择问题及复杂度分析</a></h2>
           

            </header>
            <footer class="post-info">
              <abbr class="published" title="2015-05-06T11:10:00">
                Wed 06 May 2015
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="http://www.wengweitao.com/author/wwt.html"> wwt</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
              <p>选择问题是在实际应用中经常碰到的问题，最常见的选择问题有：选最大、选最小、选中位数、选第二大等。</p>
<p>可以描述为从n个元素的集合L中选出第k小的元素，其中<span class="math">\(1 \leq k \leq n\)</span>。这里的第k小表示：将L中的元素按照升序排列，排在第k个位置的元素。如k=1时，选出的就是最小元素。</p>
<p>本文将对选择问题进行总结并对它们的复杂度进行分析。</p>
<h2>选最大最小问题</h2>
<h3>选最大算法</h3>
<p>选最大问题，最容易想到的方法就是顺序比较算法，从第一个元素开始依次往后比较n个元素，用一个变量max保存当前的最大值，算法实现如下：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">findMax</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>由于需要遍历集合L的n个元素，所以算法的时间复杂度为W(n-1)。可以证明，这个算法是求解选最大问题在时间上最优的算法。</p>
<h3>选最小算法</h3>
<p>只需要将上面选最大问题的算法稍微改动即可。</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">findMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>   
    <span class="k">return</span> <span class="n">min</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>时间复杂度也与选最大问题相同。</p>
<h3>同时选最大和最小算法</h3>
<p>我们可以利用findMax和findMin算法得到选最大和最小的算法。设计思想为：先选出最大，然后将这个最大从L中删除，接着选最小。这样时间复杂度可以表示为：
</p>
<div class="math">$$W(n) = n - 1 + n - 2 = 2n - 3$$</div>
<p>下面考虑分组比赛的方法：</p>
<ol>
<li>将L中的元素两两一组，分成<span class="math">\(\frac{n}{2}\)</span>组，若n为奇数，有一个元素轮空；</li>
<li>每组中通过一次比较可以得出每组中较大的和较小的数</li>
<li>把至多<span class="math">\(\frac{n}{2} + 1\)</span>个小组较大数的放到一起，利用findMax算法找出其中最大的元素；</li>
<li>把至多<span class="math">\(\frac{n}{2} + 1\)</span>个小组较小数的放到一起，利用findMin算法找出其中最小的元素；</li>
</ol>
<p>算法实现：</p>
<div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findMaxMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">max_group</span><span class="p">;</span>  <span class="c1">//用于保存两两比较之后较大的数</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">min_group</span><span class="p">;</span>  <span class="c1">//用于保存两两比较之后较小的数</span>

    <span class="c1">// 每个小组分别比较</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">min_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
        <span class="k">else</span><span class="p">{</span>
            <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
            <span class="n">min_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="c1">// 若n为奇数，最后一个元素轮空</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
        <span class="n">min_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">findMax</span><span class="p">(</span><span class="n">max_group</span><span class="p">,</span> <span class="n">max_group</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>  <span class="c1">// n/2 + 1个元素</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">findMin</span><span class="p">(</span><span class="n">min_group</span><span class="p">,</span> <span class="n">min_group</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>   
    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个算法的实现要比第一个要复杂些，但是效率会高一些。从上面的代码可以看出，每个小组分别比较找出较大和较小的数的比较次数为<span class="math">\(\frac{n}{2}\)</span>次，从两个子集中找出最大和最小的数的比较次数都为<span class="math">\(\lceil\frac{n}{2}\rceil-1\)</span>次，那么总的比较次数就是：
</p>
<div class="math">$$W(n) = \frac{n}{2} + 2 * (\lceil\frac{n}{2}\rceil-1)=\lceil\frac{3n}{2}\rceil-2$$</div>
<p>
可以证明这个算法是所有同时找最大和最小算法中时间复杂度最低的算法。</p>
<p>等效的实现：</p>
<div class="highlight"><pre><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">findMaxMin</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="n">min</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>   
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="p">}</span>   
        <span class="n">start</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>   
    <span class="k">for</span><span class="p">(;</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// 每两个元素需要3次比较</span>
        <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
        <span class="p">}</span>   
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span>
                <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span>
                <span class="n">min</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">start</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
        <span class="p">}</span>   
    <span class="p">}</span>   
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">max</span><span class="p">);</span>
    <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">min</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>不需要使用额外的数组来保存每次的较大值集合。如果n是奇数，就将最大值和最小值都设为第一个元素的值，然后剩余的元素两两比较，把较大的元素与当前的最大值进行比较，把较小的元素与当前的最小值进行比较，这样每两个元素就需要3次比较；如果n是偶数，就将最大值初始化为前两个元素较大的那个，较小的那个就作为最小值的初始值，然后与n为奇数的情况一样。</p>
<h2>选第二大问题</h2>
<p>最简单方法的就是调用findMax找到最大的元素，然后从L中删除max，再调用findMax找出剩下元素的最大元素，就是L中的第二大元素second。时间复杂度为
</p>
<div class="math">$$W(n)=n - 1 + n - 2 = 2n - 3$$</div>
<p>下面考虑锦标赛算法：</p>
<ol>
<li>将L的元素两两一组，分为<span class="math">\(\frac{n}{2}\)</span>组（若n为奇数，有一个数轮空）；</li>
<li>每组内进行比较，将较小的淘汰，每组中较大的元素和轮空的元素（如果有的话）进入下一轮；</li>
<li>进入下一轮的元素个数为<span class="math">\(\lceil\frac{n}{2}\rceil\)</span>个，对这些元素仍然两两一组进行比较，较大进入下一轮，知道产生“冠军”，即最大元素为止；那么如何找到第二个大元素呢？</li>
<li>首先，可以观察到，第二大的元素只能在与第一大的元素直接比较所淘汰的元素中产生（如果这个元素被max之外的元素淘汰，那么这个元素就最大只能第三大了）。这样，我们只需在被max比较中淘汰的元素。</li>
<li>在比较的过程中，将每个元素所淘汰的元素记录下来，等找到max后，只需找出max淘汰记录中的最大元素即可，这就是第二大元素。</li>
</ol>
<p>算法实现：</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="nf">findSecond</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">L</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">table</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// 一直进行比较，直到L中只有一个元素，即最大值</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">max_group</span><span class="p">;</span>  <span class="c1">// 保存本轮比较较大的数</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">table</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="p">}</span>   
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">table</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]].</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
            <span class="p">}</span>   
        <span class="p">}</span>   
        <span class="k">if</span><span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_group</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">L</span><span class="p">[</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>                                                                                                                                                               
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 若当前序列中元素的个数为奇数</span>
        <span class="p">}</span>   
        <span class="k">else</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="n">L</span> <span class="o">=</span> <span class="n">max_group</span><span class="p">;</span>
    <span class="p">}</span>   

    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">findMax</span><span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">table</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]].</span><span class="n">size</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个算法的时间复杂度是多少呢？算法所做的比较次数分为两部分：</p>
<p>（1）找最大元素max过程中的比较次数。每次比较都淘汰一个元素，淘汰n-1个元素的比较次数就是n-1；</p>
<p>（2）在产生max后在其淘汰序列中找最大所需要的比较次数。这个比较次数等于max淘汰序列中的元素个数减1，而不难看出经过<span class="math">\(\lceil logn \rceil\)</span>次淘汰后只剩下一个元素max，所以max淘汰序列中的元素个数为<span class="math">\(\lceil logn \rceil\)</span>。</p>
<p>所以，该算法的时间复杂度为：
</p>
<div class="math">$$W(n) = n - 1 + \lceil logn \rceil - 1 = n + \lceil logn \rceil - 2$$</div>
<p>可以证明，对于找第二大的问题，以上的算法是时间复杂度最低的算法。</p>
<h2>选第k小问题</h2>
<p>以上讨论了选择问题的一些特例情况，下面考虑一般性的选择第k小的问题。</p>
<p>容易想到的一种做法是对数组S进行排序，然后输出第k小的元素，时间复杂度为O(nlogn)。</p>
<p>那么是否存在O(n)时间复杂度的算法？下面我们考虑分治算法。为了叙述方便，不妨假设S中的元素彼此不相等。</p>
<p>（1）以S中某元素<span class="math">\(m^*\)</span>作为标准将S划分成两个子数组<span class="math">\(S_1\)</span>和<span class="math">\(S_2\)</span>，其中<span class="math">\(S_1\)</span>中的元素都比<span class="math">\(m^*\)</span>小，<span class="math">\(S_2\)</span>中的元素都比<span class="math">\(m^*\)</span>大。</p>
<p>（2）令<span class="math">\(|S_1|\)</span>表示<span class="math">\(S_1\)</span>子数组中元素的个数，<span class="math">\(|S_2|\)</span>表示<span class="math">\(S_2\)</span>子数组中元素的个数。</p>
<p>（3）如果<span class="math">\(k \leq |S_1|\)</span>，那么原问题就转化为求：在<span class="math">\(S_1\)</span>中找第k小的元素；</p>
<p>（4）如果<span class="math">\(k = |S_1|+1\)</span>，那么<span class="math">\(m^*\)</span>就是所要找的第k小的元素；</p>
<p>（5）如果<span class="math">\(k \gt |S_1|+1\)</span>，那么原问题就转化为在<span class="math">\(S_2\)</span>中找出第<span class="math">\(k'\)</span>小的元素，其中<span class="math">\(k' = k - |S_1| - 1\)</span></p>
<p>可以看出，算法的关键就是如何确定划分S的元素<span class="math">\(m^*\)</span>，它需要满足以下条件：</p>
<p>（1）寻找<span class="math">\(m^*\)</span>的代价不能太高，如果是O(nlogn)那么不如直接使用排序的方法求解。如果直接寻找<span class="math">\(m^*\)</span>，时间应该是O(n)。设选择算法的时间复杂度为T(n)，递归调用这个算法在S的一个真子集上寻找<span class="math">\(m^*\)</span>，应该使用T(cn)时间，这里c是一个小于1的常数，反映了M的规模与S相比缩小了多少。</p>
<p>（2）考虑最坏的情况，每次递归调用都进入一个规模较大的一个，即子问题规模为<span class="math">\(max(|S_1|, |S_2|)\)</span>，每次调用时，子问题规模与原问题的规模n的比都不超过某个小于1的常数d，调用时间为T(dn)。在采用递归算法寻找<span class="math">\(m^*\)</span>时，要保证c+d&lt;1，否则方程
</p>
<div class="math">$$T(n)=T(cn)+T(dn)+O(n)$$</div>
<p>
的解不会达到O(n)。</p>
<h3>期望为线性时间的选择算法</h3>
<p>与快速排序一样，我们将输入数组进行递归划分。但与快速排序不同的是，选择问题只需处理划分的一边即可。这一差异会在性能分析中体现出来：快排的期望运行时间为O(nlogn)，而选择问题的期望运行时间为O(n)。</p>
<p>算法实现：</p>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">randomInRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">rand_num</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">rand_num</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">randomInRange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="n">swap</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">pos</span><span class="p">]);</span>

    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="o">++</span><span class="n">index</span><span class="p">]);</span>
        <span class="p">}</span>   
    <span class="p">}</span>   

    <span class="n">swap</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">select</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">==</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>

    <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>

    <span class="k">else</span>
        <span class="k">return</span> <span class="n">select</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">k</span> <span class="o">-</span> <span class="n">num</span><span class="p">);</span>

<span class="p">}</span>
</pre></div>


<p>利用了partition过程，它的部分行为是由随机数的输出决定的。以上的select算法的期望运行时间为O(n)，但是最坏运行时间为<span class="math">\(O(n^2)\)</span>，因为每次划分如果不走运的话可能出现总是按余下元素中最大的来进行划分，而划分操作的时间复杂度为O(n)。</p>
<h3>最坏情况为线性时间的选择算法</h3>
<p>现在来看最坏运行时间为O(n)的选择算法，仍然采用递归划分来寻找所需数组，但是，该算法能够保证数组得到很好的划分。</p>
<ol>
<li>
<p>将S进行分组，5个元素一组，共分成<span class="math">\(\lceil \frac{n}{5} \rceil\)</span>组；</p>
</li>
<li>
<p>每组找一个本组的中位数，然后将这些中位数放入集合M中。可以对每组元素进行插入排序，然后确定每组有序元素的中位数；</p>
</li>
<li>
<p>在M中调用select选择算法选出一个M的中位数，这个中位数就是我们要找的<span class="math">\(m^*\)</span>；</p>
</li>
<li>
<p>利用<span class="math">\(m^*\)</span>对数组S进行划分；</p>
</li>
<li>
<p>如果num比划分的低区中的元素数目多1，因此<span class="math">\(m^*\)</span>就是第k小的元素，那么就返回<span class="math">\(m^*\)</span>；</p>
</li>
<li>
<p>如果num &gt; k在低区递归调用select选择算法；如果num &lt; k在高区递归查找第k-num小的元素</p>
</li>
</ol>
<p>可以证明，该算法最坏情况下的时间复杂度为O(n)。</p>
<hr />
<h2>Reference</h2>
<ol>
<li><a href="http://book.douban.com/subject/6434299/">算法设计与分析</a></li>
<li><a href="http://book.douban.com/subject/20432061/">算法导论</a></li>
</ol>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
            </div><!-- /.entry-content -->
            <div class="comments">
              <h3>Comments</h3>
              <div id="disqus_thread"></div>
              <script type="text/javascript">
                var disqus_identifier = "xuan-ze-wen-ti-ji-fu-za-du-fen-xi.html";
                (function() {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = 'http://wengwt.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
              </script>
            </div>


        </div><!-- /.eleven.columns -->

<div class="three columns">

<!--
<h4>Pages</h4>

 <ul>
      <li><a href="/categories.html">分类</a></li>
      <li><a href="/tags.html">标签</a></li>
      <li><a href="/archives.html">归档</a></li>
      <li><a href="/pages/about-me.html">关于我</a></li>
  </ul>
-->

<aside id="sidebar"><!--Google站内搜索开始-->
        <div class="search">
                <!--<h2>站内搜索</h2>-->
                <form method=get action="http://www.google.com/search">
                <input type=text name=q>
                <input type=submit name=btnG value="搜索">
                <input type=hidden name=ie value=UTF-8>
                <input type=hidden name=oe value=UTF-8>
                <input type=hidden name=hl value=zh-CN>
                <input type=hidden name=domains value="http://www.wengweitao.com">
                <input type=hidden name=sitesearch value="http://www.wengweitao.com">
                </form>
        </div>
<!--Google站内搜索结束-->

<h4>分类</h4>
<ul>
		<li><a href="http://www.wengweitao.com/category/bian-cheng-yu-yan.html">编程语言</a></li>
		<li><a href="http://www.wengweitao.com/category/du-shu-bi-ji.html">读书笔记</a></li>
		<li><a href="http://www.wengweitao.com/category/gong-ju.html">工具</a></li>
		<li><a href="http://www.wengweitao.com/category/ji-qi-xue-xi.html">机器学习</a></li>
		<li><a href="http://www.wengweitao.com/category/python.html">Python</a></li>
		<li><a href="http://www.wengweitao.com/category/sheng-huo.html">生活</a></li>
		<li><a href="http://www.wengweitao.com/category/suan-fa-yu-shu-ju-jie-gou.html">算法与数据结构</a></li>
</ul>

<!--
<h4>标签</h4>
<ul class="tagcloud">
        <li class="tag-1"><a href="http://www.wengweitao.com/tag/du-shu-bi-ji.html">读书笔记</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/er-cha-shu.html">二叉树</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/ce-shi.html">测试</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/wan.html">玩</a></li>
        <li class="tag-1"><a href="http://www.wengweitao.com/tag/mian-shi-ti.html">面试题</a></li>
        <li class="tag-3"><a href="http://www.wengweitao.com/tag/ji-ben-gai-nian.html">基本概念</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/gong-ju.html">工具</a></li>
        <li class="tag-1"><a href="http://www.wengweitao.com/tag/python.html">Python</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/pai-xu-suan-fa-ji-chu-zong-jie.html">排序 算法 基础 总结</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/jiao-cheng-linux.html">教程、Linux</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/ji-chu-gai-nian.html">基础概念</a></li>
        <li class="tag-1"><a href="http://www.wengweitao.com/tag/pai-xu-suan-fa-ji-chu.html">排序 算法 基础</a></li>
        <li class="tag-1"><a href="http://www.wengweitao.com/tag/leetcode.html">leetcode</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/go.html">Go</a></li>
        <li class="tag-2"><a href="http://www.wengweitao.com/tag/jiao-cheng.html">教程</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/vim.html">Vim</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/tmux.html">tmux</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/bian-cheng-zhu-ji.html">编程珠玑</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/xiao-yuan.html">校园</a></li>
        <li class="tag-4"><a href="http://www.wengweitao.com/tag/suan-fa-fen-xi.html">算法分析</a></li>
</ul>
-->


<nav class="widget">
  <h4>社交</h4>
  <ul>
    <li><a href="http://weibo.com/u/2678027854">新浪微博</a></li>
    <li><a href="http://www.douban.com/people/wengwt/">豆瓣</a></li>
    <li><a href="http://www.zhihu.com/people/vita-49">知乎</a></li>
    <li><a href="https://github.com/nurnoch">Github</a></li>
    <li><a href="https://www.v2ex.com/member/wwttc">V2EX</a></li>
  </ul>
</nav>

<nav class="widget">
  <h4>友情链接</h4>
  <ul>
    <li><a href="http://netlab.pkusz.edu.cn/">互联网信息工程研发中心</a></li>
    <li><a href="http://www.houcj.net/">houcj's blog</a></li>
    <li><a href="http://www.rudy-yuan.net/">rundy-yuan's blog</a></li>
    <li><a href="http://zwyang.me/blog/">zwyanswer's blog</a></li>
  </ul>
</nav>


</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by  <a href="http://getpelican.com/">Pelican</a> and Theme by Gum © 2015 wwt       
                       <!-- cnzz -->
                    <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1255354158'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1255354158%26show%3Dpic2' type='text/javascript'%3E%3C/script%3E"));</script>  
                    </address>
                   
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>



<script type="text/javascript">
    var disqus_shortname = 'wengwt';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = 'http://' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
  <script src="http://www.wengweitao.com/theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="http://www.wengweitao.com/theme/js/libs/gumby.min.js"></script>
  <script src="http://www.wengweitao.com/theme/js/plugins.js"></script>
</body>
</html>