<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wwt's blog</title><link>http://www.wengweitao.com/</link><description></description><atom:link href="http://www.wengweitao.com/feeds%5Cwwt.rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 25 Apr 2015 10:37:00 +0800</lastBuildDate><item><title>False is False is False 的结果是 True ?</title><link>http://www.wengweitao.com/false-is-false-is-false-de-jie-guo-shi-true.html</link><description>&lt;p&gt;在&lt;a href="https://www.youtube.com/channel/UCgxzjK6GuOHVKR_08TT4hJQ"&gt;PyCon 2015&lt;/a&gt;中提到一个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python中运行，以上命令得到的结果是：&lt;strong&gt;True&lt;/strong&gt;！
而&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python中运行，以上命令得到的结果是：&lt;strong&gt;False&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对于很多Python的初学者肯定会对第一个的运行结果感到有点出乎意料。&lt;/p&gt;
&lt;p&gt;在关于比较运算的Python官方文档中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Formally, if a, b, c, ..., y, z are expressions and op1, op2, ..., opN are comparison operators, then a op1 b op2 c ... y opN z is equivalent to a op1 b and b op2 c and ... y opN z, except that each expression is evaluated at most once.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="c"&gt;# 相当于&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样上面的第一个例子的结果就容易解释了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

&lt;span class="c"&gt;#相当于&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是为什么我们可以在Python中直接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似的这种表达式的原因（而在C/C++中是无法这么写的）。这种写法从某种程度上来说，更符合英语的写法，但是为了避免让人误解，最好还是在适当的地方使用圆括号括起来。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 25 Apr 2015 10:37:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-25:false-is-false-is-false-de-jie-guo-shi-true.html</guid><category>Python</category></item><item><title>Vim入门教程</title><link>http://www.wengweitao.com/vimru-men-jiao-cheng.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Vim 在编辑器中是神一样的存在，熟练掌握Vim将极大提高编辑文本的效率。本文将介绍Vim最基本的操作和技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;操作篇&lt;/h2&gt;
&lt;h3&gt;模式&lt;/h3&gt;
&lt;p&gt;Vim中一共有4种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通模式：启动Vim后，为普通模式，所有键都为功能键。&lt;/li&gt;
&lt;li&gt;插入模式：按下键i，进入插入模式，此时可以输入文本，返回普通模式，按Esc键。&lt;/li&gt;
&lt;li&gt;可视模式：按下键v，进入可视模式，可以移动光标对文本进行选择&lt;/li&gt;
&lt;li&gt;命令行模式：输入":"进入命令行模式，运行Vim的命令&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;最基本的移动&lt;/h3&gt;
&lt;p&gt;将光标上下左右移动，分别对应kjhl四个键。可以在前面加数字代表移动多个单位。如10j下移10行。&lt;/p&gt;
&lt;h3&gt;在文件中的移动&lt;/h3&gt;
&lt;p&gt;G-----移动到最后一行&lt;/p&gt;
&lt;p&gt;gg ------ 移动到第一行&lt;/p&gt;
&lt;p&gt;10G ------ 跳到第10行&lt;/p&gt;
&lt;p&gt;75% ----- 跳转到全文75%的地方&lt;/p&gt;
&lt;h3&gt;移动到指定字符&lt;/h3&gt;
&lt;p&gt;使用f,t,F,T可以再当前行快速移动。&lt;/p&gt;
&lt;p&gt;fx ----- 移动到光标右边的第一个’x'字符上&lt;/p&gt;
&lt;p&gt;Fx ----- 反方向查找，也就是移动到光标左边的指定字符上。&lt;/p&gt;
&lt;p&gt;tx ----- 移动到光标右边的第一个’x'字符之前&lt;/p&gt;
&lt;p&gt;Tx ----- 它移动到光标右边的指定字符'x'之后。&lt;/p&gt;
&lt;p&gt;; ----- 重复前一次输入的f, t, F, T命令&lt;/p&gt;
&lt;p&gt;, ----- 反方向重复前一次输入的f, t, F,T命令。&lt;/p&gt;
&lt;p&gt;";"和","这两个命令前也可以使用数字来表示倍数。也可以在命令前面使用数字，表示倍数。例如：
3fx ----- 移动到光标右边的第3个’x'字符上。&lt;/p&gt;
&lt;h3&gt;移动到行首行尾&lt;/h3&gt;
&lt;p&gt;0 ------ 移动到行首&lt;/p&gt;
&lt;p&gt;$ ------ 移动到行尾&lt;/p&gt;
&lt;p&gt;^ -------移动到第一个非空白字符行首&lt;/p&gt;
&lt;h3&gt;按单词移动&lt;/h3&gt;
&lt;p&gt;w ------ 移动光标的下一个单词的词首&lt;/p&gt;
&lt;p&gt;b ------ 移动光标的上一个单词的词首&lt;/p&gt;
&lt;p&gt;e ------ 移动光标的下一个单词的词尾&lt;/p&gt;
&lt;p&gt;ge ------ 移动光标的上一个单词的词尾&lt;/p&gt;
&lt;h3&gt;按窗口移动&lt;/h3&gt;
&lt;p&gt;H ------ 让光标跳到当前窗口的顶部
M ------ 让光标跳到当前窗口的中部
L ------ 让光标跳到当前窗口的底部&lt;/p&gt;
&lt;h3&gt;相对于光标滚屏&lt;/h3&gt;
&lt;p&gt;zt ------ 把光标所在行移动窗口的顶端
zz ------ 把光标所在行移动窗口的中间
zb ------ 把光标所在行移动窗口的底部&lt;/p&gt;
&lt;h3&gt;各种插入&lt;/h3&gt;
&lt;p&gt;i ------ 在光标处插入
a ------ 在光标后插入
o ------ 在当前行后插入一个新行
O ------ 在当前行前插入一个新行
cw ------ 替换从光标所在位置后到一个单词结尾的字符（c键和w键）&lt;/p&gt;
&lt;h3&gt;复制和粘贴&lt;/h3&gt;
&lt;p&gt;yy ------ 拷贝当前行
p ------ 粘贴
也可以在yy和p的前面加上数字：
3yy ------ 拷贝当前行起的3行
3p ------ 粘贴文本3次&lt;/p&gt;
&lt;h3&gt;查找&lt;/h3&gt;
&lt;p&gt;在normal模式下进行查找。
/ ------ 在Normal模式下输入”/“，然后输入你想查询的字符串，回车，就跳转到第一个匹配的地方了。
? ------ 与/相反的方向查找
n ------ 重复上一次的查找命令
N ------ 按相反方向重复上一次的查找命令&lt;/p&gt;
&lt;p&gt;在输入”/“或”?“后，用上、下光标键(或CTRL-P/CTRL-N)翻看历史记录，然后再次执行这个查找。
你还可以使用”q/“和”q?“命令，在vim窗口最下面打开一个新的窗口，这个窗口会列出你的查找历史记录，你可以使用任何vim编辑命令对此窗口的内容进行编辑，然后再按回车，就会对光标所在的行的内容进行查找。如下图所示：
&lt;img alt="q_search" src="./imgs/q_search.png" /&gt;&lt;/p&gt;
&lt;p&gt;* ------ 查找光标所在位置的单词，所有匹配的单词将高亮显示，并跳到下一个匹配项上
# ------ 查找光标所在位置的单词，所有匹配的单词将高亮显示，并跳到上一个匹配项上&lt;/p&gt;
&lt;p&gt;% ------ 括号匹配移动，即移动到与当前光标所在括号匹配的括号的位置&lt;/p&gt;
&lt;h3&gt;替换字符串&lt;/h3&gt;
&lt;p&gt;%s/源字符串/目的字符串/g ------ 将当前文档中所有的源字符串替换为目的字符串&lt;/p&gt;
&lt;h3&gt;删除、撤销和重做&lt;/h3&gt;
&lt;p&gt;dd ------ 删除当前行
dt ------ 删除当前行直到遇到它后面跟的符号
u ------ 撤销上一次操作
ctrl + r ------ redo重做 
如我用dd删除了当前行，如果后悔了不想删除可以使用u命令撤销，如果还是想删除可以使用ctrl + r继续删除。&lt;/p&gt;
&lt;h3&gt;打开、保存和退出&lt;/h3&gt;
&lt;p&gt;以下操作除非特别说明都在命令模式下操作，即每个命令前都要加入":"，如:q退出。
q ------ 退出当前文件
q! ------ 强制退出当前文件，不保存
w ------ 写入文件，存盘
wq ------ 保存退出当前文件
x ------ 保存退出当前文件
ZZ ------ 保存退出当前文件（普通模式下运行）
e filepath ------ 打开一个文件
saveas filepath ------ 另存为
bn ------ 当同时打开很多文件后，可以使用bn切换下一个文件。
bp ------ 当同时打开很多文件后，可以使用bp切换上一个文件。&lt;/p&gt;
&lt;h3&gt;重复命令&lt;/h3&gt;
&lt;p&gt;. ------ 重复上一次离开插入模式之前的全部命令
n&amp;lt; command &amp;gt; ------ 之前提到过的重复command命令n次&lt;/p&gt;
&lt;h3&gt;光标移动和命令配合使用&lt;/h3&gt;
&lt;p&gt;0y&lt;span class="math"&gt;\( ------ 复制本行（0移动到行首，y从这里开始复制，\)&lt;/span&gt;直到本行最后一个字符） 
ye ------ 复制从当前位置到下一个单词的词尾&lt;/p&gt;
&lt;h2&gt;技巧篇&lt;/h2&gt;
&lt;h3&gt;找出当前文档中相同的行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;
&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;$\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;按时间撤消&lt;/h3&gt;
&lt;p&gt;Vim 7 包括了一个让用户跳转到任何编辑点之前或之后的新特性。如使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;earlier&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以返回到 10 分钟以前的编辑状态。
又如使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;later&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以跳转到 5 秒以后的编辑点。另外，可以使用 :undolist 命令查看缓冲区存在的撤销分支列表。而通过 :undo &amp;lt; number&amp;gt; 命令则能够移到撤销的某个分支。&lt;/p&gt;
&lt;h3&gt;删除当前文档的所有空行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;在每行的行首或行尾插入指定字符串&lt;/h3&gt;
&lt;p&gt;行首插入： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^/&lt;/span&gt;&lt;span class="n"&gt;your_word&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;行尾插入：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;your_word&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如在每行前面插入行号如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读取shell命令&lt;/h3&gt;
&lt;p&gt;如插入日期：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;:r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来。&lt;/p&gt;
&lt;h3&gt;统计某个单词出现的次数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="c1"&gt;//gn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计的结果会在底部的状态栏显示。&lt;/p&gt;
&lt;h3&gt;Vim粘贴缩进问题&lt;/h3&gt;
&lt;p&gt;在Vim中粘贴Python代码后，缩进就全乱了。进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;paste&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后使用:set nopaste恢复普通模式。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;好了，这篇文章已经说了不少关于Vim的基本操作和技巧，如果能掌握这些就可以比较流畅的使用Vim了。之后会有更多关于Vim操作的文章。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 16 Apr 2015 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-16:vimru-men-jiao-cheng.html</guid><category>Vim</category></item><item><title>使用Pelican + Github Pages搭建个人博客</title><link>http://www.wengweitao.com/shi-yong-pelican-github-pagesda-jian-ge-ren-bo-ke.html</link><description>&lt;blockquote&gt;
&lt;p&gt;最近有不少同学问我，如何使用Python的Pelican搭建一个像我这样的一个个人博客。今天正好论文投稿结束，于是便抽出时间写这篇教程，希望对大家有用。有任何疑问欢迎在评论里说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;静态网站&lt;/h2&gt;
&lt;p&gt;早在多年之前，我就使用过WordPress + MySQL + Apache在国外的主机上搭建过个人博客。但是，对于个人博客而言，使用WordPress这种动态网站，还需要后台支持各种数据库，就显得过于臃肿。最近几年人们纷纷转向静态博客，加之Github Pages和Dropbox这些地方可以免费的放置这些静态页面，于是各种静态网站生成器便如雨后春笋出现，不完全统计的就有392种之多，这里由列出了所有的&lt;a href="https://staticsitegenerators.net/"&gt;Static site generator 列表及 Github 关注度排名&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;什么是静态网站&lt;/h3&gt;
&lt;p&gt;静态的网站全部由静态网页构成，这些网页都是提前生成好的，不需要与后台数据库进行交交互，并且内容不会动态改变。静态网站具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不需要数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问速度更快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本没有安全性的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使写作者更加专注于内容本身&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们只需要使用任何一个编辑器利用markdown写出文章，生成静态html即可，不需要php，也不需要数据库，你可以发布在任何你喜爱的服务器上。 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的！&lt;/p&gt;
&lt;h3&gt;几种常见的静态博客&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jekyll可以说是静态网站的鼻祖，也是最著名的静态博客引擎。它是由GitHub创始人之一使用Ruby写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;a href="https://github.com/imathis/octopress"&gt;Octopress&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Octopress是Jekyll的一个框架，但是降低了使用和部署的难度，目前也有大量的人在使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;a href="https://github.com/hexojs/hexo"&gt;Hexo&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hexo是使用Node.js编写的快速、简单且功能强大静态博客框架，值得一提的是Hexo作者来自中国台湾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;a href="https://github.com/spf13/hugo"&gt;Hugo&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hugo是使用Go语言编写的，特点是网站编译的速度非常快。记得在听IPN旗下的博客节目&lt;a href="https://ipn.li/kernelpanic/3/"&gt;内核恐慌&lt;/a&gt;中Rio谈到，使用Jekyll编译2000+网页需要12分钟左右，使用未经优化的Python多核程序进行编译需要5分钟左右，而使用Hugo只用了12秒！可见速度之快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是本博客使用的框架，是Python编写的静态博客框架中最流行的一种。Pelican作者来自法国，pelican在法语中的是记事本的意思，非常适合用来作为个人博客，作为一名Pythoner使用Pelican也就理所当然了。&lt;/p&gt;
&lt;h2&gt;如何搭建静态博客&lt;/h2&gt;
&lt;p&gt;这一部分，我将详细介绍如何使用Github Pages + Pelican搭建一个非常cool且完全免费的个人博客。&lt;/p&gt;
&lt;h3&gt;在本地搭建Pelican&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用pip安装Pelican即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通常我们都是使用Markdown来书写文章，所以还需要Pelican支持Markdown：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2.生成站点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在你的电脑上，建立一个目录，作为博客的主目录。我们假定，它的名称为blog。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;quickstart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行一下命令后，就生成了一个站点，包含以下目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;blog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;              &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;存放输入的源文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;   &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;存放手工创建的静态页面&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;               &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;生成的输出文件&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;develop_server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便开启测试服务器&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;Makefile&lt;/span&gt;             &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便管理博客的&lt;/span&gt;&lt;span class="n"&gt;Makefile&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;pelicanconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;       &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主配置文件&lt;/span&gt;
&lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;publishconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;       &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主发布文件，可删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，生成的过程中需要配置一些东西，大部分都可以一路回车，选择默认设置，其中有一步需要你填写自己的网站域名，如果暂时没有，可以先随便设置，之后可以在pelicanconf.py文件中进行修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.创建文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，就可以使用你喜欢的任何编辑器用markdown语法写你的第一篇文章。需要在每篇文章的开头填入以下关于文章的元信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;Title:&lt;/span&gt; &lt;span class="err"&gt;文章标题&lt;/span&gt;
&lt;span class="nl"&gt;Date:&lt;/span&gt; &lt;span class="err"&gt;创建日期&lt;/span&gt;
&lt;span class="nl"&gt;Modified:&lt;/span&gt; &lt;span class="err"&gt;修改日期&lt;/span&gt;
&lt;span class="nl"&gt;Category:&lt;/span&gt; &lt;span class="err"&gt;文章分类，标志本文处于该分类下&lt;/span&gt;
&lt;span class="nl"&gt;Tags:&lt;/span&gt; &lt;span class="err"&gt;文章标签，标志本文处于该标签下&lt;/span&gt;
&lt;span class="nl"&gt;Slug:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="err"&gt;中该文章的链接地址&lt;/span&gt;
&lt;span class="nl"&gt;Author:&lt;/span&gt; &lt;span class="err"&gt;作者&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中Title和Category是必选的，其他的选择可以不写。在这些元信息的后面就是文章的内容了，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;Modified&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;05&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;
&lt;span class="n"&gt;Category&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;publishing&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;
&lt;span class="n"&gt;Authors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Alexis&lt;/span&gt; &lt;span class="n"&gt;Metaireau&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Conan&lt;/span&gt; &lt;span class="n"&gt;Doyle&lt;/span&gt;
&lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Short&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;feeds&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把以上的文件保存在content目录下，如保存为./content/test.md&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.生成静态页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回博客的主目录（即包含pelican文件的目录），然后在命令行中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就会自动在output目录下生成content目录下markdown文件对应的静态页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.预览站点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以先在本地预览站点，在博客主目录下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;SimpleHTTPServer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在通过在浏览器中访问 http://localhost:8000/ 就可以看到你的站点了。&lt;/p&gt;
&lt;h3&gt;部署到Github上&lt;/h3&gt;
&lt;p&gt;Github就提供了&lt;a href="https://pages.github.com/"&gt;Pages&lt;/a&gt;功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。于是，我们就可以将生成的静态网页部署在Github Pages上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.建立一个repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;登陆自己的Github主页，创建一个名字为：username.github.io 的repository。
其中必须修改username为自己账号的username，如：nurnoch.github.io&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.将生成的静态网站上传到repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入到output目录下，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/username/username.github.com.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将username替换为自己的github用户名，初始化，并添加远程repository，将会生成 .git的目录，然后我们将output目录下的所有文件上传到github：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;update&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时可能需要输入账户和密码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.开始访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问http://username.github.io 就可以看到自己的个人博客站点了。
注意：第一次需要等待一段时间后才能看到。&lt;/p&gt;
&lt;h2&gt;配置Pelican&lt;/h2&gt;
&lt;p&gt;通过修改在博客根目录下的pelicanconf.py文件，可以对Pelican进行配置，具体配置可以&lt;a href="http://docs.getpelican.com/en/3.4.0/settings.html"&gt;参考这里&lt;/a&gt;。以下，是官方文档给出的一个配置例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;

&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Alexis Métaireau&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Alexis&amp;#39; log&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://blog.notmyidea.org&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Europe/Paris&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# can be useful in development, but set to False when you&amp;#39;re ready to publish&lt;/span&gt;
&lt;span class="n"&gt;RELATIVE_URLS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://github.com/ametaireau/&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;blog-notmyidea&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;PDF_GENERATOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="n"&gt;REVERSE_CATEGORY_ORDER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;FEED_ALL_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;CATEGORY_FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.rss.xml&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Biologeek&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://biologeek.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Filyb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://filyb.info/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Libert-fr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://www.libert-fr.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;N1k0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://prendreuncafe.com/blog/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Tarek Ziadé&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://ziade.org/blog&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Zubin Mithra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://zubin71.wordpress.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;twitter&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://twitter.com/ametaireau&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;lastfm&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://lastfm.com/user/akounet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://github.com/ametaireau&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="c"&gt;# global metadata to all the contents&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;yeah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;it is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="c"&gt;# path-specific metadata&lt;/span&gt;
&lt;span class="n"&gt;EXTRA_PATH_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;extra/robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;path&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# static paths will be copied without parsing their contents&lt;/span&gt;
&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;pictures&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;extra/robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# custom page generated with a jinja2 template&lt;/span&gt;
&lt;span class="n"&gt;TEMPLATE_PAGES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pages/jinja2_template.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;jinja2_template.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# code blocks with line numbers&lt;/span&gt;
&lt;span class="n"&gt;PYGMENTS_RST_OPTIONS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linenos&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# foobar will not be used, because it&amp;#39;s not in caps. All configuration keys&lt;/span&gt;
&lt;span class="c"&gt;# have to be in caps&lt;/span&gt;
&lt;span class="n"&gt;foobar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;barbaz&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以根据自己的需求修改其中的：站点信息、时区和日期格式、默认语言和环境、主题、插件等。&lt;/p&gt;
&lt;h3&gt;增加sitemap&lt;/h3&gt;
&lt;p&gt;Pelican有着丰富的插件，可以配置sitemap插件, 生成 sitemap.xml 供搜索引擎使用。
首先，下载Pelican的所有插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/getpelican/pelican-plugins.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改pelicanconf.py文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sitemap&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# 配置sitemap 插件&lt;/span&gt;
&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用浏览器访问 &lt;em&gt;your domain name&lt;/em&gt;/sitemap.xml即可看到生成的 Sitemap 了。&lt;/p&gt;
&lt;h3&gt;增加评论功能&lt;/h3&gt;
&lt;p&gt;Pelican支持Disqus评论, 可以在Disqus上申请一个账号, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;*your Disqus username*&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样你的博客就自动支持评论功能了。&lt;/p&gt;
&lt;h3&gt;在文章中插入本地图片&lt;/h3&gt;
&lt;p&gt;content目录下建立一个 imgs目录
然后在 pelicanconf.py 中添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;imgs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在文章中引用图片：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;aimg&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;imgs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;插入数学公式&lt;/h3&gt;
&lt;p&gt;Pelican默认是不支持数学公式的，如果想要方便的使用Pelican书写数学公式，可以&lt;a href="http://www.wengweitao.com/shi-pelicanzhi-chi-latexshu-xue-gong-shi.html"&gt;参考这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;绑定域名&lt;/h2&gt;
&lt;p&gt;你现在可以通过https://username.github.io 访问你的博客，但是如果拥有一个自己的域名不是更酷吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.购买一个域名&lt;/strong&gt;
很多地方都能买到域名，如godaddy等。价格基本都差不多，我是在&lt;a href="http://client.gegehost.com/domainchecker.php"&gt;GegeHost&lt;/a&gt;上买的。现在有好多种顶级域名，不过我还是推荐.com的。输入一个域名，如果没有人注册过，你就可以注册，付款后这个域名就归你了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.增加CNAME文件&lt;/strong&gt;
在repo的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;www.wengweitao.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在DNS要新建一条CNAME记录，指向username.github.com（请将username换成你的用户名）。这里推荐将你的域名添加到&lt;a href="https://www.dnspod.cn/"&gt;DNSPod&lt;/a&gt;，方便管理。&lt;/p&gt;
&lt;p&gt;Ok，现在你的个人博客站点就搭建好了！搭建容易，写博客难，希望各位都能坚持下去，把自己的心得体会分享给大家！&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;REFERENCES&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Static Site Generators: https://staticsitegenerators.net/&lt;/li&gt;
&lt;li&gt;Pelican Docs: http://docs.getpelican.com/en/3.5.0/&lt;/li&gt;
&lt;li&gt;github Pages和Jekyll入门：http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 16 Apr 2015 13:46:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-16:shi-yong-pelican-github-pagesda-jian-ge-ren-bo-ke.html</guid><category>教程</category></item><item><title>互联网实验室河源游玩</title><link>http://www.wengweitao.com/hu-lian-wang-shi-yan-shi-he-yuan-you-wan.html</link><description>&lt;p&gt;4月份，春暖花开，正是出游的好时间。实验室一年一度的集体出游（当然是老板全部报销啦~），就定在了4月11日和12日这两天，今年去的地方是——河源。实验室一群小伙伴度过了非常欢乐的一个周末。&lt;/p&gt;
&lt;h3&gt;河源&lt;/h3&gt;
&lt;p&gt;在去&lt;a href="http://zh.wikipedia.org/wiki/%E6%B2%B3%E6%BA%90%E5%B8%82"&gt;河源&lt;/a&gt;游玩之前，仅仅是听过有河源这个地方，其他的都是这次旅游完才了解到的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河源在广东的东北部，从深圳坐大巴过去大概2个半小时。&lt;/li&gt;
&lt;li&gt;河源是一个地级市，河源市辖1个市辖区、5个县，但是地方感觉不太大。市区里面还分新城区和老城区，虽然是新城区不过高楼大厦仍然极少。&lt;/li&gt;
&lt;li&gt;大量客家人&lt;/li&gt;
&lt;li&gt;河源菜是东江菜的典型代表，而东江菜是粤菜的主要流派之一，其特点是偏重“肥、咸、熟”&lt;/li&gt;
&lt;li&gt;景点：&lt;ul&gt;
&lt;li&gt;万绿湖&lt;/li&gt;
&lt;li&gt;镜花缘&lt;/li&gt;
&lt;li&gt;野趣沟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;行程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;野趣沟风景区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟1" src="./imgs/河源1.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟2" src="./imgs/河源2.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟3" src="./imgs/河源5.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;山上的风景还挺不错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜花缘&lt;/strong&gt;
&lt;img alt="镜花缘" src="./imgs/河源8.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;镜花缘里面实验室大合影&lt;/p&gt;
&lt;p&gt;&lt;img alt="镜花缘2" src="./imgs/河源7.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;通过镜子合影，有创意&lt;/p&gt;
&lt;p&gt;&lt;img alt="镜花缘3" src="./imgs/河源9.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;女儿国表演&lt;/p&gt;
&lt;p&gt;此外，晚上我们还泡了温泉，一共60多个池子，牛奶的、艾草的、薰衣草的等等，非常舒服。&lt;/p&gt;
&lt;h3&gt;聚餐&lt;/h3&gt;
&lt;p&gt;回到深圳，还剩了不少经费，就实验室集体聚餐一次。除了研三忙着写毕业论文的师兄师姐，大家基本都到了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="聚餐" src="./imgs/聚餐1.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这次河源之行大家还是非常欢乐。平时大家一直在实验室待着，天天对着电脑和论文，难得有这么好的机会，实验室12级，13级，14级的小伙伴们能够聚在一起出去游玩，彼此之间的感情也更加好了。今后，应该多组织大家出去。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 14 Apr 2015 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-14:hu-lian-wang-shi-yan-shi-he-yuan-you-wan.html</guid><category>玩</category></item><item><title>编写高质量Python代码（4）——设计模式</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-4-she-ji-mo-shi.html</link><description>&lt;blockquote&gt;
&lt;p&gt;本文将介绍如何写出Pythonic的设计模式代码，让设计模式更好的应用在实际的Python编程当中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议50：利用模块设计实现单例模式&lt;/h3&gt;
&lt;p&gt;GOF的23种设计模式中，单例是最常用的模式，通过单例模式可以保证系统中一个类只有一个实例而且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。&lt;/p&gt;
&lt;p&gt;Python语言实现实例没有那么方便，因为缺乏声明私有构造函数的语法元素，实例又带有类型信息。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Singleton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;_Singleton&lt;/span&gt;
&lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;another&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# 输出 &amp;lt;class &amp;#39;__main__._Singleton&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然把Singleton的类定义删除了，但是还是可以通过已有实例的__class__属性生成一个新的实例。&lt;/p&gt;
&lt;p&gt;其实模块采用的方法是天然的单例实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有变量都会绑定到模块&lt;/li&gt;
&lt;li&gt;模块只初始化一次&lt;/li&gt;
&lt;li&gt;import 机制是线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# World.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Sun&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;Sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;Sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;# 在入口文件main.py里导入&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;World&lt;/span&gt;
&lt;span class="n"&gt;World&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Borg模式：“实例的唯一性”本身是有问题的，实际更关注的是实例的状态，只要所有的实例共享状态（可以简单理解为属性）、行为（简单理解为方法）一致就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Borg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;__shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__dict__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__shared_state&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议51：用mixin模式让程序更加灵活&lt;/h3&gt;
&lt;p&gt;在理解mixin之前，需要重温下模板方法模式。所谓&lt;strong&gt;模板方法模式&lt;/strong&gt;就是在一个方法中定义一个算法（行为）的骨架，并将一些实现步骤延迟到子类中。可以使子类在不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;
&lt;p&gt;每一个类都有一个__bases__属性，它是一个元组，用来存放所有的基类。与其他静态语言不同，Python中的基类在运行中可以动态改变。所以当我们向其中增加新的基类时，这个类就拥有了新的方法，也就是所谓的&lt;strong&gt;混入(mixin)&lt;/strong&gt;。这种动态性的好处就是代码获得了更丰富的扩展功能。可以后期增加基类，就可以增强功能，多么方便！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_teapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UseKungfuTeapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_teapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;KungfuTeapot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;simple_tea_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;coffee_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseCoffeepot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tea_and_coffee_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UseCoffeepot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议52：用发布订阅模式实现松耦合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发布订阅模式(publis/subscribe或者pub/sub)&lt;/strong&gt;是一种编程模式，消息的发送者不会发送其消息给特定接收者，而是将发布消息分为不同类别直接发布，并不关注订阅者是谁。而订阅者可以对一个或者多个类别感兴趣，且只接收感兴趣的消息，并且不关注是哪个发布者发布的消息。
发布订阅模式的优点是发布者与订阅者松散的耦合，双方不需要知道对方的存在。要实现这个模式需要一个中间代理人，在实现中一般称为Broker，它维护着发布者和订阅者的关系：订阅者把感兴趣的主题告诉它，而发布者的信息也通过它路由到各个订阅者处。简单的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Broker.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;
&lt;span class="n"&gt;route_table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它的应用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Broker&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;Broker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Broker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wwt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是简化的实现，blinker和Python-message两个模块提供了更加完备的实现。下面以python-message为例说明。
首先需要安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;message&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了sub()/pub()之外，Python-message还支持取消订阅和终止消息传递。&lt;/p&gt;
&lt;h3&gt;建议53：用状态模式美化代码&lt;/h3&gt;
&lt;p&gt;所谓&lt;strong&gt;状态模式&lt;/strong&gt;，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。
状态模式主要用于控制一个对象状态的条件表达式过于复杂的情况，其可把状态的判断逻辑转移到表示不同状态的一系列类中，进而把复杂的判断逻辑简化。
例如，一个人，工作日和周日的日常生活是不同的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;workday&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;work hard&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;weekend&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;play harder!&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weekend&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;workday&lt;/span&gt;
        &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过在不同条件下将实例的方法替换掉，就实现了状态模式。&lt;/p&gt;
&lt;p&gt;在网络编程中，需要判断用户是否登录，只有登录后才能调用某些函数，如果每个函数前面都加上if ... raise ... 那么这样代码会很难看。一个解决方法是使用decorator:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ensure_signin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_signin&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;NeedSignin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@ensure_signin&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;do_sth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是如果需要检查的不仅仅是用户是否登陆，还有其他需求，那么如果在每个函数前面都加上4,5个装饰器，那样也很难看。这时候就可以使用state的状态转移。&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 13 Apr 2015 23:31:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-13:bian-xie-gao-zhi-liang-pythondai-ma-4-she-ji-mo-shi.html</guid><category>Python</category></item><item><title>使Pelican支持LaTex数学公式</title><link>http://www.wengweitao.com/shi-pelicanzhi-chi-latexshu-xue-gong-shi.html</link><description>&lt;p&gt;作为一个技术博客，在写文章的时候，肯定需要经常输入各种公式符号。在之前写一篇文章的时候，发现Pelican默认是不支持编辑数学公式的。之前用过一些在线的markdonw编辑器，都是通过&lt;a href="https://github.com/mathjax/mathjax"&gt;MathJax&lt;/a&gt;来支持在markdown中书写数学公式，而且用起来非常的方便，语法基本和LaTex一样。于是，就找到了一种简单的使Pelican支持LaTex语法的数学公式，在这里分享给大家。&lt;/p&gt;
&lt;h2&gt;如何使Pelican支持渲染数学公式&lt;/h2&gt;
&lt;p&gt;最简单的方法就是使用Pelican的一个插件——&lt;a href="https://github.com/barrysteyn/pelican_plugin-render_math"&gt;pelican_plugin-render_math&lt;/a&gt;。
这个插件可以通过使用MathJax使pelican拥有渲染数学公式的能力，并且同时支持Markdown 和reStructuredText，用起来也非常的方便！&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;在Pelican的安装目录中找到Pelican的配置文件pelicanconf.py，在文件中增加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;render_math&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使插件生效，必须保证插件render_path所在的目录是可以访问的。通常，这个插件同其他插件都一起放在pelican-plugins目录中。&lt;/p&gt;
&lt;p&gt;没错，只要这一步你的pelican网站就可以通过mathjax渲染数学公式了！不需要更改任何模板文件。&lt;/p&gt;
&lt;p&gt;Just use and enjoy!&lt;/p&gt;
&lt;h2&gt;开始使用&lt;/h2&gt;
&lt;p&gt;对于内联的公式，将公式用\&lt;span class="math"&gt;\(...\\)&lt;/span&gt;包含起来，对于需要单独另起一行显示的公式使用\&lt;span class="math"&gt;\(\\)&lt;/span&gt;...\&lt;span class="math"&gt;\(\\)&lt;/span&gt;包含起来。例如：&lt;span class="math"&gt;\(1 + 1 = 2\)&lt;/span&gt; 和
&lt;/p&gt;
&lt;div class="math"&gt;$$1 + 1 = 2$$&lt;/div&gt;
&lt;h3&gt;书写一个质能守恒公式&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nb"&gt;E &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt; mc^&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="math"&gt;$$E=mc^2$$&lt;/div&gt;
&lt;h3&gt;希腊字母&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;\alpha&lt;/span&gt;&lt;span class="nb"&gt;, &lt;/span&gt;&lt;span class="nv"&gt;\beta&lt;/span&gt;&lt;span class="nb"&gt;, ..., &lt;/span&gt;&lt;span class="nv"&gt;\omega&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;\Gamma&lt;/span&gt;&lt;span class="nb"&gt;, &lt;/span&gt;&lt;span class="nv"&gt;\Delta&lt;/span&gt;&lt;span class="nb"&gt;, …, &lt;/span&gt;&lt;span class="nv"&gt;\Omega&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;小写希腊字母：&lt;span class="math"&gt;\(\alpha, \beta, ..., \omega\)&lt;/span&gt;
大写希腊字母：&lt;span class="math"&gt;\(\Gamma, \Delta, …, \Omega\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;上标和下标&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nb"&gt;x_i^&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上标和下标分别为^ 和 _. 例如：&lt;span class="math"&gt;\(x_i^2\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;求和与积分&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\sum&lt;/span&gt;&lt;span class="nb"&gt;_{k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}^{n}&lt;/span&gt;&lt;span class="nv"&gt;\frac&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}{k}&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt; 
&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\sum&lt;/span&gt;&lt;span class="nb"&gt;_{k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}^n&lt;/span&gt;&lt;span class="nv"&gt;\frac&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}{k}&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt; 
&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\int&lt;/span&gt;&lt;span class="nb"&gt;_a^b f&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;dx&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="math"&gt;$$\sum_{k=1}^{n}\frac{1}{k}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\sum_{k=1}^n\frac{1}{k}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\int_a^b f(x)dx$$&lt;/div&gt;
&lt;p&gt;如果你使用过LaTex那么用起来就非常熟悉了，语法基本和LaTex一样。可以访问 &lt;a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference"&gt;MathJax&lt;/a&gt; 参考更多使用方法。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 10 Apr 2015 19:35:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-10:shi-pelicanzhi-chi-latexshu-xue-gong-shi.html</guid><category>教程</category></item><item><title>求字符的所有组合和所有排列</title><link>http://www.wengweitao.com/qiu-zi-fu-de-suo-you-zu-he-he-suo-you-pai-lie.html</link><description>&lt;blockquote&gt;
&lt;p&gt;昨天看到一道关于求解字符串的排列的问题。如何求出几个字符的所有排列，发现对这种类似的题型还不是很熟练，因此本文对字符的全排列和全组合的问题作下总结，加深自己的理解和记忆，同时也希望能够帮助大家更好的学习和理解该类问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;字符串的排列&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;：
考虑把这个复杂的问题分解成为小的问题。整个字符串的排列，可以看成两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，求所有可能出现在第一个位置的字符&lt;/li&gt;
&lt;li&gt;然后，固定第一个字符，求后面所有字符的排列。这个时候仍然把后面的所有字符分成两个部分：后面的第一个字符，以及这个字符之后的所有字符。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析到这里，可以看出这是非常典型的递归。接下来，就可以写出代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\t&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\t&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;字符串的组合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：
不是求字符的所有排列，而是求字符的所有组合呢？还是输入三个字符a、b、c，组合有：a, b, c , ab, ac, bc, abc。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;：
字符串的组合与排列不同，当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是一个组合。比如ab和ba是两个排列，但是一个组合。
假设输入n个字符，则这n个字符能构成长度为1的组合、长度为2的组合、......、长度为n的组合。在求n个字符组成长度为m的组合的时候，与字符串全排列的求解思想类似，我们可以把这n个字符分为两个部分：第一个字符和剩余的其他所有的n-1个字符。这个时候可以分为两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果组合里包含第一个字符，则从所有剩余n-1个字符里选取&lt;strong&gt;m-1&lt;/strong&gt;个字符；&lt;/li&gt;
&lt;li&gt;如果组合里不包含第一个字符，则下一步在剩余的n-1个字符选取&lt;strong&gt;m&lt;/strong&gt;个字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，我们可以把求n个字符组成长度为m的组合问题分解成两个子问题，分别求n-1个字符串长度为m-1的组合，以及求n-1个字符的长度为m的组合。这两个子问题都可以用递归方式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Combination&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// n-1个字符串中，选取number-1个字符&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// n-1个字符串中，选取number个字符&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop_back&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cobination函数中，分别求解字符个数为1到n的所有组合；使用一个vector容器来保存放进组合中的字符。&lt;/p&gt;
&lt;p&gt;另外，还有另一种思路可以求解——基于位图。
假设一共有n个字符，则可能的组合结果共有&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;种。
以输入3个字符a、b、c为例：
3个字符，可以用3个位来表示，从右到左的每一位分别用来代表a、b、c，该位为1表示取该元素，该位为0表示不取该元素。例如如组合a表示为001，组合b表示为010，组合ac表示为101，组合abc表示为111，而000是没有意义的，所以总共的结果就是&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;种。&lt;/p&gt;
&lt;p&gt;因此，我们可以从值1开始循环到&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;，输出每个值所代表的组合即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Combination2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 依次输出值1到2^n-1所代表值的组合&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 判断第j位是否为1&lt;/span&gt;
            &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;相关题目&lt;/h2&gt;
&lt;h3&gt;求正方体对面顶点和相等数组&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：
输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析&lt;/strong&gt;：
我们可以求出这8个数字的全排列，然后从中找出是否符合题目条件的排列。即先得到a1、a2、a3、a4、a5、a6、a7和a8这8个数字的所有排列，然后判断有没有某个排列符合条件：&lt;/p&gt;
&lt;div class="math"&gt;$$a1 + a2 + a3 + a4 = a5 + a6 + a7 + a8$$&lt;/div&gt;
&lt;div class="math"&gt;$$a1 + a3 + a5 + a7 = a2 + a4 + a6 +a8$$&lt;/div&gt;
&lt;div class="math"&gt;$$a1 + a2 + a5 + a6 = a3 + a4 + a7 + a8$$&lt;/div&gt;
&lt;p&gt;&lt;img alt="cubic" src="./imgs/cube.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum4&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sum5&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CubicEqualExist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IsEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;CubicEqualExist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;八皇后问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：
在8 X 8的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处于同一行，同一列或者同一对角线上，求出所有符合条件的摆法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析&lt;/strong&gt;：
任意两个皇后不得处于同一行，由此可得每个皇后都单独占据一行。我们可以定义一个数组ColumnIndex[8]，其中ColumnIndex[i]表示处在第i行位置的那个皇后对应在ColumnIndex[i]列，例如ColumnIndex&lt;a href="http://book.douban.com/subject/6966465/"&gt;1&lt;/a&gt; = 3 表示处在第1行的皇后在第3列上。
接下来，分别用0~7这8个数字对ColumnIndex进行初始化。注意，此时所有的皇后不同行也不同列。
因此，我们只需要对ColumnIndex数组进行全排列，判断每一个排列所对应的8个皇后的位置是否在对角线上即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                                                                                    
                &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IsRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EightQueens&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;References:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.douban.com/subject/6966465/"&gt;剑指offer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 10 Apr 2015 14:41:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-10:qiu-zi-fu-de-suo-you-zu-he-he-suo-you-pai-lie.html</guid><category>面试题</category></item><item><title>编写高质量Python代码（3）——库</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-3-ku.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Python具有非常丰富的库，这篇文章介绍了常用库的使用和技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议36：掌握字符串的基本用法&lt;/h3&gt;
&lt;p&gt;有个小技巧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;SELECT *&amp;#39;&lt;/span&gt;
         &lt;span class="s"&gt;&amp;#39;FROM atable &amp;#39;&lt;/span&gt;
         &lt;span class="s"&gt;&amp;#39;WHERE afield=&amp;quot;value&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="n"&gt;s&lt;/span&gt;
 &lt;span class="s"&gt;&amp;#39;SELECT *FROM atable WHERE afield=&amp;quot;value&amp;quot;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上利用了Python遇到未闭合的小括号时会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接在一起的特性做到的。（而如果使用三个引号会把换行符和空格都当做字符串的一部分）&lt;/p&gt;
&lt;p&gt;Python字符串分为str和unicode两种。当需要判断变量是否为字符串时，应该使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;basestring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python提供了很多判定字符串的函数如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isalnum()&lt;/li&gt;
&lt;li&gt;isalpha() &lt;/li&gt;
&lt;li&gt;isdigit() &lt;/li&gt;
&lt;li&gt;islower()&lt;/li&gt;
&lt;li&gt;isupper()&lt;/li&gt;
&lt;li&gt;isspace()&lt;/li&gt;
&lt;li&gt;istitle() 首字母大写&lt;/li&gt;
&lt;li&gt;startswith(prefix, start, end)&lt;/li&gt;
&lt;li&gt;endswith&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找和替换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count(sub, start, end )&lt;/li&gt;
&lt;li&gt;find  找不到返回-1&lt;/li&gt;
&lt;li&gt;index   找不到返回ValueError&lt;/li&gt;
&lt;li&gt;rfind&lt;/li&gt;
&lt;li&gt;rindex&lt;/li&gt;
&lt;li&gt;replace(old, new, count)  最多替换count次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分切与连接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;partition(seq), rpartition, : 返回一个3个元素的元组对象。sep左端，sep，sep右端&lt;/li&gt;
&lt;li&gt;splitlines&lt;/li&gt;
&lt;li&gt;split(sep, maxsplit), rsplit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意split()与split(' ')不同&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39; hello   world!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39; hello   world!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;变形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower() &lt;/li&gt;
&lt;li&gt;upper() &lt;/li&gt;
&lt;li&gt;capitalize() &lt;/li&gt;
&lt;li&gt;swapcase() &lt;/li&gt;
&lt;li&gt;title()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;填充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;center  居中&lt;/li&gt;
&lt;li&gt;ljust   左对齐&lt;/li&gt;
&lt;li&gt;rjust   右对齐)&lt;/li&gt;
&lt;li&gt;zfill   字符0填充&lt;/li&gt;
&lt;li&gt;expandtabs 制表符替换为适当数量的空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议37：按需选择sort()或者sorted()&lt;/h3&gt;
&lt;h4&gt;1.相比sort, sorted()的使用更为广泛。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iterable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;cmp：用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable或者list），返回-1, 0, 1，当第一个参数小于第二个参数则返回负数。
key：带一个参数的函数，用来为每个元素提取比较值，默认为None
reverse：排序结果是否反转&lt;/p&gt;
&lt;p&gt;sorted可以作用于任意迭代对象，而sort()一般作用于列表。如sort((1,3,2))就抛出异常。&lt;/p&gt;
&lt;h4&gt;2.当排序对象为列表时，二者适合的场景不同。&lt;/h4&gt;
&lt;p&gt;sorted 返回一个排序后的列表，原有列表保持不变；而sort直接修改原有的列表，函数返回为None。
sort函数不需要复制原有列表，消耗内存较少，效率也比较高。&lt;/p&gt;
&lt;h4&gt;3.传入参数key比参数cmp效率高。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;timeit&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sorted(xs, key=lambda x:x[1])&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xs=range(100);xs=zip&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;).timeit(10000)    # 比较x[1]位置的值&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.18814091348924744&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sorted(xs, cmp=lambda a,b: cmp(a[1],b[1]))&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xs=rang&lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;).timeit(10000)  # 比较x[1]位置的值   cmp(x,y)当x &amp;lt; y - &amp;gt; -1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.2789308104491681&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4.sorted功能非常强大，可以方便对不同数据结构进行排序。&lt;/h4&gt;
&lt;p&gt;①对字典进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;phonebook&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Linda&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;7750&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;9345&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Carol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;5834&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;sorted_pb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phonebook&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;sorted_pb&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;5834&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Linda&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;7750&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;9345&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;itemgetter获得指定位置的值。&lt;/p&gt;
&lt;p&gt;②多维list排序。对多个字段进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;gameresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;95.00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Alan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;86.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mandy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;82.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;A&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;], [&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Rob&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;, 86, &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;]]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gameresult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mandy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;82.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;95.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Alan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;86.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Rob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;86&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先按等级，等级相同则按照分数高低排序。&lt;/p&gt;
&lt;p&gt;③字典中混合list排序。
字典中的key或者值为列表，需要对列表中的某个位置的元素进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;mydict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s"&gt;&amp;#39;Zhang&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s"&gt;&amp;#39;Weng&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mydict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Weng&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Zhang&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;iteritems()返回的是（k，v），传入到函数中;  itemgetter(1)(v)取得v的第一个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;CDEFG&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;④List中混合字典排序
列表中每一个元素都为字典，需要针对字典的多个key值进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;gameresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wins&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;losses&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;75.00&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wwt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wins&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;losses&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gameresult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;losses&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rating&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;75.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;losses&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rating&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按key为rating、name排序&lt;/p&gt;
&lt;h3&gt;建议38：使用copy模块深拷贝对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;copy&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="c"&gt;#浅拷贝&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deepcopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;#深拷贝&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;51&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;51&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;浅拷贝仅仅拷贝了对象的地址而不对对应地址所指向的具体内容进行拷贝。&lt;/p&gt;
&lt;h3&gt;建议39：使用Counter进行计数统计&lt;/h3&gt;
&lt;p&gt;计数统计有多重方法如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用dict&lt;/li&gt;
&lt;li&gt;使用defaultdict&lt;/li&gt;
&lt;li&gt;使用set和list&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;some_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;count_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;count_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;count_set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;countlist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有更优雅地就是使用collections.Counter：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;some_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用elements可以获取key值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用most_common找出前N个频率最高的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;most_common&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当访问不存在的元素时，返回的是0，而不是KeyError:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;update和subtract:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;58&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;success&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sucessfully&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 累加而不是替换&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subtract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;successfully&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于Counter的更深入应用，可以阅读我的另一篇&lt;a href="http://www.wengweitao.com/pythonrong-qi-counterde-shi-yong.html"&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;建议40：深入掌握ConfigParser&lt;/h3&gt;
&lt;p&gt;配置文件的意义在于用户不需要修改代码，就可以改变应用程序的行为。
ConfigParser有几个地方需要提一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;getboolean函数，根据一定的规则将配置项的值转换为布尔值。
[section1]
option1=0
当调用getboolean('section1','option1')时，返回的值是False。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置项的查找规则。
有一个[DEFAULT]节，当读取的配置项不在指定的节里时，会在[DEFAULT]节中查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持字符串格式化的类似语法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DEFAULT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;conn_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dnb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="n"&gt;dbn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;
&lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3306&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;db1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;pw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ppp&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exmaple&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;db2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="n"&gt;pw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ccc&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ConfigParser&lt;/span&gt;
&lt;span class="n"&gt;conf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;foramt.conf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;db1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;conn_str&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上配置可以根据不同配置获取不同数据库配置相应的连接字符串。&lt;/p&gt;
&lt;h3&gt;建议41：使用argparse处理命令行参数&lt;/h3&gt;
&lt;p&gt;Pythonista有好几种方案，标准库中留下来的getopt, optparse和argparse。
其中argparse是最强大的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;_StoreAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;
&lt;span class="n"&gt;ne&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;68&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;verbose&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;68&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;_StoreTrueAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;verbose&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;69&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Namespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;verbose&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在又出现了docopt，比argparse更先进更易用的命令行参数处理器。（但是，还不是标准库的一部分）&lt;/p&gt;
&lt;h3&gt;建议42：使用pandas处理大型CSV文件&lt;/h3&gt;
&lt;p&gt;CSV(Comma Seperated Values)作为一种逗号分隔型值的纯文本格式文件，实际中经常用到。Python提供了处理csv的API：&lt;/p&gt;
&lt;p&gt;1.reader( csvfile, dialect='excel', fmtparam  ) 用于csv文件的读取，返回reader对象。当dialect设置为excel时，默认Dialect值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;excel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Dialect&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 单个字符，用于分隔字段，常见的有, | ;&lt;/span&gt;
    &lt;span class="n"&gt;quotechar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 用于对特殊符号加引号&lt;/span&gt;
    &lt;span class="n"&gt;doublequote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# quotechar出现时候表现形式&lt;/span&gt;
    &lt;span class="n"&gt;skipinitialspace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# true是delimiter后面的空格会忽略&lt;/span&gt;
    &lt;span class="n"&gt;lineterminator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;#行结束符&lt;/span&gt;
    &lt;span class="n"&gt;quoting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QUOTE_MINIMAL&lt;/span&gt; &lt;span class="c"&gt;# 是否在字段前加引号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.csv.writer(csvfile, dialect=‘excel’, **fmtparams)用于写入CSV文件，参数同上。&lt;/p&gt;
&lt;p&gt;3.csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect="excel", &lt;em&gt;args, &lt;/em&gt;*kwds)
同reader方法类似，不同的是把信息映射到一个字典中去。&lt;/p&gt;
&lt;p&gt;4.csv.DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', &lt;em&gt;args, &lt;/em&gt;*kwds)用于支持字典写入。&lt;/p&gt;
&lt;p&gt;CSV模块使用非常方便(import csv)，但如果要处理的CSV文件大小上百MB或者几个GB，那么csv模块就应付不来了。
下面做一个实验，临时创建一个1GB的CSV文件并将其加载到内存中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;large.csv&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1073741824&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# 创建大文件的技巧&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\0&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;large.csv&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_size&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="il"&gt;1073741824L&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;large.csv&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;csvfile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;mycsv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;csvfile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;delimiter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;mycsv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;         &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行后会出现MemoryError。&lt;/p&gt;
&lt;p&gt;所以应该使用pandas。其支持两种数据结构——Series和DataFrame是数据处理的基础。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Series:是一种类似数组的带索引的一维数据结构。通过obj.values()和obj.index()可以分别获取值和索引。&lt;/li&gt;
&lt;li&gt;DataFrame：类似一个二维数据结构，支持行和列的索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pandas中处理csv文件的函数主要为read_csv()和to_csv()，前者读取csv文件内容并返回DataFrame,后者则相反。
①可以指定读取部分列和文件的行数
②设置CSV文件与excel兼容
③对文件进行分块处理并返回一个可迭代的对象
④当文件格式相似的时候，支持多个文件合并处理。&lt;/p&gt;
&lt;p&gt;pandas处理非常灵活，而且底层使用Cython实现速度较快，在专业的数据处理与分析领域，如金融等行业已经得到广泛应用。&lt;/p&gt;
&lt;h3&gt;建议43：一般情况下使用ElementTree解析XML&lt;/h3&gt;
&lt;p&gt;xml.dom.minidom和xml.sax是Python解析XML文件最为人们熟知的两个模块了。从Python2.5开始ElementTree成为标准模块，cElementTree是Cython实现，速度更快，消耗内存更少，实际使用应尽量使用cElementTree. 具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用简单。每一个元素的属性以字典形式表示&lt;/li&gt;
&lt;li&gt;内存消耗明显低于DOM解析。避免将整个XML文件加载到内存中&lt;/li&gt;
&lt;li&gt;支持XPath查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果XML文件在GB级别，那么第三方的lxml是更好的选择。&lt;/p&gt;
&lt;p&gt;ElementTree主要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getroot()&lt;/li&gt;
&lt;li&gt;find(match)&lt;/li&gt;
&lt;li&gt;findall(match)&lt;/li&gt;
&lt;li&gt;findtext(match, default=None)&lt;/li&gt;
&lt;li&gt;iter(tag)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;xml.etree.ElementTree&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ET&lt;/span&gt;
&lt;span class="n"&gt;tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ET&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ElementTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test.xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getroot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;system/purpose&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议44：理解模块pickle优劣&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;序列化的场景很常见&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在磁盘上保存当前程序的状态数据以便重启的时候能够重新加载&lt;/li&gt;
&lt;li&gt;多用户或者分布式操作系统中数据结构的网络传输时，可以将数据序列化后发送给一个可信网络对端，接收后反序列化后恢复相同的对象。&lt;/li&gt;
&lt;li&gt;session和cache的存储等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：简单地说就是把内存中数据结构在不丢失其身份和类型信息的情况下转成对象的文本或者二进制表示的过程。对象序列化后的形式经过反序列化过程应该能够恢复为原有的对象。
Python有很多支持序列化的模块，如pickle，json，marshal和shelve等。&lt;/p&gt;
&lt;p&gt;pickle是最通用的序列化模块。它的C语言实现为cPickle，其速度为pickle的1000倍。
pickle最主要的两个函数时dump()和load()，分别进行序列化和反序列化。&lt;/p&gt;
&lt;p&gt;pickle.dump(obj, file, protocol )序列化数据到一个文件描述符，obj表示需要序列化的对象
load(file): 反序列化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cPickle&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pickle&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;my_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2.7.5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;picklefile.dat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 打开要写入的文件&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;picklefile.dat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;version&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2.7.5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Language&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;pickle具有的特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口简单，容易使用。dump和load&lt;/li&gt;
&lt;li&gt;存储格式具有通用性。能够被不同平台的Python解析器共享。&lt;/li&gt;
&lt;li&gt;支持数据类型广泛&lt;/li&gt;
&lt;li&gt;pickle模块式可以扩展的。对于不可序列化的对象，如sockets、文件句柄、数据库连接等，可以通过特殊方法__getstate__()和__setstate__()来返回实例在被pickle时的状态。&lt;/li&gt;
&lt;li&gt;能够自动维护对象间的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loads&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 反序列化后对a1对象的修改仍然会影响到b1&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;pickle也有一些限制&lt;/strong&gt;：
- 不能保证操作的原子性。也就是说pickle调用中如果发生异常， 可能部分数据已经保存。
- pickle存在安全性问题。pickle.loads('cmd')
- pickle协议是Python特定的，不同语言兼容性难以保证。&lt;/p&gt;
&lt;h3&gt;建议45：序列化的另一个不错的选择——JSON&lt;/h3&gt;
&lt;p&gt;Python有一系列模块提供对JSON格式的支持，如simplejson, cjson, yajl, ujson, 2.6后又引入了标准库JSON。cjson是用C语言实现，yajl是Cython版本的JSON实现。
simplejson与标准库JSON的区别不大，但更新可能更快，在实际使用中将这两者结合采用如下的import方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;simplejson&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JSON的常用方法与pickle类似，dump/dumps序列化，load/loads反序列化。 &lt;/p&gt;
&lt;p&gt;相比pickle，json具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用简单，支持多种数据类型。&lt;/li&gt;
&lt;li&gt;名称/ 值对的集合&lt;/li&gt;
&lt;li&gt;值的有序列表&lt;/li&gt;
&lt;li&gt;存储格式可读性更为友好，容易修改。dumps函数提供了一个参数indent使生成的json文件可读性更好，0意味着每个值单独一行；大于0的数字表示使用这个数字的空格来缩进嵌套结构。但这个是以文件大小变大为代价的。&lt;/li&gt;
&lt;li&gt;json支持跨平台跨语言操作，能够轻易被其他语言解析。&lt;/li&gt;
&lt;li&gt;具有较强的扩展性。提供了编码(JSONEncoder)和解码类（JSONDecoder）以便用户对其默认不支持的序列化类型进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是Python中标准模块json的性能比pickle稍逊。性能要求高的话，还是选择cPickle。&lt;/p&gt;
&lt;h3&gt;建议46：使用traceback获取栈信息&lt;/h3&gt;
&lt;p&gt;traceback会输出完整的栈信息，有利于开发人员快速找到异常发生时的现场信息。
tracback.print_exc()打印出：错误类型，错误对应的值已经具体的trace信息，包括文件名、具体行号、函数名已经对应的代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;traceback&lt;/span&gt;
&lt;span class="n"&gt;gList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;i&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sorry, out of range&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;
        &lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_exc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;sorry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;out&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;
&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="nb"&gt;index&lt;/span&gt; &lt;span class="nb"&gt;out&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;
&lt;span class="nx"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;most&lt;/span&gt; &lt;span class="nx"&gt;recent&lt;/span&gt; &lt;span class="nb"&gt;call&lt;/span&gt; &lt;span class="nb"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nb"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;f&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
    &lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="nx"&gt;gList&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
IndexError: list index out of range
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议47：使用logging记录日志信息&lt;/h3&gt;
&lt;p&gt;仅仅将栈信息输出到控制台远远不够，更为常见的做法是使用日志保存程序运行过程中的相关信息，如运行时间、描述信息以及错误或者异常发生时候的特定上下文信息。Python自带了logging模块提供了日志功能。&lt;/p&gt;
&lt;p&gt;logger分为5个级别，包含4个主要对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;logger：程序信息输出的接口，分散在不同代码中，使得程序可以再运行的时候记录相应的信息，并根据设置的日志级别或者filter来决定哪些信息需要输出，并将这些信息方法到其关联的handler。&lt;/li&gt;
&lt;li&gt;handler。处理信息的输出，可以输出到控制台、文件或者网络。&lt;/li&gt;
&lt;li&gt;Formatter。决定log信息的格式&lt;/li&gt;
&lt;li&gt;Filter。决定哪些信息需要输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个使用logging的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;traceback&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="n"&gt;gList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="c"&gt;# configure log output formatter&lt;/span&gt;
        &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;filemode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(filename)s&lt;/span&gt;&lt;span class="s"&gt;[line:&lt;/span&gt;&lt;span class="si"&gt;%(lineno)d&lt;/span&gt;&lt;span class="s"&gt;] &lt;/span&gt;&lt;span class="si"&gt;%(levelname)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;[INFO]:calling method g() in f()&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# normal message&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;i&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Information during calling f():&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sorry, out of range&amp;#39;&lt;/span&gt;
        &lt;span class="c"&gt;#traceback.print_exc()&lt;/span&gt;
        &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exc_info&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[ERROR]:Sorry,Exception occured.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;object info:&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Error Type:{0}, Error information:{1}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format_tb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出log到log.txt，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;55&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;684&lt;/span&gt; &lt;span class="nx"&gt;trace_back.py&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; DEBUG Information during calling f():
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; INFO &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;INFO&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;:calling method g() in f()
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; ERROR &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;ERROR&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;:Sorry,Exception occured.
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL object info:list index out of range
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL Error Type:&lt;span class="nt"&gt;&amp;lt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="na"&gt;exceptions&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IndexError&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;, Error information:list index out of range
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL   File &amp;quot;trace_back.py&amp;quot;, line 27, in &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
    f()
  File &amp;quot;trace_back.py&amp;quot;, line 14, in f
    return g()
  File &amp;quot;trace_back.py&amp;quot;, line 16, in g
    return h()
  File &amp;quot;trace_back.py&amp;quot;, line 19, in h
    return i()
  File &amp;quot;trace_back.py&amp;quot;, line 22, in i
    print gList&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议48：使用threading模块编写多线程程序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GIL&lt;/strong&gt;(Global Interpreter Lock)全局解释器锁，是解释器用于同步线程的工具，使得任何时候只有一个线程在运行。GIL的存在使得Python多线程编程暂时无法利用多处理器的优势。但这不意味着我们要放弃多线程。
对于纯Python的代码也许使用多线程不能提高运行效率，但是以下几种情况，多线程仍然是比较好的解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待外部资源返回&lt;/li&gt;
&lt;li&gt;建立反应灵活的用户界面&lt;/li&gt;
&lt;li&gt;多用户应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python为多线程编程提供了两个模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;thread&lt;/li&gt;
&lt;li&gt;threading&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;thread模块提供了多线程的底层支持模块，以低级方式来处理和控制线程，使用起来较为复杂；
threading模块基于thread进行封装，将线程操作对象化，在语言层面提供了丰富的特性。
因此，实际使用中推荐优先使用threading模块，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;threading对同步原语的支持更为完善和丰富。如有Lock指令锁，还支持条件变量condition、信号量Semaphore等。&lt;/li&gt;
&lt;li&gt;threading模块在主线程与子线程的交互上更为友好。threading中的join()方法能够阻塞当前上下文环境的线程，直到调用此方法的线程终止或者到达指定的timeout。利用该方法可以方便地控制主线程与子线程以及子线程之间的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; delay for &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;This is thread &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; on line &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;End of thread &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Thread 1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Thread 2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Wait t1 to end&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;End of main&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：
&lt;img alt="threading_join" src="./imgs/threading_join.png" /&gt;&lt;/p&gt;
&lt;p&gt;主线程main上使用t1的join()方法，主线程会等待t1结束后才继续运行后面的语句。线程t2的启动在join语句之后，t2一直等到t1退出后才会开始运行。&lt;/p&gt;
&lt;p&gt;thread模块不支持守护进程。thread模块在主线程退出后，所有的主线程无论是否还在工作，都会被强制结束。threading模块，支持守护进程，可以通过setDaemon()来设定线程的daemon属性，当daemon属性为True时，表面主线程的退出可以不用等待子线程的完成（默认为False，即所有子线程结束后主线程才会结束）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;I will calculate square of &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; after delay for &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;calculate begins...&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDaemon&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDaemon&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="threading" src="./imgs/threading.png" /&gt;&lt;/p&gt;
&lt;h3&gt;建议49：使用Queue使多线程编程更安全&lt;/h3&gt;
&lt;p&gt;线程间的同步互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。&lt;/p&gt;
&lt;p&gt;Python中的Queue提供了三种队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queue.Queue(maxsize)。FIFO&lt;/li&gt;
&lt;li&gt;Queue.LifoQueue(maxsize)&lt;/li&gt;
&lt;li&gt;Queue.PriorityQueue(maxsize)。优先级队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三种队列支持以下几种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queue.qsize()&lt;/li&gt;
&lt;li&gt;empty()&lt;/li&gt;
&lt;li&gt;full()&lt;/li&gt;
&lt;li&gt;put(item, block, timeout  ):往队列中添加item元素，block为False的时候，若队列满则抛出Full异常，若block为True，则队列满一直等待有空位置，知道timeout时间后抛出异常。&lt;/li&gt;
&lt;li&gt;put_nowait(item): 相当于block为False的put方法&lt;/li&gt;
&lt;li&gt;get(block, timeout ): 与put类似的用法&lt;/li&gt;
&lt;li&gt;get_nowait()&lt;/li&gt;
&lt;li&gt;task_done()：发送信号表面入列任务已经完成，经常在消费者线程中使用&lt;/li&gt;
&lt;li&gt;join()：阻塞直到队列中所有元素处理完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Queue实现了多个生产者和多个消费者的队列，当多线程之间需要信息安全交换的时候特别有用。
需要注意的是Queue与collections.deque中的队列是不同的，前者主要用于不同线程之间的通信，它内部实现了线程的锁机制；而后者是数据结构上的概念。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Queue&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DownloadThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;begin download&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;download_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task_done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; download completed!&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;download_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;urlhandler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.html&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;chunk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urlhandler&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;chunk&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;
                &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chunk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.baidu.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;http://www.google.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;http://www.wengweitao.com&amp;quot;&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DownloadThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# wait for the queue to finish&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;h2&gt;&lt;img alt="threading_queue" src="./imgs/threading_queue.png" /&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 08 Apr 2015 22:58:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-08:bian-xie-gao-zhi-liang-pythondai-ma-3-ku.html</guid><category>Python</category></item><item><title>Python容器——Counter的使用</title><link>http://www.wengweitao.com/pythonrong-qi-counterde-shi-yong.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Counter是Python标准库提供的一个非常有用的容器，可以用来对序列中出现的各个元素，进行计数。这篇文章中，利用Counter来实现多元集合(MultiSets)、概率质量函数(PMFs)以及贝叶斯假设。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Python代码中使用Counter，只需从collections包引入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1.判断两个字符串是否由相同的字母集合调换顺序而成的（anagram）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_anagram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Checks whether the words are anagrams.&lt;/span&gt;

&lt;span class="sd"&gt;    word1: string&lt;/span&gt;
&lt;span class="sd"&gt;    word2: string&lt;/span&gt;

&lt;span class="sd"&gt;    returns: boolean&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Counter如果传入的参数是字符串，就会统计字符串中每个字符出现的次数，如果两个字符串由相同的字母集合颠倒顺序而成，则它们Counter的结果应该是一样的。&lt;/p&gt;
&lt;h3&gt;2.多元集合(MultiSets)&lt;/h3&gt;
&lt;p&gt;multiset是相同元素可以出现多次的集合，Counter可以非常自然地用来表示multiset。并且可以将Counter扩展，使之拥有set的一些操作如is_subset。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Multiset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A multiset is a set where elements can appear more than once.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_subset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Checks whether self is a subset of other.&lt;/span&gt;

&lt;span class="sd"&gt;        other: Multiset&lt;/span&gt;

&lt;span class="sd"&gt;        returns: boolean&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

    &lt;span class="c"&gt;# map the &amp;lt;= operator to is_subset&lt;/span&gt;
    &lt;span class="n"&gt;__le__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;is_subset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.概率质量函数&lt;/h3&gt;
&lt;p&gt;概率质量函数（probability mass function，简写为pmf）是离散随机变量在各特定取值上的概率。可以利用Counter表示概率质量函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A Counter with probabilities.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Normalizes the PMF so the probabilities add to 1.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__add__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Adds two distributions.&lt;/span&gt;

&lt;span class="sd"&gt;        The result is the distribution of sums of values from the&lt;/span&gt;
&lt;span class="sd"&gt;        two distributions.&lt;/span&gt;

&lt;span class="sd"&gt;        other: Pmf&lt;/span&gt;

&lt;span class="sd"&gt;        returns: new Pmf&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;pmf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob1&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;pmf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;key2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;prob1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;prob2&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pmf&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__hash__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Returns an integer hash value.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__eq__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;render&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Returns values and their probabilities, suitable for plotting.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;normalize: 归一化随机变量出现的概率，使它们之和为1&lt;/p&gt;
&lt;p&gt;add: 返回的是两个随机变量分布两两组合之和的新的概率质量函数&lt;/p&gt;
&lt;p&gt;render: 返回按值排序的(value, probability)的组合对，方便画图的时候使用&lt;/p&gt;
&lt;p&gt;下面以骰子（ps: 这个竟然念tou子。。。）作为例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;one die&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pmf({1: 0.16666666666666666, 2: 0.16666666666666666, 3: 0.16666666666666666, 4: 0.16666666666666666, 5: 0.16666666666666666, 6: 0.16666666666666666})&lt;/p&gt;
&lt;p&gt;使用add，我们可以计算出两个骰子和的分布：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;d6_twice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d6&lt;/span&gt;
&lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;two dices&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;借助numpy.sum，我们可以直接计算三个骰子和的分布：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="n"&gt;d6_thrice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;d6_thrice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;three dices&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后可以使用render返回结果，利用matplotlib把结果画图表示出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d6_thrice&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;render&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linewidth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Total&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Probability&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如下：
&lt;img alt="pmf_results" src="./imgs/pmf.png" /&gt;&lt;/p&gt;
&lt;h3&gt;4.贝叶斯统计&lt;/h3&gt;
&lt;p&gt;我们继续用掷骰子的例子来说明用Counter如何实现贝叶斯统计。现在假设，一个盒子中有5种不同的骰子，分别是：4面、6面、8面、12面和20面的。假设我们随机从盒子中取出一个骰子，投出的骰子的点数为6。那么，取得那5个不同骰子的概率分别是多少？&lt;/p&gt;
&lt;p&gt;（1）首先，我们需要生成每个骰子的概率质量函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;make_die&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_sides&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_sides&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;num_sides&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;


&lt;span class="n"&gt;dice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;make_die&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）接下来，定义一个抽象类Suite。Suite是一个概率质量函数表示了一组假设(hypotheses)及其概率分布。Suite类包含一个bayesian_update函数，用来基于新的数据来更新假设(hypotheses)的概率。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Map from hypothesis to probability.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Performs a Bayesian update.&lt;/span&gt;

&lt;span class="sd"&gt;        Note: called bayesian_update to avoid overriding dict.update&lt;/span&gt;

&lt;span class="sd"&gt;        data: result of a die roll&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;like&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;likelihood&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;like&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中的likelihood函数由各个类继承后，自己实现不同的计算方法。&lt;/p&gt;
&lt;p&gt;（3）定义DiceSuite类，它继承了类Suite。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DiceSuite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Suite&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;likelihood&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Computes the likelihood of the data under the hypothesis.&lt;/span&gt;

&lt;span class="sd"&gt;        data: result of a die roll&lt;/span&gt;
&lt;span class="sd"&gt;        hypo: Die object&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并且实现了likelihood函数，其中传入的两个参数为：
data: 观察到的骰子掷出的点数，如本例中的6
hypo: 可能掷出的那个骰子&lt;/p&gt;
&lt;p&gt;（4）将第一步创建的dice传给DiceSuite，然后根据给定的值，就可以得出相应的结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DiceSuite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;

&lt;span class="n"&gt;d4&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="mf"&gt;0.392156862745&lt;/span&gt;
&lt;span class="n"&gt;d8&lt;/span&gt; &lt;span class="mf"&gt;0.294117647059&lt;/span&gt;
&lt;span class="n"&gt;d12&lt;/span&gt; &lt;span class="mf"&gt;0.196078431373&lt;/span&gt;
&lt;span class="n"&gt;d20&lt;/span&gt; &lt;span class="mf"&gt;0.117647058824&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正如，我们所期望的4个面的骰子的概率为0（因为4个面的点数只可能为0~4），而6个面的和8个面的概率最大。
现在，假设我们又掷了一次骰子，这次出现的点数是8，重新计算概率：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;


&lt;span class="n"&gt;d4&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d8&lt;/span&gt; &lt;span class="mf"&gt;0.623268698061&lt;/span&gt;
&lt;span class="n"&gt;d12&lt;/span&gt; &lt;span class="mf"&gt;0.277008310249&lt;/span&gt;
&lt;span class="n"&gt;d20&lt;/span&gt; &lt;span class="mf"&gt;0.0997229916898&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在可以看到6个面的骰子也被排除了。8个面的骰子是最有可能的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以上的几个例子，展示了Counter的用处。实际中，Counter的使用还比较少，如果能够恰当的使用起来将会带来非常多的方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;：
Using Counters : http://nbviewer.ipython.org/github/AllenDowney/PythonCounterPmf/blob/master/PythonCounterPmf.ipynb&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 08 Apr 2015 14:52:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-08:pythonrong-qi-counterde-shi-yong.html</guid><category>Python</category></item><item><title>编写高质量Python代码（2）</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-2.html</link><description>&lt;blockquote&gt;
&lt;p&gt;这篇文章基础语法出发讲述Python的使用技巧和注意事项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议8： 利用assert语句来发现问题&lt;/h3&gt;
&lt;p&gt;assert语句主要为调试程序服务，能够快速方便地检查程序的异常或者发现不恰当的输入等，防止意想不到的情况出现。
基本语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;expression1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
&lt;span class="c"&gt;#assert x == y, &amp;quot;not equals&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中计算expressi1的值若为False则会引发一个AssertionError，expression是可选的，用来传递具体的异常信息。&lt;/p&gt;
&lt;p&gt;另外，需要注意的是断言是对程序的性能有一定的影响，禁用断言的方法是运行时加上 -O标志。&lt;/p&gt;
&lt;h3&gt;建议9： 交换值时不推荐使用中间变量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;timeit&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;temp = x; x = y; y = temp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;x = 2; y = 3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.054762504979284254&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x, y = y, x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;x = 2; y = 3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.02862422937357678&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到第二种方法所耗费的时间更少。这是为什么呢？
一般情况下Python计算表达式的计算顺序是从左到右的，但是遇到&lt;strong&gt;表达式赋值是先计算右边的操作数&lt;/strong&gt;。如表达式exp3, exp4 = exp1, exp2的计算顺序是：exp1, exp2, exp3, exp4。
更深入一点，我们可以通过Python生成的&lt;strong&gt;字节码&lt;/strong&gt;来分析。Python字节码是一种类似汇编指令的中间语言，但是一个字节码并不是对应一个机器指令。我们通过以下dis模块来进行分析：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;dis&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;swap1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;swap2&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;swap1对应的字节码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;swap1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="n"&gt;ROT_TWO&lt;/span&gt;
     &lt;span class="mi"&gt;19&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;28&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;swap2对应的字节码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;swap2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;27&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ROT_TWO是交换两个栈的最顶层元素。
swap2中有更多的load和store操作，耗时更多。&lt;/p&gt;
&lt;h3&gt;建议10： 充分利用Lazy evaluation的特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;lazy evaluation&lt;/strong&gt;指的是在真正需要执行的时候才计算表达式的值。该特性带来的好处有：&lt;/p&gt;
&lt;h4&gt;1. 避免不必要的计算，带来性能提升&lt;/h4&gt;
&lt;p&gt;if x and y, x为false的情况下y表达式不计算； if x or y, x为true的情况下y不计算。
所以，对于or把最可能为真的放在最前面，二and则应该推后。&lt;/p&gt;
&lt;h4&gt;2. 节省空间，使得无限循环的数据结构成为可能&lt;/h4&gt;
&lt;p&gt;最典型的就是&lt;strong&gt;生成器&lt;/strong&gt;表达式了，通过yield产生所需要的元素。如斐波那契数列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;itertools提供了很多操作的生成器实现的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;islice&lt;/span&gt;
 &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;islice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议11： 理解枚举类型实现的缺陷&lt;/h3&gt;
&lt;p&gt;Python3.4之前并不提供枚举类型，因此需要自己实现枚举类型。实现过程中要注意可能的缺陷，如可能枚举值的重复、无意义的操作等。&lt;/p&gt;
&lt;h3&gt;建议12： 不推荐使用type来进行类型检查&lt;/h3&gt;
&lt;p&gt;基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。
如： class UserInt(int) 中 type(n) is types.IntType 为 False
在古典类中，任意类的实例的type()返回结果都是type 'instance'。这种情况就会与实际结果大相径庭。&lt;/p&gt;
&lt;p&gt;如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，如list(listing)，str(name)等，否则可以使用isinstance()函数来检测。
如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此可以将以上例子中的print type(n) is types.IntType改为print isinstance(n, int)以获取正确的结果。&lt;/p&gt;
&lt;h3&gt;建议13： 尽量转换为浮点类型后再做除法&lt;/h3&gt;
&lt;p&gt;浮点数也可能是不准确的，因为浮点数的存储规则决定了不是所有的浮点数都能准确表示，有些是不准确，有些是无限接近的。如0.1转换为二进制则为0.000110011001......后面1001无限循环。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于i != 1.5这种要尽量避免（可以使用 i &amp;lt;= 1.5）&lt;/p&gt;
&lt;h3&gt;建议14： 警惕eval()的安全漏洞&lt;/h3&gt;
&lt;p&gt;eval()函数将字符串str当成有效的表达式来求值并返回计算结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ExpCalcBot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your answer is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;NameError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Invalid&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Input your expression or enter e to end&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Please enter number or operation. Enter c to complete. :&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;ExpCalcBot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码的功能是根据用户的输入，计算Python表达式的值。假设用户输入:
&lt;strong&gt;import&lt;/strong&gt;("os").system("dir")就会列出当前目录的所有文件，也可以把所有文件都删除：
&lt;strong&gt;import&lt;/strong&gt;("os").system("del * /Q")
虽然可以在globals参数中禁止全局命名空间的访问，但是有经验的入侵者会使用一系列强大的手段，使eval执行某些命令。&lt;/p&gt;
&lt;h3&gt;建议15： 使用enumerate()获取序列迭代的索引和值&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;index:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;element:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
&lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequence&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中sequence可以为序列，如list，set等，也可以是iterator等可以迭代的对象。其实实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
     &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
     &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
         &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;
         &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于字典使用iteritems():&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;personinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议16：分清 == 与 is的适用场景&lt;/h3&gt;
&lt;p&gt;is:  object identity（拥有相同的内存地址）
==: equal
另外，在判断内存地址是否相同时，可以使用id(x)查看内存地址&lt;/p&gt;
&lt;h3&gt;建议17：考虑兼容性，尽可能使用Unicode&lt;/h3&gt;
&lt;p&gt;Python内建字符串有两种类型：str和Unicode，它们拥有相同的祖先basestring。
&lt;strong&gt;Unicode&lt;/strong&gt;的实现方式称为Unicode转换格式，简称为&lt;strong&gt;UTF&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;实例1：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;filehandle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中test.txt中的内容为：Python中文测试，文件以UTF-8的形式保存，运行结果会乱码。
在windows系统中本地默认的编码是CP936，它被映射为GBK编码，所以在控制台上直接显示UTF-8字符的时候，两种编码会冲突。UTF-8的编码，被解释成为其他的符号，由此产生了乱码。
解决的方法是使用Unicode作为中介来完成转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;gbk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;decode() : 解码。将其他编码对应的字符串解码成Unicode；
encode(): 编码。将Unicode编码转换为另一种编码。&lt;/p&gt;
&lt;p&gt;另外，有些软件在保存UTF-8的时候，会在文件的最开始的地方插入不可见的字符BOM(0xEF 0xBB 0xBF, 即BOM)，这些不可见字符无法被解析。（BOM是byte order mark说明文件的字节序的）。&lt;/p&gt;
&lt;h4&gt;实例2：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;pytho 中文测试&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;源文件中包含中文字符会抛出异常。
因为&lt;strong&gt;Python中默认的编码是ASCII编码&lt;/strong&gt;，中文字符不是ASCII字符，就出错。
可以使用以下方法对文件的编码进行声明。只需要把下面任何一行加入Python源文件的第一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# coding=utf-8&lt;/span&gt;
&lt;span class="c"&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python2.6 之后可以通过import unicode_literals自动将定义的字符识别为Unicode字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;你好时间&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="s"&gt;u&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\u4f60\u597d\u65f6\u95f4&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议18： 构建合理的包层次来管理module&lt;/h3&gt;
&lt;p&gt;什么是包？简单的说包就是目录，但是除了包含常规的Python文件之外，还包含一个__init__.py文件。同时它允许嵌套。包结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Package&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Module1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Module2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Subpackage&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
        &lt;span class="n"&gt;Module1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
        &lt;span class="n"&gt;Module2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要调用Subpackage中的Module1：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Package.Subpackage.Module1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;__init__.py的作用： 使包和普通目录区分；其次可以在该文件中申明模块级别的import语句从而使其变成包级别可见。&lt;/p&gt;
&lt;p&gt;当__init__.py为空时需要使用完整的路径来声明import语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Package.Module1&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是在该文件中添加from Module1 import Test后，可以直接使用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以在文件中定义__all__变量，控制需要导入的子包或者模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Module1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Module2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Subpackage&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;包的使用能够带来以下便利：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;合理组织代码，便于维护和使用&lt;/li&gt;
&lt;li&gt;能够有效避免名称空间冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 07 Apr 2015 22:39:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-07:bian-xie-gao-zhi-liang-pythondai-ma-2.html</guid><category>Python</category></item><item><title>Python代码格式化工具——YAPF</title><link>http://www.wengweitao.com/pythondai-ma-ge-shi-hua-gong-ju-yapf.html</link><description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/google/yapf"&gt;YAPF&lt;/a&gt;是Google开源的一个工具，可以用来格式化Python代码，使Python代码拥有一致的编程风格，减轻了团队或者个人进行代码风格维护的单调的工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;之前已经有一些类似的Python代码风格格式化工具如：&lt;a href="https://github.com/hhatto/autopep8"&gt;autopep8&lt;/a&gt;和&lt;a href="https://github.com/spulec/pep8ify"&gt;pep8ify&lt;/a&gt;等。这些工具基于&lt;a href="http://clang.llvm.org/docs/ClangFormat.html"&gt;clang-format&lt;/a&gt;,能够很好的解决大多数pep8报告的格式问题。然而，有些代码虽然遵从了PEP8的编程风格指南，但这并不意味着这些代码看起来就足够好，对于这种问题之前的那些Python代码格式化工具就无能为力了。
YAPF与其他的格式化工具不同，其算法能够把代码重新格式化为符合编程风格的最佳格式，无论原始的代码是否违法了某种指定的编程风格指南。YAPF的最终目标就是通过YAPF格式化后的代码能够与程序员完全遵从编程风格写的代码一样的好。&lt;/p&gt;
&lt;h3&gt;YAPF的使用&lt;/h3&gt;
&lt;h4&gt;1.安装&lt;/h4&gt;
&lt;p&gt;可以直接通过pip进行安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;yapf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2.使用。&lt;/h4&gt;
&lt;p&gt;安装完成之后，就可以直接在命令行中使用了。
以下是yapf的命令行参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;usage&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;yapf&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[--&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;STYLE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;Formatter&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;positional&lt;/span&gt; &lt;span class="k"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;files&lt;/span&gt;

&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="k"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;            &lt;span class="err"&gt;显示帮助信息&lt;/span&gt;
  &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;STYLE&lt;/span&gt;         &lt;span class="err"&gt;指定需要格式化的编程风格，如&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt;&lt;span class="err"&gt;或者&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="err"&gt;等&lt;/span&gt;
                        &lt;span class="err"&gt;也可以是自定义的设置文件。默认是&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;            &lt;span class="err"&gt;比较格式化后的文件和原文件的区别&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;place&lt;/span&gt;        &lt;span class="err"&gt;直接把格式化的文件更改在源文件上&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt;
                        &lt;span class="err"&gt;指定格式化的行的范围&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;recursive&lt;/span&gt;       &lt;span class="err"&gt;在目录中递归运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3.例子&lt;/h4&gt;
&lt;p&gt;以下是一段非常ugly的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;927&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello {}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;     &lt;span class="nb"&gt;object&lt;/span&gt;  &lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;   &lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;       &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="o"&gt;*-+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;      &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="o"&gt;+-+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用yapf将它格式化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;927&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello {}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;-+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;-+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好看很多！&lt;/p&gt;
&lt;p&gt;另外，YAPF在格式化的时候仍然有一些问题。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当有一大段内容的时候，我们都习惯分行排列，因为这显然更方便我们阅读。但是，使用YAPF格式化后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;遇到这种情况，YAPF也提供了解决的方法，就是在代码段的后面加上：
 # yapf: disable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# yapf: disable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;所以，YAPF是一个非常有用的工具，它可以帮助你将代码变得更加一致、更加容易阅读并且Pythonic。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 07 Apr 2015 15:10:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-07:pythondai-ma-ge-shi-hua-gong-ju-yapf.html</guid><category>Python</category><category>工具</category></item><item><title>编写高质量Python代码（1）</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-1.html</link><description>&lt;blockquote&gt;
&lt;p&gt;去年参加了珠海的PyCon大会，幸运地抽中了三本书，其中一本是《编写高质量代码：改善Python程序的91个建议》。本书从多个方面给出了编写高质量Python代码的91个建议，我把每一章的建议都先总结下来，分享给大家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议1： 理解Pythonic概念&lt;/h3&gt;
&lt;h4&gt;（1）Pythonic的定义&lt;/h4&gt;
&lt;p&gt;遵循Pythonic的代码看起来像伪代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;less&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;greater&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
    &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可读性比伪代码还要好！&lt;/p&gt;
&lt;h4&gt;（2）代码风格&lt;/h4&gt;
&lt;p&gt;Pythonic的代码要充分体现Python自身特色。
例如交换两个数(packaging/unpackaging)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有需要安全关闭文件描述符，可以使用with语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_st&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们应当追求充分利用Python的语法，但不应过分追求奇技淫巧，比如利用Slice语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;abcdef&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是一个实现列表倒序输出的功能，但是如果不熟悉该语法的可能就看不懂，实际上，这个时候更能体现Pythonic的代码是充分利用Python的库里的reversed函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reversed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;（3）标准库&lt;/h4&gt;
&lt;p&gt;写Pythonic的程序必须对Python的标准库有充分了解，特别是内置函数与内置数据类型。
例如格式化输出字符串,通常的做法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pythonic的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello %{name}s&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尤其是参数多的时候可读性更好。
str.format()是Python最为推荐的字符串格式化方法，当然也是最Pythonic的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{greet} from {language}.&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;language&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;（4）Python的库或框架&lt;/h4&gt;
&lt;p&gt;公认Flask这个框架式比较Pythonic的。可以仔细阅读这些优秀Python开源项目的源码。&lt;/p&gt;
&lt;h3&gt;建议2： 编写Pythonic代码&lt;/h3&gt;
&lt;h4&gt;（1）避免劣化代码&lt;/h4&gt;
&lt;p&gt;通常有几个需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免只用大小写来区分不同的对象。如a和A&lt;/li&gt;
&lt;li&gt;避免使用容易引起混淆的名称&lt;/li&gt;
&lt;li&gt;不要害怕过长的变量名，如person_info比pi可读性强得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;（2）深入认识Python有助于编写Pythonic代码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;看官方Reference&lt;/li&gt;
&lt;li&gt;学习新版本特性&lt;/li&gt;
&lt;li&gt;深入学习公认的Pythonic的代码，比如Flask、gevent和requests等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;（3）使用工具检查程序PEP8&lt;/h4&gt;
&lt;p&gt;安装PEP8的检测程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;pep8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面使用工具检查：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到检查的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;E231&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;whitespace&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;W391&lt;/span&gt; &lt;span class="n"&gt;blank&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就是，后面要空格，文件最后不应该有空行。
还可以展示出非常详细的错误和警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PEP8也并非是唯一的规范，还有Google Python Style Guide等等。&lt;/p&gt;
&lt;h3&gt;建议3： 理解Python与C语言的不同之处&lt;/h3&gt;
&lt;p&gt;Python底层是使用C来写的，但不要把C语言的思维方式带入Python。
可以利用Python实现C中Python并不自带的功能：&lt;/p&gt;
&lt;p&gt;三元运算符：  C ? X : Y  =&amp;gt;  X if C else Y&lt;/p&gt;
&lt;p&gt;类似switch的跳转功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You typed zero.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You are in top.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Only single-digit numbers are allowed&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议4： 在代码中适当注释&lt;/h3&gt;
&lt;p&gt;Python中有3种形式的注释：块注释、行注释和文档注释（docstring）。
注释和代码隔开一定的距离；
给外部访问的函数和方法添加文档注释，包括方法功能，参数，返回值以及可能的异常进行说明。&lt;/p&gt;
&lt;h3&gt;建议5： 通过适当添加空行使代码布局更为优雅、合理&lt;/h3&gt;
&lt;p&gt;如以下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;
&lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Hello! What is your name?&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Well, {0}, I am thinking of a number between 1 and 20.&amp;#39;&lt;/span&gt;\
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Take a guess: &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your guess is too low.&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your guess is too high.&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Good job&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Nope&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;一组代码表达完一个完整的思路后，应该用空白行隔开&lt;/li&gt;
&lt;li&gt;尽量保持上下文语义的易理解性。如当一个函数调用另一个函数时，尽量将它们放在一起，最好调用者在上，被调用者在下。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;A&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;B&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;避免过长的代码行。超过部分使用括号进行连接&lt;/li&gt;
&lt;li&gt;逗号和分号之前不要空格；二元运算符左右应该有空格；&lt;/li&gt;
&lt;li&gt;函数名和左括号不需要空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议6： 编写函数的4个原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;函数设计尽量短小，嵌套层次不宜过深。尽量不要太长，需要来回滚动。&lt;/li&gt;
&lt;li&gt;函数声明做到合理、简单、易于使用&lt;/li&gt;
&lt;li&gt;函数设计考虑向下兼容，如加入默认参数避免退化，做到向下兼容。&lt;/li&gt;
&lt;li&gt;一个函数只做一件事！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议7：将常量集中到一个文件中&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过命名风格提醒使用者该变量代表为常量，如使用大写字母加下划线。&lt;/li&gt;
&lt;li&gt;通过自定义的类实现常量功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 06 Apr 2015 18:42:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-06:bian-xie-gao-zhi-liang-pythondai-ma-1.html</guid><category>Python</category></item><item><title>斐波那契数列及其相关问题</title><link>http://www.wengweitao.com/fei-bo-na-qi-shu-lie-ji-qi-xiang-guan-wen-ti.html</link><description>&lt;p&gt;很多书在提到递归的时候，总是会拿斐波那契数列作为例子，它的定义如下：
&lt;img alt="Fibonacci" src="http://ac.jobdu.com/upload/201201/image/fbncslie.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;现在要求输出斐波那契数列的第n项。&lt;/p&gt;
&lt;p&gt;首先，最容易想到的方法就是直接利用递归求解：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归求解的形式非常简单易懂，但是递归的解法存在很严重的效率问题，因为计算过程中很多结点都是重复计算的，而且重复的结点数随着n的增大而急剧增加。例如，假设n=100，那么程序的速度将慢到无法忍受！&lt;/p&gt;
&lt;p&gt;上面递归的方法之所以慢，是因为大量的重复计算，我们只需要把已经得到的数列的中间项保存起来，下次需要的时候直接查找，就不用重复计算了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;                                                                                                                                                                             
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fib2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;另外，斐波那契数列数列还有不少的应用，下面列出几个例子。&lt;/p&gt;
&lt;h3&gt;1. 跳台阶的问题&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;p&gt;当只有1级台阶，有1种跳法；当只有2级台阶，有2种跳法。
当台阶数大于2，第一次跳有两种选择：第一次只跳1级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目；第一次跳2级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目。所以n级台阶不同跳法总数为f(n) = f(n-1) + f(n-2)。实际上就是斐波那契数列了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;numJump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;jump2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                                                        
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 变态跳台阶&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;p&gt;与上面的跳台阶问题类似。当n&amp;gt;2时，第一次跳有n种选择：第一次只跳1级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目；第一次跳2级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，依次类推，第一次直接跳n级。所以，所以n级台阶不同跳法总数为f(n) = f(n-1) + f(n-2) + ... + f(1) + 1。利用归纳法可以证明f(n) = 2^(n-1).&lt;/p&gt;
&lt;h3&gt;3. 矩形覆盖&lt;/h3&gt;
&lt;p&gt;我们可以用2&lt;em&gt;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;/em&gt;1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;p&gt;假设2 * n的大矩形总共有f(n)中覆盖方法。首先，用2*1的小矩形去覆盖大矩形最左边时有两个选择，若横着覆盖，则这个小矩形下面的那个小矩形也必须要横着覆盖，此时剩余2 * (n - 2)的区域，这种情形下的覆盖方法记为f(n - 2)；若竖着覆盖，则剩余2 * (n - 1)的区域，这种情形下覆盖的方法记为f(n - 1)。所以总的覆盖方法有：f(n - 1) + f(n - 2)。仍然是一个斐波那契数列。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 05 Apr 2015 00:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-05:fei-bo-na-qi-shu-lie-ji-qi-xiang-guan-wen-ti.html</guid><category>面试题</category></item><item><title>信息技术协会第一期电脑技术培训顺利举办</title><link>http://www.wengweitao.com/xin-xi-ji-zhu-xie-hui-di-yi-qi-dian-nao-ji-zhu-pei-xun-shun-li-ju-ban.html</link><description>&lt;blockquote&gt;
&lt;p&gt;新的学年开始了，一直想着信协能够举办几个新的有意思的活动，想了好久觉得既有意义，又能吸引其他专业的同学参加的，那么技术培训是个不错的选择。于是，就和协会的小伙伴们商量，准备定期举办同学们最感兴趣的系列技术专题培训。第一期便是Photoshop培训。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2014年10月17日晚七点，南燕信息技术协会举办了第一期电脑培训活动--Photoshop基础入门与应用的培训讲座。活动受到了同学们的广泛欢迎和好评。 &lt;/p&gt;
&lt;p&gt;本次培训讲座邀请2013级计算机应用技术的高龙飞同学担任主讲人。他深入浅出地介绍了Photoshop中常用的工具并通过实例操作向同学们清晰地展示各种操作方法。在讲解各种基础知识和工具之后，又通过PS常用的三个实例讲述了PS的使用技巧。同学们跟随主讲人的演示学习操作。两个小时的讲座很快就进入了尾声，同学们依然兴致盎然。&lt;/p&gt;
&lt;p&gt;&lt;img alt="培训现场" src="http://www.pkusz.edu.cn/uploadfile/2014/1020/20141020050506774.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;培训结束后，信息协会会长翁蔚涛对本次讲座作了简单的总结，并强调希望同学们在讲座后能多多练习，“纸上得来终觉浅，绝知此事要躬行”，并向同学们有奖征集协会的新海报设计，鼓励大家学以致用。简单总结过后，进入到抽奖环节，来自汇丰的陈敬钰同学获得了由协会送出的精美礼品。&lt;/p&gt;
&lt;p&gt;最后，协会成员和部分到场同学合影留念，第一期电脑培训活动圆满结束。接下来信息技术协会还会举办一系列培训，包括Matlab编程、网页制作等，希望同学们能够继续踊跃参加。&lt;/p&gt;
&lt;p&gt;&lt;img alt="合影" src="http://www.pkusz.edu.cn/uploadfile/2014/1020/20141020050520418.jpg" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信息技术协会致力于为北大深研院的同学们营造一个学习和交流信息学科得环境和氛围，为大家提供有关信息领域的设计、应用、资讯等方面的信息。信息技术协会积极打造与深港信息类企业合作和联动的平台，帮助学生走出校园，观察产业发展动态；积极开展电脑维护活动，帮助同学们解决生活中遇到的技术困难。在以后，信息技术协会仍然会坚持协会宗旨，继续为大家服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转自：http://news.pkusz.edu.cn/article-143-4357.html&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 18 Oct 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-10-18:xin-xi-ji-zhu-xie-hui-di-yi-qi-dian-nao-ji-zhu-pei-xun-shun-li-ju-ban.html</guid><category>校园</category></item><item><title>支持向量机——线性支持向量机</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;对于理想情况下线性可分的问题，可以使用上文介绍的线性可分支持向量机（硬间隔最大化）完美解决。但是，实际情况中，训练数据往往是线性不可分的，即在样本中存在噪声或特异点。此时，可以使用本文中介绍的更一般的学习算法——线性支持向量机（软间隔最大化）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;线性支持向量机&lt;/h2&gt;
&lt;p&gt;怎样才能把&lt;a href="http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html"&gt;上文中介绍的线性可分支持向量机&lt;/a&gt;扩展到线性不可分的数据集中呢？这就需要改变硬间隔最大化，使其成为软间隔最大化。&lt;/p&gt;
&lt;p&gt;通常情况下，数据集中存在一些特异点（outlier），将这些特异点去除后，剩下大部分样本点组成的集合是线性可分的。那些线性不可分的样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;意味着不能满足函数间隔大于等于1的约束条件（即&lt;span class="math"&gt;\(y_i(w.x_i + b)-1 \geq 0\)&lt;/span&gt;）。为了解决这个问题，可以为每个样本点引入一个松弛变量&lt;span class="math"&gt;\(\xi_i \geq 0\)&lt;/span&gt;，使函数间隔加上松弛变量后大于等于1.同时对每个松弛变量&lt;span class="math"&gt;\(\xi_i\)&lt;/span&gt;，支付一个代价&lt;span class="math"&gt;\(\xi_i\)&lt;/span&gt;。这样线性不可分的线性支持向量机的学习问题变成如下的凸二次规划问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b,\xi} \frac{1}{2}{||w||^2}+C\sum_{i=1}^{N}\xi_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　(1)y_i(w.x_i+b) \geq 1 - \xi_i　　(2)\xi_i \geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;这样可以和训练数据集可分时一样来考虑训练数据集线性不可分时的线性可支持向量机学习问题。相应于硬间隔最大化，它称为&lt;strong&gt;软间隔最大化&lt;/strong&gt;，并称这样的模型为&lt;strong&gt;线性支持向量机&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;学习的对偶算法&lt;/h2&gt;
&lt;p&gt;（1）构建拉格朗日函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b,\xi,\alpha,\mu)=\frac{1}{2}{||w||^2} +C\sum_{i=1}^{N}\xi_i- \sum_{i=1}^{N}\alpha_i(y_i(w.x_i+b)-1+\xi_i) - \sum_{i=1}^{N}\mu_i\xi_i$$&lt;/div&gt;
&lt;p&gt;
对每一个约束引进拉格朗日乘子&lt;span class="math"&gt;\(\alpha_i \geq 0, \mu_i \geq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题:
&lt;/p&gt;
&lt;div class="math"&gt;$$原始问题：min_{w,b,\xi}max_{\alpha_i \geq 0, \mu_i \geq 0}L(w, b, \xi, \alpha, \mu)$$&lt;/div&gt;
&lt;div class="math"&gt;$$对偶问题：max_{\alpha_i \geq 0, \mu_i \geq 0}min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)$$&lt;/div&gt;
&lt;p&gt;（3）求解对偶问题的解，需要先求&lt;span class="math"&gt;\(L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;对&lt;span class="math"&gt;\(w,b,\xi\)&lt;/span&gt;的极小，再求对&lt;span class="math"&gt;\(\alpha, \mu\)&lt;/span&gt;的极大&lt;/p&gt;
&lt;p&gt;（4）先求&lt;span class="math"&gt;\(min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;
将拉格朗日函数分别对&lt;span class="math"&gt;\(w,b,\xi\)&lt;/span&gt;求偏导数并令偏导数等于0. 将求得的结果代入拉格朗日函数中可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;（5）求&lt;span class="math"&gt;\(min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大，即是对偶问题
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{\alpha}L(w, b,  \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$　　C-\alpha_i-\mu_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha_i \geq 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$\mu_i \geq 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;转化下可以得到对偶问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;得到&lt;strong&gt;线性支持向量机的学习算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：现在可分训练数据集T&lt;/p&gt;
&lt;p&gt;输出：分离超平面和分类决策函数&lt;/p&gt;
&lt;p&gt;（1）构造并求解约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
求得最优解&lt;span class="math"&gt;\(\alpha^* = (\alpha_1^* ... \alpha_n^*)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）计算
&lt;/p&gt;
&lt;div class="math"&gt;$$w^* = \sum_{i=1}^{N}\alpha_i^*y_ix_i$$&lt;/div&gt;
&lt;p&gt;
并选择一个&lt;span class="math"&gt;\(0 &amp;lt; \alpha_j^* &amp;lt; C\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_ix_j)$$&lt;/div&gt;
&lt;p&gt;（3）求得分离超平面
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
分类决策函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;是由&lt;a href="http://book.douban.com/subject/10590856/"&gt;KKT条件&lt;/a&gt;得到的。w的解是唯一的，但是b的解不唯一。对于任一适合条件&lt;span class="math"&gt;\(0 &amp;lt; \alpha_j^* &amp;lt; C\)&lt;/span&gt;，都可以求出&lt;span class="math"&gt;\(b^*\)&lt;/span&gt;，所以实际计算时可以取在所有符合条件的样本点上的平均值。&lt;/p&gt;
&lt;h2&gt;支持向量&lt;/h2&gt;
&lt;p&gt;我们可以将&lt;span class="math"&gt;\(\alpha_i^* &amp;gt; 0\)&lt;/span&gt;的样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;称为&lt;strong&gt;支持向量&lt;/strong&gt;（软间隔的支持向量）。但是，这时的支持向量要比上文中介绍的复杂。&lt;/p&gt;
&lt;p&gt;实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;到间隔边界的距离为&lt;span class="math"&gt;\(\frac{\xi_i}{||w||}\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;lt; C\)&lt;/span&gt;，则&lt;span class="math"&gt;\(\xi_i = 0\)&lt;/span&gt;&lt;sup id="fnref:关系"&gt;&lt;a class="footnote-ref" href="#fn:关系" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;恰好落在间隔边界上；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* = C\)&lt;/span&gt;，&lt;span class="math"&gt;\(0&amp;lt; \xi_i &amp;lt; 1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;落在间隔边界与超平面之间，分类正确；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;gt; C\)&lt;/span&gt;，&lt;span class="math"&gt;\(\xi_i =1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;恰好在超平面上；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;gt; C\)&lt;/span&gt;，&lt;span class="math"&gt;\(\xi_i &amp;gt;1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;位于分离超平面误分一侧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;合页损失函数&lt;/h2&gt;
&lt;p&gt;线性支持向量机学习还有另外一种解释，就是最小化以下目标函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{i=1}^{N}[1-y_i(w.x_i+b)]_++\lambda ||w||^2$$&lt;/div&gt;
&lt;p&gt;
目标函数中的第一项是经验损失或经验风险，函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(y(w.x+b))=[1-y_i(w.x_i+b)]_+$$&lt;/div&gt;
&lt;p&gt;
称为合页损失函数（hinge loss function）。下标"+"表示以下取正值的函数
&lt;/p&gt;
&lt;div class="math"&gt;$$[z]_+=\left\{\begin{matrix}
z, z &amp;gt; 0\\ 
0, z \leq 0
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
表示样本点被正确分类（z &amp;gt; 0），损失是0；错误分类损失为&lt;span class="math"&gt;\(1−y_i(w.x_i+b)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;合页损失函数的图形，以函数间隔&lt;span class="math"&gt;\(y(w.x+b)\)&lt;/span&gt;为横轴，纵轴是损失。由于函数形状像一个合页，故名合页损失函数。与感知机的损失函数相比，相当于右移1长度，所以合页损失函数对学习要求更高，不仅要分类正确，而且确信度足够高时损失才是0（大于1的部分）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:关系"&gt;
&lt;p&gt;&lt;span class="math"&gt;\(C-\alpha_i-\mu_i=0\)&lt;/span&gt;并且&lt;span class="math"&gt;\(\mu_i^* \xi_i^*=0（从KTT条件可得）\)&lt;/span&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:关系" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 03 Aug 2014 14:54:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-03:zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html</guid><category>读书笔记</category></item><item><title>支持向量机——线性可分支持向量机</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;支持向量机（support vector machine， SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使之有别与感知机。支持向量机还包括核技巧，这使它成为实质上的非线性分类器。SVM的学习策略是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的学习算法是求解凸二次规划的最优算法。SVM学习方法包含构建由简至烦的模型：
- 线性可分支持向量机：当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性分类器
- 线性支持向量机：当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），学习一个线性分类器，也称为软间隔支持向量机
- 非线性支持向量机：当训练数据线性不可分时，通过使用核技巧（kernel trick）即软间隔最大化，学习非线性支持向量机。
核函数（kernel function）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法称为核技巧。核方法是比支持向量机更为一般的机器学习方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;线性可分支持向量机与硬间隔最大化&lt;/h2&gt;
&lt;h3&gt;线性可分支持向量机&lt;/h3&gt;
&lt;p&gt;支持向量机中，输入都由输入空间转换到特征空间将输入映射为特征向量，支持向量机的学习是在特征空间中进行的。&lt;/p&gt;
&lt;p&gt;假设训练数据是线性可分的，学习的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程&lt;span class="math"&gt;\(w.x+b=0\)&lt;/span&gt;，它由法向量w和截距b决定，可用(w,b)来表示。分离超平面将特征空间划分为两部分，一部分为正类，一部分为负类。法向量执行的一侧为正类，另一侧为负类。&lt;/p&gt;
&lt;p&gt;一般地，当训练数据集线性可分时，存在无穷个超平面可将两类数据正确分开。感知机利用误分类最小的策略，求得分离超平面，不过这时的解有无穷多个。线性可分支持向量机利用间隔最大化求最优分离超平面，这时，解是唯一的。&lt;/p&gt;
&lt;p&gt;给定线性可分训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
以及相应的分类决策函数
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;线性可分支持向量机&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;线性可分支持向量机对应着将两类数据正确划分并且间隔最大的直线。&lt;/p&gt;
&lt;h3&gt;函数间隔和几何间隔&lt;/h3&gt;
&lt;p&gt;一个点距离超平面的远近可以表示分类预测的确信程度（越远就越可信）。在超平面程&lt;span class="math"&gt;\(w.x+b=0\)&lt;/span&gt;确定的情况下，程&lt;span class="math"&gt;\(|w.x+b|\)&lt;/span&gt;能够相对地表示点x距离超平面的远近。而&lt;span class="math"&gt;\(w.x+b\)&lt;/span&gt;的符号与类标记y的符号是否一致能够表示分类是否正确。所以可以用&lt;span class="math"&gt;\(y(w.x+b)\)&lt;/span&gt;来表示分类的正确性及确信度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数间隔：&lt;/strong&gt; 定义超平面(w,b)关于样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的函数间隔为
&lt;/p&gt;
&lt;div class="math"&gt;$$\widehat{\gamma_i}=y_i(w.x_i+b)  $$&lt;/div&gt;
&lt;p&gt;
定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的函数间隔之最小值。&lt;/p&gt;
&lt;p&gt;但是，对于函数间隔只要成比例地改变w和b，例如变为2w和2b，超平面并没有改变，但是函数间隔却成为原来的2倍。可以对分离超平面的法向量w加某些约束，如规范化，||w||=1，使得间隔是确定的。这时函数间隔成为几何间隔（geometric margin）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几何间隔：&lt;/strong&gt; 定义超平面(w,b)关于样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的几何间隔为
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_i=y_i(\frac{w}{||w||}.x_i+\frac{b}{||w||})  $$&lt;/div&gt;
&lt;p&gt;
定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的几何间隔之最小值。&lt;/p&gt;
&lt;p&gt;如果||w||=1，函数间隔和几何间隔相等。如果超平面参数w和b成比例地改变，函数间隔也按比例改变，而几何间隔不变。&lt;/p&gt;
&lt;h3&gt;间隔最大化&lt;/h3&gt;
&lt;p&gt;支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。这里的集合间隔最大的分离超平面是唯一的，这里的间隔最大化又称为&lt;strong&gt;硬间隔最大化&lt;/strong&gt;。间隔最大化最直观的解释就是，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。&lt;/p&gt;
&lt;h4&gt;1.最大间隔分离超平面&lt;/h4&gt;
&lt;p&gt;最大间隔分离超平面这个问题可以表示为下面的约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{w,b} \gamma$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(\frac{w}{||w||}.x_i+\frac{b}{||w||}) \geq \gamma 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
约束条件表示为超平面(w,b)关于每个训练样本点的几何间隔至少是&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;。考虑几何间隔和函数间隔的关系式：
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_i = \frac{\widehat{\gamma_i}}{||w||}$$&lt;/div&gt;
&lt;p&gt;
可以将这个问题改写为：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{w,b} \frac{\widehat{\gamma_i}}{||w||}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) \geq \gamma 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
&lt;strong&gt;函数间隔&lt;/strong&gt;的取值&lt;span class="math"&gt;\(\widehat{\gamma_i}\)&lt;/span&gt;的取值并不影响最优化问题的解。可以将w和b成比例的改变，对上面最优化问题的不等式约束没有影响。也就是说，它产生一个等价的最优化问题。这样，就可以取&lt;span class="math"&gt;\(\widehat{\gamma_i}=1\)&lt;/span&gt;。将&lt;span class="math"&gt;\(\widehat{\gamma_i}=1\)&lt;/span&gt;代入上面的最优化问题，&lt;strong&gt;可以得到线性可分支持向量机学习的最优化问题&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b} \frac{1}{2}{||w||^2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) - 1\geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
这是一个凸二次规划&lt;sup id="fnref:convex"&gt;&lt;a class="footnote-ref" href="#fn:convex" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;（convex quadratic programming）问题。
如果解出了约束最优化问题的&lt;span class="math"&gt;\(w^*, b^*\)&lt;/span&gt;那么就可以得到最大间隔分离超平面&lt;span class="math"&gt;\(w^*.x + b^*=0\)&lt;/span&gt;及分类决策函数，也就是线性可分支持向量机模型。&lt;/p&gt;
&lt;h4&gt;最大间隔分类超平面的存在唯一性&lt;/h4&gt;
&lt;p&gt;线性可分训练数据集的最大间隔分离超平面是&lt;strong&gt;存在且唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;支持向量和间隔边界&lt;/h4&gt;
&lt;p&gt;训练数据集的样本点中与分离超平面距离最近的样本点的实例称为&lt;strong&gt;支持向量（support vector）&lt;/strong&gt;。支持向量是使约束条件等号成立的点，即
&lt;/p&gt;
&lt;div class="math"&gt;$$y_i(w.x_i+b) - 1= 0 $$&lt;/div&gt;
&lt;p&gt;
对&lt;span class="math"&gt;\(y_i=+1\)&lt;/span&gt;的正例点，支持向量在超平面：
&lt;/p&gt;
&lt;div class="math"&gt;$$H_1: w.x_i+b = 1 $$&lt;/div&gt;
&lt;p&gt;
上，对&lt;span class="math"&gt;\(y_i=-1\)&lt;/span&gt;的负例点，支持向量在超平面：
&lt;/p&gt;
&lt;div class="math"&gt;$$H_2: w.x_i+b = -1 $$&lt;/div&gt;
&lt;p&gt;
上。&lt;span class="math"&gt;\(H_1\)&lt;/span&gt;与&lt;span class="math"&gt;\(H_2\)&lt;/span&gt;上的点就是支持向量。&lt;span class="math"&gt;\(H_1\)&lt;/span&gt;与&lt;span class="math"&gt;\(H_2\)&lt;/span&gt;是平行的，它们之间的距离称为&lt;strong&gt;间隔（margin）&lt;/strong&gt;。间隔依赖于超平面的法向量w，等于&lt;span class="math"&gt;\(\frac{2}{||w||}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在决定分离超平面时只有支持向量其作用，而其他实例点并不起作用，所以将这种分类模型称为支持向量机。支持向量的个数一般很少，所以支持向量机由很少的“重要”训练样本确定。&lt;/p&gt;
&lt;h3&gt;学习的对偶算法&lt;/h3&gt;
&lt;p&gt;为了求解线性可分支持向量机的最优化问题，将它作为原始最优化问题，应用拉格朗日对偶性。通过求解对偶问题得到原始问题的最优解，这就是线性可分支持向量机的对偶算法。这样做的优点，一是对偶问题往往更容易求解；而是自然引入核函数，进而推广到非线性分类问题。&lt;/p&gt;
&lt;p&gt;线性可分支持向量机学习的最优化问题为：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b} \frac{1}{2}{||w||^2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) - 1\geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;（1）构建拉格朗日函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b,\alpha)=\frac{1}{2}{||w||^2} - \sum_{i=1}^{N}\alpha_iy_i(w.x_i+b)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;
对每一个约束引进拉格朗日乘子&lt;span class="math"&gt;\(\alpha_i \geq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题:
&lt;/p&gt;
&lt;div class="math"&gt;$$原始问题：min_{w,b}max_{\alpha_i \geq 0}L(w, b, \alpha)$$&lt;/div&gt;
&lt;div class="math"&gt;$$对偶问题：max_{\alpha_i \geq 0}min_{w,b}L(w, b, \alpha)$$&lt;/div&gt;
&lt;p&gt;（3）求解对偶问题的解，需要先求&lt;span class="math"&gt;\(L(w, b, \alpha)\)&lt;/span&gt;对w,b的极小，再求对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大&lt;/p&gt;
&lt;p&gt;（4）先求&lt;span class="math"&gt;\(min_{w,b}L(w, b, \alpha)\)&lt;/span&gt;
将拉格朗日函数分别对w,b求偏导数并令偏导数等于0. 将求得的结果代入拉格朗日函数中可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b}L(w,b,\alpha)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;（5）求&lt;span class="math"&gt;\(min_{w,b}L(w, b, \alpha)\)&lt;/span&gt;对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大，即是对偶问题
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{\alpha}L(w,b,\alpha)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. \sum_{i=1}^{N}\alpha_iy_i = 0　\alpha_i \geq 0, i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;可以将上面的目标函数由极大转换为求极小，得到&lt;strong&gt;线性可分支持向量机的学习算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：现在可分训练数据集T&lt;/p&gt;
&lt;p&gt;输出：分离超平面和分类决策函数&lt;/p&gt;
&lt;p&gt;（1）构造并求解约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b}L(w,b,\alpha)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. \sum_{i=1}^{N}\alpha_iy_i = 0　\alpha_i \geq 0, i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
求得最优解&lt;span class="math"&gt;\(\alpha^* = (\alpha_1^* ... \alpha_n^*)\)&lt;/span&gt;（必须满足&lt;span class="math"&gt;\(\alpha_i \geq 0\)&lt;/span&gt;，如果找不到则最小值在边界上）.&lt;/p&gt;
&lt;p&gt;（2）计算
&lt;/p&gt;
&lt;div class="math"&gt;$$w^* = \sum_{i=1}^{N}\alpha_i^*y_ix_i$$&lt;/div&gt;
&lt;p&gt;
并选择一个&lt;span class="math"&gt;\(\alpha_j^* &amp;gt; 0\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_ix_j)$$&lt;/div&gt;
&lt;p&gt;（3）求得分离超平面
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
分类决策函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;是由&lt;a href="http://www.wengweitao.com/la-ge-lang-ri-dui-ou-xing-lagrange-duality.html"&gt;KKT条件&lt;/a&gt;得到的。&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;只依赖于训练数据中对应于&lt;span class="math"&gt;\(\alpha_i &amp;gt; 0\)&lt;/span&gt;的样本点，而其他样本点对它们没有影响，因此，我们也可以将&lt;span class="math"&gt;\(\alpha_i &amp;gt; 0\)&lt;/span&gt;的样本点称为&lt;strong&gt;支持向量&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:convex"&gt;
&lt;p&gt;凸优化问题是指约束最优化问题
&lt;div class="math"&gt;$$min_x f(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. g_i(x) \leq0　h_i(x) \leq 0　i=1,2,...,N$$&lt;/div&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:convex" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 02 Aug 2014 20:32:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-02:zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html</guid><category>读书笔记</category></item><item><title>逻辑斯谛回归与最大熵模型</title><link>http://www.wengweitao.com/luo-ji-si-di-hui-gui-yu-zui-da-shang-mo-xing.html</link><description>&lt;blockquote&gt;
&lt;p&gt;逻辑斯谛回归（logistic regression）是统计学习中的经典分类方法，可以用于二类分类也可以用于多类分类。最大熵模型由最大熵原理推导出来，最大熵原理是概率模型学习或估计的一个准则，最大熵原理认为在所有可能的概率模型的集合中，熵最大的模型是最好的模型，最大熵模型也可以用于二类分类和多类分类。逻辑斯谛回归模型与最大熵模型都属于对数线性模型&lt;sup id="fnref:log"&gt;&lt;a class="footnote-ref" href="#fn:log" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;逻辑斯谛回归模型&lt;/h2&gt;
&lt;h3&gt;逻辑斯谛分布&lt;/h3&gt;
&lt;p&gt;设X是连续随机变量，X服从逻辑斯谛分布是指X具有如下分布函数和密度函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$F(X)=P(X \leq x)=\frac{1}{1+e^{-(x-u)/\gamma}}$$&lt;/div&gt;
&lt;div class="math"&gt;$$f(x)=F'(x)=\frac{e^{-(x-u)/\gamma}}{\gamma(1+e^{-(x-u)/\gamma})^2}$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(\mu\)&lt;/span&gt;为位置参数，&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;为形状参数。
&lt;strong&gt;分布函数的图形是一条S形曲线&lt;/strong&gt;（sigmoid curve），是中心对称的，曲线在中心点附近增长的较快，在两端增长的较慢。&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;的值越小，曲线在中心附近增长的越快。&lt;/p&gt;
&lt;h3&gt;逻辑斯谛回归模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二项逻辑斯谛回归模型&lt;/strong&gt;是如下的条件概率分布：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{exp(w.x+b)}{1+exp(w.x+b)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|x)=\frac{1}{1+exp(w.x+b)}$$&lt;/div&gt;
&lt;p&gt;
随机变量X取值为实数，输出Y是0或1，w称为权值向量，b称为偏置。二项逻辑斯谛回归模型是一种分类模型，由条件概率P(Y|X)表示，形式为参数化的逻辑斯谛分布。&lt;/p&gt;
&lt;p&gt;有时为了方便，将权值向量和输入向量加以扩展，将偏置放入权值向量中，输入向量也增加一个值为1的分量，这时逻辑斯谛回归模型可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{exp(w.x)}{1+exp(w.x)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|x)=\frac{1}{1+exp(w.x)}$$&lt;/div&gt;
&lt;p&gt;对逻辑斯谛回归而言，x输入分类为Y=1的对数几率&lt;sup id="fnref:odds"&gt;&lt;a class="footnote-ref" href="#fn:odds" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;或logit函数是：
&lt;/p&gt;
&lt;div class="math"&gt;$$log\frac{P(Y=1|X)}{P(Y=0|X)}=w.x$$&lt;/div&gt;
&lt;p&gt;
也就是说再逻辑斯谛回归模型中，输出Y=1的对数几率是输入x的线性函数。或者&lt;strong&gt;说Y=1的对数几率是由输入x的线性函数&lt;span class="math"&gt;\(w.x\)&lt;/span&gt;表示的模型，即逻辑斯谛回归模型&lt;/strong&gt;。
线性函数越接近正无穷，概率值就越接近1；越接近负无穷，概率值就越接近0.这样的模型就是逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;而在使用线性回归进行二类分类的时候：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)= w_0 + w_1x_1 + ... + w_nx_n$$&lt;/div&gt;
&lt;p&gt;
存在两个问题：&lt;/p&gt;
&lt;p&gt;（1）等式两边的取值范围不同。左边为概率是[0, 1]，右边是无穷&lt;/p&gt;
&lt;p&gt;（2）实际很多问题中，概率P和输入并非简单的线性关系，在x很小或很大的时候，可能对于P的影响很小，而x在某些值附近可能对P的影响很大。&lt;/p&gt;
&lt;p&gt;逻辑斯谛回归模型对线性回归模型进行了修正，解决了以上的2个问题。&lt;/p&gt;
&lt;h3&gt;模型参数估计&lt;/h3&gt;
&lt;p&gt;我们通过监督学习的方法来估计模型参数。对于给定的训练数据集，可以运用极大似然法估计模型参数，从而得到逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;假设
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|X)=\pi(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|X)=1 - \pi(x)$$&lt;/div&gt;
&lt;p&gt;
似然函数可以表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1 - \pi(x_i)]^{1-y_i}$$&lt;/div&gt;
&lt;p&gt;
对数似然函数表示为&lt;span class="math"&gt;\(L(w)\)&lt;/span&gt;，&lt;strong&gt;对&lt;span class="math"&gt;\(L(w)\)&lt;/span&gt;求最大值，得到w的估计值&lt;/strong&gt;。得到了
w就可以学到逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;这样问题就变成了以对数似然函数为目标的最优化问题。逻辑斯谛回归学习中常用的方法是梯度下降&lt;sup id="fnref:gradient descent"&gt;&lt;a class="footnote-ref" href="#fn:gradient descent" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;及拟牛顿法&lt;sup id="fnref:newton method"&gt;&lt;a class="footnote-ref" href="#fn:newton method" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h3&gt;多项逻辑斯谛回归&lt;/h3&gt;
&lt;p&gt;上面介绍的是二类分类，也可以将逻辑斯谛回归模型推广到多类分类。假设离散型随机变量Y的取值集合是{1,2,...,K}，那么多项逻辑斯谛回归模型是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=k|x)=\frac{exp(w_k.x)}{1+\sum_{k=1}^{K-1}exp(w_k.x)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=K|x)=\frac{1}{1+\sum_{k=1}^{K-1}exp(w_k.x)}$$&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;最大熵模型&lt;/h2&gt;
&lt;h3&gt;最大熵原理&lt;/h3&gt;
&lt;p&gt;最大熵原理认为，学习概率模型时，在所有可能的概率模型中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型的集合。最大熵原理认为选择的概率模型首先必须满足已有的事实，即约束条件。所以最大熵原理可以表示为：&lt;strong&gt;在满足约束条件的模型集合中选取熵最大的模型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在没有更多信息的情况下，可以按照满足约束条件下求等概率的方法估计概率分布（因为均匀分布，熵最大）。&lt;/p&gt;
&lt;h3&gt;最大熵模型的定义&lt;/h3&gt;
&lt;p&gt;将最大熵原理应用到分类就得到最大熵模型。&lt;/p&gt;
&lt;p&gt;给定训练数据集可以确定联合分布P(X,Y)的经验分布和边缘分布P(X)的经验分布&lt;span class="math"&gt;\(\widetilde{P}(X,Y)和\widetilde{P}(X)\)&lt;/span&gt;。用特征函数f(x,y)描述输入x和输出y之间的某一个事实，定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x,y)=\left\{\begin{matrix}
1,x与y满足某一事实\\ 
0,不满足某一事实
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;特征函数f(x,y)&lt;strong&gt;关于经验分布&lt;span class="math"&gt;\(\widetilde{P}(X,Y)\)&lt;/span&gt;的期望值&lt;/strong&gt;，用&lt;span class="math"&gt;\(E_\widetilde{P}(f)\)&lt;/span&gt;表示：
&lt;/p&gt;
&lt;div class="math"&gt;$$E_\widetilde{P}(f)=\sum_{x,y}\widetilde{P}(x,y)f(x,y)$$&lt;/div&gt;
&lt;p&gt;特征函数f(x,y)&lt;strong&gt;关于模型P(Y|X)与经验分布&lt;span class="math"&gt;\(\widetilde{P}(X)\)&lt;/span&gt;的期望值&lt;/strong&gt;，用&lt;span class="math"&gt;\(E_{P}(f)\)&lt;/span&gt;表示：
 &lt;/p&gt;
&lt;div class="math"&gt;$$E_p(f)=\sum_{x,y}\widetilde{P}(X)P(y|x)f(x,y)$$&lt;/div&gt;
&lt;p&gt;如果模型可以获取训练数据中的信息，那么可以假设以上两个期望值相等：
 &lt;/p&gt;
&lt;div class="math"&gt;$$E_\widetilde{P}(f)=E_p(f)$$&lt;/div&gt;
&lt;p&gt;
 或
 &lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{x,y}\widetilde{P}(x,y)f(x,y)=\sum_{x,y}\widetilde{P}(X)P(y|x)f(x,y)$$&lt;/div&gt;
&lt;p&gt;
以上两式作为&lt;strong&gt;模型学习的约束条件&lt;/strong&gt;。假如有n个特征函数&lt;span class="math"&gt;\(f_i(x,y)， i=1,2,...,n\)&lt;/span&gt;那么就有&lt;em&gt;n个约束条件&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;最大熵模型的学习&lt;/h3&gt;
&lt;p&gt;最大熵模型的学习可以形式化为约束最优化问题。&lt;/p&gt;
&lt;p&gt;给定训练数据集T已经特征函数&lt;span class="math"&gt;\(f_i(x,y)， i=1,2,...,n\)&lt;/span&gt;，最大熵模型的学习等价于约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{P \in C} H(P)=-\sum_{x,y}\widetilde{P}(x)P(y|x)logP(y|x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. E_\widetilde{P}(f)=E_p(f)， i=1,2,...,n　并且　\sum_yP(y|x)=1$$&lt;/div&gt;
&lt;p&gt;
按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{P \in C} -H(P)=\sum_{x,y}\widetilde{P}(x)P(y|x)logP(y|x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. E_\widetilde{P}(f)-E_p(f)=0， i=1,2,...,n　并且　\sum_yP(y|x)=1$$&lt;/div&gt;
&lt;p&gt;
求解以上最优化问题，所得出的解，就是最大熵模型学习的解。&lt;/p&gt;
&lt;p&gt;这里，将约束最优化问题的原始问题转换为无约束最优化的对偶问题，通过求解对偶问题求解原始问题。&lt;/p&gt;
&lt;p&gt;（1）引入拉格朗日乘子，定义拉格朗日函数&lt;span class="math"&gt;\(L(P,w)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）首先求解&lt;span class="math"&gt;\(L(P,w)\)&lt;/span&gt;关于P的极小化问题，固定拉格朗日乘子&lt;span class="math"&gt;\(w_0,w_1,...,w_n\)&lt;/span&gt;，对P求偏导数&lt;/p&gt;
&lt;p&gt;（3）另各偏导数等于0，解出各个P，得到&lt;span class="math"&gt;\(min_PL(P,w)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）求解&lt;span class="math"&gt;\(L(P_w,w)\)&lt;/span&gt;关于w的极大化问题&lt;/p&gt;
&lt;p&gt;（5）令&lt;span class="math"&gt;\(L(P_w,w)\)&lt;/span&gt;对w的各偏导数为0&lt;/p&gt;
&lt;p&gt;（6）得到最大熵模型&lt;/p&gt;
&lt;p&gt;可以求解得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}exp(\sum_{i=1}^{n}w_if_i(x,y))$$&lt;/div&gt;
&lt;p&gt;
其中
&lt;/p&gt;
&lt;div class="math"&gt;$$Z_w(x)=\sum_{y}exp(\sum_{i=1}^{n}w_if_i(x,y))$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(Z_w(x)\)&lt;/span&gt;称为&lt;strong&gt;规范化因子&lt;/strong&gt;；&lt;span class="math"&gt;\(f_i(x,y)\)&lt;/span&gt;是特征函数；&lt;span class="math"&gt;\(w_i\)&lt;/span&gt;是特征的权值。有上式表示的模型&lt;span class="math"&gt;\(P_w=P_w(y|x)\)&lt;/span&gt;就是最大熵模型。最后，最大熵模型的学习归结为对偶函数的极大化。&lt;/p&gt;
&lt;h3&gt;极大似然函数&lt;/h3&gt;
&lt;p&gt;可以证明对偶函数的极大化等价于最大熵模型的极大似然估计。这样最大熵模型的学习问题就转化为具体求解对数似然函数极大化或对偶函数极大化问题。&lt;/p&gt;
&lt;p&gt;最大熵模型与逻辑斯谛回归模型有类似的形式，它们又称为&lt;strong&gt;对数线性模型(log linear model)&lt;/strong&gt;。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;模型学习的最优化选择&lt;/h2&gt;
&lt;p&gt;最大熵模型与逻辑斯谛回归模型学习归结为以似然函数为目标函数的最优化问题，通常通过迭代算法求解。这时的目标函数是光滑的凸函数，因此多种最优化的方法都适用，保证能找到全局最优解。常用的方法有改进的迭代尺度法、梯度下降法、牛顿法或拟牛顿法。牛顿法或拟牛顿法一般收敛速度更快。&lt;/p&gt;
&lt;h3&gt;改进的迭代尺度法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;改进的迭代尺度法（improved iterative scaling, IIS）&lt;/strong&gt;是一种最大熵模型学习的最优化算法。IIS的想法是：假设最大熵模型的当前的参数向量是&lt;span class="math"&gt;\(w\)&lt;/span&gt;，我们希望找到一个新的参数向量&lt;span class="math"&gt;\(w=w+\delta\)&lt;/span&gt;，使得模型的对数似然函数值增大。如果能有一种参数向量的更新方法&lt;span class="math"&gt;\(w \rightarrow w+\delta\)&lt;/span&gt;，那么就可以重复使用这一方法，直到找到对数似然函数的最大值。&lt;/p&gt;
&lt;h3&gt;拟牛顿法&lt;/h3&gt;
&lt;p&gt;最大熵模型还可以使用牛顿法或拟牛顿法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第六章&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/lilyth_lilyth/article/details/10032993&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:log"&gt;
&lt;p&gt;对数线性模型是对线性模型的一个变形，使用原始数据的对数建模。&amp;#160;&lt;a class="footnote-backref" href="#fnref:log" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:odds"&gt;
&lt;p&gt;一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。&amp;#160;&lt;a class="footnote-backref" href="#fnref:odds" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:gradient descent"&gt;
&lt;p&gt;参考我之前的另一篇文章&lt;a href="http://www.wengweitao.com/ti-du-xia-jiang-fa.html"&gt;梯度下降法&lt;/a&gt; &amp;#160;&lt;a class="footnote-backref" href="#fnref:gradient descent" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:newton method"&gt;
&lt;p&gt;参考我之前的另一篇文章&lt;a href="http://www.wengweitao.com/niu-dun-fa.html"&gt;牛顿法&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:newton method" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 01 Aug 2014 09:53:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-01:luo-ji-si-di-hui-gui-yu-zui-da-shang-mo-xing.html</guid><category>读书笔记</category></item><item><title>牛顿法</title><link>http://www.wengweitao.com/niu-dun-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;牛顿法是近似求解方程的方法，方法是使用函数的泰勒级数的前面几项来寻找方程的根。在统计学习中，牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是&lt;strong&gt;求解无约束最优化问题&lt;/strong&gt;的常用方法。有&lt;strong&gt;收敛速度快&lt;/strong&gt;的优点。牛顿法是&lt;strong&gt;迭代方法&lt;/strong&gt;，每一步需要求解目标函数的海森矩阵（Hessian matrix）的逆矩阵，计算比较复杂。拟牛顿法通过正定矩阵近似海赛矩阵的逆矩阵或海赛矩阵，简化了这一过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;牛顿法&lt;/h2&gt;
&lt;h3&gt;目标&lt;/h3&gt;
&lt;p&gt;考虑无约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$minf(x)$$&lt;/div&gt;
&lt;p&gt;其中&lt;span class="math"&gt;\(x^* $为目标函数的极小点。求出f(x)的极小点 $x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;泰勒级数&lt;/h4&gt;
&lt;p&gt;若函数f（x）在点的某一临域内具有直到（n+1）阶导数，则在该邻域内f（x）的n阶泰勒公式为
用无限项的级数连加式来表示一个函数，这些相加的项由函数在某一点的导数求得。在该点邻域内f（x）的n阶泰勒公式表示为&lt;img alt="泰勒级数" src="http://upload.wikimedia.org/math/0/2/8/02837e50dddb76c237328172e2040135.png" /&gt;。
对于二阶泰勒展开，二阶的项可以使用海森矩阵来表示。&lt;/p&gt;
&lt;h4&gt;海森矩阵&lt;/h4&gt;
&lt;p&gt;海森矩阵（Hessian matrix）是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵。可以表示为：
&lt;img alt="海森矩阵" src="http://upload.wikimedia.org/math/d/c/e/dce355e43fb1539863302f482da7e6f6.png" /&gt;&lt;/p&gt;
&lt;h3&gt;牛顿法算法&lt;/h3&gt;
&lt;p&gt;函数f(x)有极值的必要条件是在极值点处一阶导数为0，即梯度向量为0.特别是当&lt;span class="math"&gt;\(H(x^{(k)})\)&lt;/span&gt;是正定矩阵时，函数f(x)的极值为极小值。
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=0$$&lt;/div&gt;
&lt;p&gt;
假设f(x)具有二阶连续偏导数，则将f(x)在第k次迭代值&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;邻域内进行二阶展开。&lt;/p&gt;
&lt;p&gt;每次迭代从点&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;开始，求目标函数的极小点，作为第k+1次迭代值&lt;span class="math"&gt;\(x^{(k+1)}\)&lt;/span&gt;。对将f(x)在第k次迭代值&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;邻域内进行二阶展开，然后对x求导有：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=g_k + H_k(x-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;，&lt;span class="math"&gt;\(H_k\)&lt;/span&gt;是f(x)的海森矩阵在&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;的值。
假设&lt;span class="math"&gt;\(x^{(k+1)}\)&lt;/span&gt;满足：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x^{(k+1)})=0$$&lt;/div&gt;
&lt;p&gt;
由前面两个式子，可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$g_k + H_k(x^{(k+1)}-x^{(k)})=0$$&lt;/div&gt;
&lt;p&gt;
因此可得
&lt;/p&gt;
&lt;div class="math"&gt;$$x^{(k+1)}=x^{(k)}+p_k  \; \; \; 其中H_kp_k=-g_k$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：目标函数f(x)，梯度&lt;span class="math"&gt;\(g(x)=\bigtriangledown f(x)\)&lt;/span&gt;矩阵,海森矩阵&lt;span class="math"&gt;\(H(x)\)&lt;/span&gt;，精度要求&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：f(x)的极小值点&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）取初始点&lt;span class="math"&gt;\(x^{(0)}\)&lt;/span&gt;，置k=0&lt;/p&gt;
&lt;p&gt;（2）计算&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）若&lt;span class="math"&gt;\(\left \| g_k \right \| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）计算&lt;span class="math"&gt;\(H_k=H(x^{(k)})\)&lt;/span&gt;，并求&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$p_k=-H_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;（5）置&lt;span class="math"&gt;\(x^{(k+1)}=x^{(k)}+p_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（6）置k=k+1，转（2）&lt;/p&gt;
&lt;p&gt;步骤（4）中求&lt;span class="math"&gt;\(p_k=-H_k^{-1}g_k\)&lt;/span&gt;，先求&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;计算比较复杂，所以有其他改进算法。&lt;/p&gt;
&lt;h2&gt;拟牛顿法思路&lt;/h2&gt;
&lt;p&gt;考虑用一个n阶矩阵&lt;span class="math"&gt;\(G_k=G(x^{(k)})\)&lt;/span&gt;来代替&lt;span class="math"&gt;\(H_k^{-1}=H^{-1}(x^{(k)})\)&lt;/span&gt;。这就是拟牛顿法的基本想法。&lt;/p&gt;
&lt;p&gt;将&lt;span class="math"&gt;\(x=x^{(k+1)}\)&lt;/span&gt;代入下式：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=g_k + H_k(x-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
得到
&lt;/p&gt;
&lt;div class="math"&gt;$$g_{k+1} - g_k = H_k(x^{(k+1)}-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
记$y_k=g_{k+1} - g_k, \delta_k = x^{(k+1)}-x^{(k)} $，则
&lt;/p&gt;
&lt;div class="math"&gt;$$y_k = H_k\delta_k$$&lt;/div&gt;
&lt;p&gt;
或
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta_k = H_k^{-1}y_k$$&lt;/div&gt;
&lt;p&gt;
上式就称为拟牛顿条件。&lt;/p&gt;
&lt;div class="math"&gt;$$x=x^{(k)}+\lambda p_k = x^{(k)}-\lambda H_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;
所以f(x)在&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;的泰勒展开式可以近似写成：
&lt;/p&gt;
&lt;div class="math"&gt;$$ f(x) = f(x^{(k)})-\lambda g_k^TH_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;
因为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;是正定的，当&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;为一个充分小的正数时，总有&lt;span class="math"&gt;\(f(x)&amp;lt; f(x^{(k)})\)&lt;/span&gt;，也就是说&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;是下降方向。&lt;/p&gt;
&lt;p&gt;拟牛顿法将&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;的近似，要求矩阵&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;满足同样的条件。首先，&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;是正定的，同时&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;满足下面的拟牛顿条件：
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta_k = G_{k+1}y_k$$&lt;/div&gt;
&lt;p&gt;
按照拟牛顿条件选择将&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;的近似或者将&lt;span class="math"&gt;\(B_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k\)&lt;/span&gt;的近似的算法就称为&lt;strong&gt;拟牛顿法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;按照拟牛顿条件，在每次迭代中可以选择更新矩阵&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$G_{k+1} = G_{k} + \Delta G_{k} $$&lt;/div&gt;
&lt;p&gt;
这种选择有一定的灵活性，因此有多种具体实现方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DFP算法&lt;/strong&gt;：选择&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;的方法是，假设每一步迭代中矩阵&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;是由&lt;span class="math"&gt;\(G_{k}加上两个附加项构成\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BFGS算法&lt;/strong&gt;: 最流行的拟牛顿算法。BFGS算法与DFP算法类似，只是采用的B来近似H&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Broyden类算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BFGS的详细算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时相应的拟牛顿条件是
&lt;/p&gt;
&lt;div class="math"&gt;$$B_{k+1}\delta_k = y_k$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$B_{k+1}=B_{k}+P_{k}+Q_{k}$$&lt;/div&gt;
&lt;p&gt;
找到适合条件的&lt;span class="math"&gt;\(P_{k}和Q_{k}\)&lt;/span&gt;可以求得&lt;span class="math"&gt;\(B_{k+1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;输入：目标函数f(x)，梯度&lt;span class="math"&gt;\(g(x)=\bigtriangledown f(x)\)&lt;/span&gt;矩阵，精度要求&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; （不需要输入海森矩阵）&lt;/p&gt;
&lt;p&gt;输出：f(x)的极小值点&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）取初始点&lt;span class="math"&gt;\(x^{(0)}\)&lt;/span&gt;，取&lt;span class="math"&gt;\(B_0\)&lt;/span&gt;为正定对称矩阵，置k=0&lt;/p&gt;
&lt;p&gt;（2）计算&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）若&lt;span class="math"&gt;\(|\left \| g_k \right \|| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k)}\)&lt;/span&gt; ，否则转向（4）&lt;/p&gt;
&lt;p&gt;（4）计算&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$p_k=-B_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;（5）一维搜索：求&lt;span class="math"&gt;\(\lambda_k\)&lt;/span&gt;使得
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x^{(k)}+\lambda_k p_k) = min_{\lambda \geq 0}f(x^{(k)}+\lambda_k p_k)$$&lt;/div&gt;
&lt;p&gt;（6）置&lt;span class="math"&gt;\(x^{(k+1)}=x^{(k)}+\lambda_k p_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（7）计算&lt;span class="math"&gt;\(g_{k+1} =g(x^{(k+1)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（8）若&lt;span class="math"&gt;\(|\left \| g_{k+1} \right \|| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k+1)}\)&lt;/span&gt; ，否则计算出&lt;span class="math"&gt;\(B_{k+1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（9）置k=k+1，转（4）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 30 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-30:niu-dun-fa.html</guid><category>基本概念</category></item><item><title>拉格朗日对偶性（Lagrange Duality）</title><link>http://www.wengweitao.com/la-ge-lang-ri-dui-ou-xing-lagrange-duality.html</link><description>&lt;blockquote&gt;
&lt;p&gt;在求解约束优化问题的时候，常常利用拉格朗日对偶性（Lagrange Duality）将原始问题转化为对偶问题，通过求解对偶问题而得到原始问题的解。该方法用在许多统计学习方法中，如最大熵模型和SVM等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;原始问题&lt;/h2&gt;
&lt;h3&gt;原始最优化问题&lt;/h3&gt;
&lt;p&gt;考虑最优化问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$min_x f(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. c_i(x) \leq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$h_j(x) = 0   \:\:\:\:\: j=1,2,...,l$$&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;称此约束最优化问题为原始最优化问题或原始问题。&lt;/p&gt;
&lt;h3&gt;广义拉格朗日函数&lt;/h3&gt;
&lt;p&gt;为了解决原始问题，我们先引入&lt;strong&gt;广义拉格朗日（generalized Lagrangian）函数&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x, \alpha, \beta) = f(x) + \sum_{i=1}^{k}\alpha_i  c_i(x) + \sum_{j=1}^{l}\beta_j h_j(x)$$&lt;/div&gt;
&lt;p&gt;
这里的&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;和&lt;span class="math"&gt;\(\beta_j\)&lt;/span&gt;称为&lt;strong&gt;拉格朗日乘子&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;极小极大问题&lt;/h3&gt;
&lt;p&gt;现在考虑&lt;span class="math"&gt;\(L(x, \alpha, \beta)\)&lt;/span&gt;的最大值：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) = max_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
上式中的下标p代表“primal（原始问题）”。如果上式中的x不满足原始问题的约束条件（即存在某些i使得&lt;span class="math"&gt;\(c_i(x)&amp;gt;0\)&lt;/span&gt;或者&lt;span class="math"&gt;\(h_i(x) \neq 0\)&lt;/span&gt;），那么就有
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) =  f(x) + \sum_{i=1}^{k}\alpha_i  c_i(x) + \sum_{j=1}^{l}\beta_j h_j(x)= \infty$$&lt;/div&gt;
&lt;p&gt;
因为若&lt;span class="math"&gt;\(c_i(x)&amp;gt;0\)&lt;/span&gt;，可取&lt;span class="math"&gt;\(\alpha_i \rightarrow +\infty\)&lt;/span&gt;，或者&lt;span class="math"&gt;\(h_i(x) \neq 0\)&lt;/span&gt;，可令&lt;span class="math"&gt;\(\beta_j h_j(x) \rightarrow +\infty\)&lt;/span&gt;，而将其余的&lt;span class="math"&gt;\(\alpha_i ，\beta_j\)&lt;/span&gt;都取0.&lt;/p&gt;
&lt;p&gt;相反的，若满足原始优化问题的约束条件，那么有&lt;span class="math"&gt;\(\theta_p(x) = f(x)\)&lt;/span&gt;。所以有
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) = \left\{\begin{matrix}
f(x)   \:\:\:\:\: x满足约束条件\\
\infty  \:\:\:\:\: 其他
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
因此，如果我们考虑极小化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_x\theta_p(x) = min_xmax_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
我们可以看到这与原始最优化问题是等价的，称为&lt;strong&gt;广义拉格朗日函数的极小极大问题&lt;/strong&gt;。这样就把原始最优化问题转化为求解拉格朗日函数的极小极大问题。我们定义原始最优化问题的最优值为
&lt;/p&gt;
&lt;div class="math"&gt;$$p^* = min_x\theta_p(x)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;原始问题的值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;对偶问题&lt;/h2&gt;
&lt;p&gt;定义
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_D(x) = min_xL(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
上式中的下标D代表“dual（对偶问题）”。与前面定义的原始问题不同的是，原始问题是通过参数&lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt;进行优化（极大化），而这里定义的问题是通过&lt;span class="math"&gt;\(x\)&lt;/span&gt;进行优化（极小化）。&lt;/p&gt;
&lt;p&gt;对&lt;span class="math"&gt;\(\theta_D(x)\)&lt;/span&gt;极大化，就可以得到&lt;strong&gt;对偶优化问题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$max_{\alpha, \beta: \alpha_i \geq 0}\theta_D(\alpha, \beta) = max_{\alpha, \beta: \alpha_i \geq 0}min_xL(x, \alpha, \beta) $$&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;称为&lt;strong&gt;广义拉格朗日函数的极大极小问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对偶问题与原始问题除了交换式子中max和min的顺序外，是一样的。同样，我也定义&lt;strong&gt;对偶优化问题的最优值&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = max_{\alpha, \beta: \alpha_i \geq 0}\theta_D(\alpha, \beta)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;对偶问题的值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;原始问题和对偶问题的关系&lt;/h2&gt;
&lt;p&gt;容易得到（max min 小于等于 min max）：
&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = max_{\alpha, \beta: \alpha_i \geq 0}min_xL(x, \alpha, \beta) \leq min_xmax_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta)= p^*$$&lt;/div&gt;
&lt;p&gt;在某些条件下，原始问题和对偶问题的最优值相等即&lt;span class="math"&gt;\(d^* = p^*\)&lt;/span&gt;，这时可以&lt;strong&gt;用对偶问题替代原始问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理1：&lt;/strong&gt;考虑原始问题和对偶问题。假设&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;和&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;是凸函数（convex），&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt;是仿射函数（affine，与线性函数类似只是允许增加一个截距b）；并且存在x，对所有的i有&lt;span class="math"&gt;\(c_i(x) &amp;lt; 0\)&lt;/span&gt;. 则存在&lt;span class="math"&gt;\(x^* , \alpha^* ,\beta^*\)&lt;/span&gt;，使得在&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;是原始问题的解，&lt;span class="math"&gt;\(\alpha^* ,\beta^*\)&lt;/span&gt;是对偶问题的解，并且&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = p^* = L(x^*, \alpha^*, \beta^*)$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定理2：&lt;/strong&gt;考虑原始问题和对偶问题。假设&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;和&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;是凸函数（convex），&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt;是仿射函数（affine）；并且存在x，对所有的i有&lt;span class="math"&gt;\(c_i(x) &amp;lt; 0\)&lt;/span&gt;. 则&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;是原始问题的解，并且&lt;span class="math"&gt;\(\alpha^*, \beta^*\)&lt;/span&gt;是对偶问题的解的充分必要条件是&lt;span class="math"&gt;\(x^* , \alpha^* ,\beta^*\)&lt;/span&gt; 满足下面的&lt;strong&gt;Karush-Kuhn-Tucker(KKT)条件&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown_x L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\alpha L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\beta L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^* c_i(x^*) = 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$c_i(x^*) \leq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^* \geq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$h_j(x^*) = 0   \:\:\:\:\: j=1,2,...,l$$&lt;/div&gt;
&lt;p&gt;其中，上面的第4个式子，称为KKT的对偶互补条件，由此条件可得，若&lt;span class="math"&gt;\(\alpha^*&amp;gt;0\)&lt;/span&gt;那么&lt;span class="math"&gt;\(c_i(x^*) = 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 30 Jul 2014 09:56:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-30:la-ge-lang-ri-dui-ou-xing-lagrange-duality.html</guid><category>基础概念</category></item><item><title>决策树</title><link>http://www.wengweitao.com/jue-ce-shu.html</link><description>&lt;blockquote&gt;
&lt;p&gt;决策树（decision tree）是一种基本的分类与回归方法。它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。其主要优点是模型可读性好，分类速度快。决策树的学习通常包含3个部分：特征选择、决策树生成和决策树的修剪。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。常用的算法有ID3、C4.5和CART。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;决策树模型与学习&lt;/h2&gt;
&lt;h3&gt;决策树模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;决策树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。结点有两种类型：内部结点和叶结点。&lt;strong&gt;内部结点&lt;/strong&gt;表示一个特征或者属性，&lt;strong&gt;叶节点&lt;/strong&gt;表示一个类。&lt;/p&gt;
&lt;p&gt;用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归的对实例进行测试并分配，直至到达叶节点，最后将实例分配到叶节点的类中。&lt;/p&gt;
&lt;h3&gt;决策树与if-then规则&lt;/h3&gt;
&lt;p&gt;互斥且完备&lt;/p&gt;
&lt;h3&gt;决策树与条件概率分布&lt;/h3&gt;
&lt;p&gt;决策树还可以表示为&lt;strong&gt;给定特征条件下类的条件概率分布&lt;/strong&gt;。各叶节点上的条件概率往往偏向某一个类，决策树分类时将该结点的实例强行分到条件概率大的那一类去。&lt;/p&gt;
&lt;h3&gt;决策树学习&lt;/h3&gt;
&lt;p&gt;学习的目标：根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。&lt;/p&gt;
&lt;p&gt;决策树模型可以看成是由训练数据集估计条件概率模型。&lt;/p&gt;
&lt;p&gt;决策树的学习的策略是以损失函数为目标函数的最小化。决策树的损失函数通常是正则化的极大似然函数。&lt;strong&gt;学习的问题就变成了在损失函数意义下选择最优决策树的问题。&lt;/strong&gt;因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树的学习算法通常采用启发式方法，近似求解这一优化问题。这样得到的决策树是次最优（sub-optimal）的。&lt;/p&gt;
&lt;p&gt;决策树的学习算法通常是一个递归的选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。&lt;/p&gt;
&lt;p&gt;（1）开始构建根结点，将所有的训练数据都放入根结点；&lt;/p&gt;
&lt;p&gt;（2）选择一个最优特征，按照这一特征将训练数据分割成子集，使得各个子集有一个在当前条件下最好的分类；&lt;/p&gt;
&lt;p&gt;（3）如果这些子集已经基本被正确分类，那么就把这些子集分到所对应的叶节点中去；&lt;/p&gt;
&lt;p&gt;（4）如果还有子集未能基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行分割&lt;/p&gt;
&lt;p&gt;（5）如此递归下去，直到全部基本正确分类，最后每一个子集都被分配到叶节点上，即都有了明确的分类，这就生成了一棵决策树。&lt;/p&gt;
&lt;p&gt;以上生成的决策树对训练数据有很好的分类能力，但可能发生过拟合的情况。我们需要对生成的决策树进行自下而上的剪枝（去掉过于细分的叶结点，使其回退到父节点或者更高的结点，使树变得更简单），使其具有更好的泛化能力。&lt;/p&gt;
&lt;p&gt;如果特征数量过多，可以在决策树学习开始的时候，对特征进行选择，留下对训练数据有足够充分分类能力的特征。&lt;/p&gt;
&lt;p&gt;可以看出决策树的学习算法包含特征选择、决策树生成和决策树剪枝过程。由于决策树表示一个条件概率分布，所以深浅不同的决策树对应着不同复杂度的概率模型。决策树的生成对应于模型的局部选择，决策树的剪枝对应于模型的全局选择。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;特征选择&lt;/h2&gt;
&lt;h3&gt;特征选择问题&lt;/h3&gt;
&lt;p&gt;特征的选择在于选取对训练数据具有分类能力的特征，这样可以提高决策树学习的效率。&lt;strong&gt;通常特征选择的准则是信息增益或信息增益比&lt;/strong&gt;。特征选择是决定用哪个特征来划分特征空间。如果一个特征具有较强的分类能力，那么我们就应该选择这个特征（或者说一个特征能使划分后的子集在当前条件下有最好的分类）。信息增益（information gain）就能够很好的表示这一准则。&lt;/p&gt;
&lt;h3&gt;信息增益&lt;/h3&gt;
&lt;p&gt;先给出熵和条件熵的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熵（entropy）&lt;/strong&gt;表示随机变量不确定性的度量。假设X是一个取有限个值的离散变量，X的熵定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$H(X)=-\sum_{i=1}^{n}p_ilogp_i$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(p_i\)&lt;/span&gt;为X取每一个可能值的概率，上式中的对数以2为底或者以e为底，这时熵的单位分别称作比特（bit）或纳特（nat）。可以看出X的熵只依赖于X的分布，而与X的取值无关，所以可以将X的熵记为
&lt;/p&gt;
&lt;div class="math"&gt;$$H(p)=-\sum_{i=1}^{n}p_ilogp_i$$&lt;/div&gt;
&lt;p&gt;
熵越大，随机变量的不确定性就越大。从定义可以验证：
&lt;/p&gt;
&lt;div class="math"&gt;$$0 \leq H(p) \leq logn$$&lt;/div&gt;
&lt;p&gt;
即熵达到最大值（所有可能的事件等概率时不确定性最高）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件熵H(Y|X)&lt;/strong&gt;表示在已知随机变量X的条件下随机变量Y的不确定性。定义为X给定条件下Y的条件概率分布的熵对X的数学期望
&lt;/p&gt;
&lt;div class="math"&gt;$$H(Y|X)=\sum_{i=1}^{n}p_iH(Y|X=x_i)$$&lt;/div&gt;
&lt;p&gt;
这里&lt;span class="math"&gt;\(p_i=P(X=x_i), i=1,2,...,n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当熵和条件熵中的概率由数据统计得到时，所对应的熵与条件熵分别称为&lt;strong&gt;经验熵（empirical entropy）和经验条件熵（empirical conditional entropy）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息增益（information gain）&lt;/strong&gt;表示得知特征X的信息而使得类Y的信息不确定性的&lt;strong&gt;减少&lt;/strong&gt;长度。&lt;/p&gt;
&lt;p&gt;特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差：
&lt;/p&gt;
&lt;div class="math"&gt;$$g(D|A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;p&gt;
一般地，熵H(Y)与条件熵H(Y|X)之差称为互信息（mutual information）。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。
信息增益大的特征具有更强的分类能力。&lt;/p&gt;
&lt;p&gt;根据学习增益准则的特征选择方法：对训练数据集D，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息增益的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：训练数据集D和特征A；&lt;/p&gt;
&lt;p&gt;输出：特征A对训练数据集D的信息增益g(D,A)&lt;/p&gt;
&lt;p&gt;（1）计算数据集D的经验熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H(D)=-\sum_{k=1}^{K}\frac{C_k}{|D|}log_2\frac{C_k}{|D|}$$&lt;/div&gt;
&lt;p&gt;
（2）计算特征A对数据集D的经验条件熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{|D_i|}$$&lt;/div&gt;
&lt;p&gt;
（3）计算信息增益
&lt;/p&gt;
&lt;div class="math"&gt;$$g(D|A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(|D|\)&lt;/span&gt;表示样本容量，设有K个类&lt;span class="math"&gt;\(C_k，|C_k|\)&lt;/span&gt;属于类&lt;span class="math"&gt;\(C_k\)&lt;/span&gt;的样本数量。特征A将D划分为n个子集&lt;span class="math"&gt;\(D_1,D_2,...,D_n，|D_i|\)&lt;/span&gt;为&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;的样本数。子集&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;中属于类&lt;span class="math"&gt;\(C_k\)&lt;/span&gt;的样本的集合为&lt;span class="math"&gt;\(D_{ik}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;信息增益比&lt;/h3&gt;
&lt;p&gt;以信息增益作为划分训练数据集的特征，存在&lt;strong&gt;偏向于选择取值较多的特征&lt;/strong&gt;的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正。这是特征选择的另一准则。&lt;/p&gt;
&lt;p&gt;特征A对训练数据集D的信息增益比&lt;span class="math"&gt;\(g_R(D,A)\)&lt;/span&gt;定义为其信息增益g(D,A)与训练数据集D关于特征A的值的熵&lt;span class="math"&gt;\(H_A(D)\)&lt;/span&gt;之比：
&lt;/p&gt;
&lt;div class="math"&gt;$$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(H_A(D)=-\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}log_2\frac{|D_{i}|}{|D|}\)&lt;/span&gt;，n为特征A的取值个数，&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;表示特征A将D分成的子集。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;决策树的生成&lt;/h2&gt;
&lt;h3&gt;ID3算法&lt;/h3&gt;
&lt;p&gt;ID3算法的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。具体的方法是：&lt;/p&gt;
&lt;p&gt;（1）从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子节点&lt;/p&gt;
&lt;p&gt;（2）对子节点递归的调用以上方法，构建决策树&lt;/p&gt;
&lt;p&gt;（3）直到所有特征的信息增益均很小或没有特征选择为止。&lt;/p&gt;
&lt;p&gt;ID3算法相当于用极大似然估计法进行概率模型的选择。&lt;/p&gt;
&lt;h3&gt;C4.5的生成算法&lt;/h3&gt;
&lt;p&gt;C4.5算法与ID3算法类似，在生成的过程中，用信息增益比来选择特征。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;决策树的剪枝&lt;/h2&gt;
&lt;p&gt;决策树生成算法产生的决策树，会出现过拟合的现象。因为在学习的过程中过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法就是考虑决策树的复杂度，对已生成的决策树进行简化。对已生成的决策树进行简化的过程称为&lt;strong&gt;剪枝（pruning）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。决策树的损失函数可以定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=\sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中，树T的叶节点数为|T|，叶节点t有&lt;span class="math"&gt;\(|N_t|\)&lt;/span&gt;个样本点，其中属于k类的数目为&lt;span class="math"&gt;\(|N_{tk}|\)&lt;/span&gt;个，&lt;span class="math"&gt;\(H_t(T)\)&lt;/span&gt;为叶节点t的经验熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H_t(T)=-\sum_{k=1}^{K}\frac{|N_{tk}|}{|N_t|}log_2\frac{|N_{tk}|}{|N_t|}$$&lt;/div&gt;
&lt;p&gt;
决策树的损失函数可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
这时C(T)表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型的复杂度，参数α控制二者直接的影响。较大的α促使选择较简答的模型，较小反之。&lt;/p&gt;
&lt;p&gt;剪枝，就是当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;确定时，选择损失函数最小的模型，即损失函数最小的子树。利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的剪枝算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：生成算法产生的整棵树T，参数&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：修剪后的子树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）计算每个结点的经验熵&lt;/p&gt;
&lt;p&gt;（2）递归地从叶节点向上回缩。设叶节点回到到其父节点之前与之后的整体树分别为&lt;span class="math"&gt;\(T_B\)&lt;/span&gt;和&lt;span class="math"&gt;\(T_A\)&lt;/span&gt;，如果其对应的损失函数有：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_A) \leq C_\alpha(T_B)$$&lt;/div&gt;
&lt;p&gt;
则进行剪枝，即将父节点变为新的叶结点。&lt;/p&gt;
&lt;p&gt;（3）返回（2）直至不能继续，得到损失函数最小的子树。&lt;/p&gt;
&lt;p&gt;上式只需考虑两棵树的损失函数的差，其计算可以在局部进行，所以决策树的剪枝算法可以由一种动态规划算法实现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;CART算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;分类与回归树（classification and regression tree, CART）&lt;/strong&gt;是应用广泛的决策树学习方法。既可以用于分类也可以用于回归。CART假设决策树是&lt;strong&gt;二叉树&lt;/strong&gt;，内部结点的特征取值为“是”或“否”，左分支是取值为“是”的分支，右分支是取值为“否”的的分支。这样的决策树等于递归地二分每个特征，将输入空间划分为有限个单元，并在这些单元上确定预测的概率分布。&lt;/p&gt;
&lt;p&gt;CART算法由以下两步组成：&lt;/p&gt;
&lt;p&gt;（1）决策树的生成&lt;/p&gt;
&lt;p&gt;（2）决策树的剪枝&lt;/p&gt;
&lt;h3&gt;CART生成&lt;/h3&gt;
&lt;p&gt;决策树的生成就是递归地构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树&lt;strong&gt;用基尼指数（Gini index）最小化准则，进行特征选择&lt;/strong&gt;，生成二叉树。&lt;/p&gt;
&lt;h4&gt;回归树的生成&lt;/h4&gt;
&lt;p&gt;遍历所有输入变量，找到最优的切分变量j和切分点（可以用平方误差来表示回归树对于训练数据的预测误差，使预测误差最小），构成一个对（j,s）。依次将输入空间划分为两个区域，接着对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成一棵回归树。这样的&lt;strong&gt;回归树通常称为最小二乘回归树（least squares regression tree）&lt;/strong&gt;。&lt;/p&gt;
&lt;h6&gt;分类树的生成&lt;/h6&gt;
&lt;p&gt;分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。&lt;/p&gt;
&lt;p&gt;在分类问题中，假设有K个类，样本点属于第k类的概率为&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;，则概率分布的基尼指数定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(p)=\sum_{k=1}^{K}p_k(1-p_k)=1-\sum_{k=1}^{K}p_k^2$$&lt;/div&gt;
&lt;p&gt;
对于给定的样本集合D，其基尼指数为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(p)=1-\sum_{k=1}^{K}(\frac{|C_k|}{|D|})^2$$&lt;/div&gt;
&lt;p&gt;
假设样本集合D根据特征A是否取某一可能值a被分割成两个部分&lt;span class="math"&gt;\(D_1\)&lt;/span&gt;和&lt;span class="math"&gt;\(D_2\)&lt;/span&gt;，则在特征A的条件下，集合D的基尼系数定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$&lt;/div&gt;
&lt;p&gt;
&lt;strong&gt;基尼指数Gini(D)表示集合D的不确定性&lt;/strong&gt;，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数越大，样本集合的不确定性也就越大（与熵类似）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CART生成算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：训练数据集D，停止计算的条件（如结点中样本个数小于预定阈值，或样本集的基尼指数小于预定阈值）&lt;/p&gt;
&lt;p&gt;输出：CART决策树&lt;/p&gt;
&lt;p&gt;从根结点开始，递归地对每个结点进行以下操作：&lt;/p&gt;
&lt;p&gt;（1）设结点的训练数据集为D，计算现有特征对该数据集的基尼指数，对每一个特征A，对其可能的每一个取值a，根据样本点对A=a的测试为“是”或“否”将D分割成&lt;span class="math"&gt;\(D_1\)&lt;/span&gt;和&lt;span class="math"&gt;\(D_2\)&lt;/span&gt;两部分，计算A=a时的基尼指数。&lt;/p&gt;
&lt;p&gt;（2）在所有的特征A以及它们所有可能的切分点a中，&lt;strong&gt;选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点&lt;/strong&gt;。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。&lt;/p&gt;
&lt;h3&gt;CART剪枝&lt;/h3&gt;
&lt;p&gt;CART剪枝算法由两步组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）剪枝，形成一个子树序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从生成算法产生的决策树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;低端开始不断剪枝，直到&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;的根结点，形成一个子树序列&lt;span class="math"&gt;\({T_0,T_1,...,T_n}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在剪枝的过程中，计算子树的损失函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中，T为任意子树，C(T)为对训练数据的预测误差（如基尼指数），|T|为子树的叶结点个数。&lt;/p&gt;
&lt;p&gt;从整体树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;开始剪枝，对&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;的任意内部结点t，以t为单结点树的损失函数是（叶结点个数为0）
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(t)=C(t)+\alpha$$&lt;/div&gt;
&lt;p&gt;
以t为根结点的子树&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;的损失函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)=C(T_t)+\alpha|T_t|$$&lt;/div&gt;
&lt;p&gt;
当&lt;span class="math"&gt;\(\alpha=0及\alpha\)&lt;/span&gt;充分小时，有不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t) \leq C_\alpha(t)$$&lt;/div&gt;
&lt;p&gt;
当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;增大时，上面&lt;span class="math"&gt;\(C_\alpha(T_t) = C_\alpha(t)\)&lt;/span&gt;，当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;再增大时，上面的不等式就反向了。只要&lt;span class="math"&gt;\(\alpha = \frac{C(t)-C(T_t)}{|T_t|-1}\)&lt;/span&gt;，&lt;span class="math"&gt;\(T_t与t\)&lt;/span&gt;有相同的损失函数值，而t的结点少，因此t比&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;更可取，对&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;进行剪枝。&lt;/p&gt;
&lt;p&gt;为此对&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;中每一内部结点t，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$g(t) = \frac{C(t)-C(T_t)}{|T_t|-1}$$&lt;/div&gt;
&lt;p&gt;
上式的分子可以表示误差的增加，分母部分表示剪枝后树叶数量的减小。它表示剪枝后整体损失函数减少的程度。在&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;中减去g(t)最小的&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;，将得到子树作为&lt;span class="math"&gt;\(T_1\)&lt;/span&gt;，同时将最小的g(t)设为&lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;。&lt;span class="math"&gt;\(T_1\)&lt;/span&gt;为区间&lt;span class="math"&gt;\([\alpha_1,\alpha_2)\)&lt;/span&gt;的最优子树。&lt;/p&gt;
&lt;p&gt;如此剪枝下去，直至得到根结点。在这一过程中，不断增加&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的值，产生新的区间。&lt;/p&gt;
&lt;p&gt;（1）对于所有的子树t，我们想用合适的叶子节点来代替t，然后计算增加的误差E与t的叶子节点的比值（即g(t)）。我们选择比值最小的那个子树t，用合适的叶子节点代替之。&lt;/p&gt;
&lt;p&gt;（2）重复迭代以上步骤，每次都替换掉一棵子树。我们会得到从完全增长的树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;到只有根节点一个决策结点的树&lt;span class="math"&gt;\(T_n\)&lt;/span&gt;的一系列决策树：&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;。然后我们用独立的验证集(我们可以从可用数据集中抽取三分之一作为验证集，剩下的三分之二作为训练集)来验证各个决策树的分类准确性。选取准确性最高的决策树为最终的CART决策树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）在剪枝得到的子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中通过交叉验证选取最优子树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中每棵子树&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;都对应于一个参数&lt;span class="math"&gt;\(\alpha_0,\alpha_1,...,\alpha_n\)&lt;/span&gt;。所以当最优子树&lt;span class="math"&gt;\(T_k\)&lt;/span&gt;确定时，对应的&lt;span class="math"&gt;\(\alpha_k\)&lt;/span&gt;也确定了，即得到最优决策树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果一个结点是叶节点那么其g(t)为无穷大，如果不是叶节点那么按照以上的方法计算g(t)。每次从当前的树中选择一个g(t)最小的（因为该结点增加的误差率是最小的），然后删去该结点或结点集合，得到一棵新的树，然后递归上面的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CART剪枝算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：CART算法生成的决策树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：最优决策树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）设k=0, T=&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）$\alpha = +\infty $&lt;/p&gt;
&lt;p&gt;（3）自下而上对各内部结点计算&lt;span class="math"&gt;\(C(T_t)\)&lt;/span&gt;，计算出g(t)，并且将各结点计算出的最小的g(t)保存在&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;中&lt;/p&gt;
&lt;p&gt;（4）自上而下访问内部结点，如果g(t)=&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;，剪去g(t)最小的T，并对叶节点t以多数表决法决定其类，得到树T&lt;/p&gt;
&lt;p&gt;（5）k=k+1,在&lt;span class="math"&gt;\(\alpha_k=\alpha, T_k=T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（6）T不是由根结点单独一个结点构成的树，就&lt;strong&gt;返回（4）（（2）？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（7）采用交叉验证在剪枝得到的子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中选取最优子树&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第五章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 29 Jul 2014 10:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-29:jue-ce-shu.html</guid><category>读书笔记</category></item><item><title>朴素贝叶斯法</title><link>http://www.wengweitao.com/po-su-bei-xie-si-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;朴素贝叶斯法（naive Bayes）是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，利用特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;朴素贝叶斯法的学习与分类&lt;/h2&gt;
&lt;h3&gt;基本方法&lt;/h3&gt;
&lt;p&gt;朴素贝叶斯法通过训练数据集学习联合概率分布P(X,Y).x为输入特征向量，y为输出的类标记。
先求先验概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k), k = 1,2,...,K$$&lt;/div&gt;
&lt;p&gt;
然后求条件概率分布
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;
于是学习到联合概率分布P(X,Y)。&lt;/p&gt;
&lt;p&gt;条件概率分布&lt;span class="math"&gt;\(P(X=x|Y=c_k)\)&lt;/span&gt;有指级数量的次数，其估计实际是不可行的。假设&lt;span class="math"&gt;\(x^{(j)}\)&lt;/span&gt;的可能有&lt;span class="math"&gt;\(S_j\)&lt;/span&gt;个，j=1,2,...,n，Y的取值有K个，那么参数的个数为&lt;span class="math"&gt;\(K\prod S_j\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;朴素贝叶斯法是典型的生成方法。之所以叫做朴素贝叶斯法是因为该方法&lt;strong&gt;对条件概率的分布作了条件独立性的假设&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k)=\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;朴素贝叶斯分类时，对给定的输入x，通过学习到的模型计算后验概率分布&lt;span class="math"&gt;\(P(Y=c_k|X=x)\)&lt;/span&gt;，将后验概率最大的类作为x的类输出。&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X|Y)P(Y)}{\sum P(Y)P(X|Y)}$$&lt;/div&gt;
&lt;p&gt;
这是朴实贝叶斯分类器的基本形式。因为分母对于所有的&lt;span class="math"&gt;\(c_k\)&lt;/span&gt;都是相同的，所以朴素贝叶斯的分类器可以表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$y=argmaxP(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;
将n维的输入向量x代入，求出y值最大的那个分类&lt;span class="math"&gt;\(c_k\)&lt;/span&gt;，就是输入x的类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是先验概率和后验概率？
先验概率P(h)：就是在事情尚未发生之前，我们对该事件发生概率的估计，是根据以往经验分析得到的概率；
后验概率P(h|D)：给定D时，h发生的概率。是表示在某事件已经发生的条件下，求该事件由某个元素引起的可能性大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;后验概率最大化的含义&lt;/h3&gt;
&lt;p&gt;朴素贝叶斯法将实例分到后验概率最大的类中，这等价于期望经验风险最小化。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;朴素贝叶斯法的参数估计&lt;/h2&gt;
&lt;h3&gt;极大似然估计&lt;/h3&gt;
&lt;p&gt;在朴素贝叶斯法中，学习意味着估计&lt;span class="math"&gt;\(P(Y=c_k)\)&lt;/span&gt;和&lt;span class="math"&gt;\(P(X^{(j)}=x^{(j)}|Y=c_k)\)&lt;/span&gt;。可以运用极大似然估计法估计相应的概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)}{N}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x^{(j)}=a_{jl}|y_i=c_k)}{N}$$&lt;/div&gt;
&lt;h3&gt;贝叶斯估计&lt;/h3&gt;
&lt;p&gt;用极大似然估计可能会出现所要估计的概率值为0的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)+\lambda}{N+K\lambda}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x^{(j)}=a_{jl}|y_i=c_k)+\lambda}{N+S_j\lambda}$$&lt;/div&gt;
&lt;p&gt;
等价于在随机变量各个取值的频数上赋予一个正数&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;。常取&lt;span class="math"&gt;\(\lambda=1\)&lt;/span&gt;成为拉普拉斯平滑。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第四章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 28 Jul 2014 14:06:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-28:po-su-bei-xie-si-fa.html</guid><category>读书笔记</category></item><item><title>k近邻法</title><link>http://www.wengweitao.com/kjin-lin-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;k近邻法（k-nearest neighbor, k-NN）是一种基于分类与回归的方法。分类时，对新的待分类的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显示的学习过程。k值的选择、距离度量及分类决策规则是k近邻法的3个基本要素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;k近邻算法&lt;/h2&gt;
&lt;p&gt;k近邻算法简单、直观：对新的待分类的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。&lt;/p&gt;
&lt;h2&gt;k近邻模型&lt;/h2&gt;
&lt;p&gt;k近邻法的使用的模型实际上对应于对特征空间的划分。模型由三个要素——距离度量、k值的选择和分类决策规则决定。&lt;/p&gt;
&lt;h3&gt;模型&lt;/h3&gt;
&lt;p&gt;当训练集、距离度量、k值以及分类决策规程确定后，对于任何一个新的输入实例，它所属的类唯一确定。k近邻法的模型对应特征空间的一个划分，将特征空间划分为一些子空间，确定子空间里的每一个点所属的类。&lt;/p&gt;
&lt;p&gt;在特征空间中，对每个训练实例点&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;，距离该点比其他点更近的所有点组成一个区域，叫做单元（cell）。最近邻将实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;的类作为类&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;作为其单元中所有点的类标记（class label）。&lt;/p&gt;
&lt;h3&gt;距离度量&lt;/h3&gt;
&lt;p&gt;特征空间中两个实例点的距离是两个实例点相似程度的反映。&lt;/p&gt;
&lt;p&gt;设特征空间是n维实数向量空间，对于&lt;span class="math"&gt;\(x_i,x_j\)&lt;/span&gt;的&lt;span class="math"&gt;\(L_p\)&lt;/span&gt;距离定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L_p(x_i,x_j)=(\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|^p)^{\frac{1}{p}}$$&lt;/div&gt;
&lt;p&gt;
当p=2时，是欧氏距离；&lt;/p&gt;
&lt;p&gt;当p=1时，是曼哈顿距离；&lt;/p&gt;
&lt;p&gt;当p=&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;时，它是各个坐标距离的最大值，即
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_i,x_j)=max|x_i^{(l)}-x_j^{(l)}|$$&lt;/div&gt;
&lt;h3&gt;k值的选择&lt;/h3&gt;
&lt;p&gt;k值的选择会对k近邻法的结果产生重大的影响。如果选择较小的k值，那么就相当于用较小的领域中的训练实例进行预测，“学习”的近似误差（approximation error）会减小，只有与输入实例较近的训练实例才会对预测结果有作用。但缺点是“学习”的估计误差（estimation error）会增大，预测结果对近邻的实例点非常敏感，如果近邻点切好是噪音，那么预测就会出错。也就是说，k值较小整体模型越复杂，容易发生拟合。k值较大则相反。&lt;/p&gt;
&lt;p&gt;实际中通常k值取一个较小的数，采用交叉验证法来选取最优的k值。&lt;/p&gt;
&lt;h3&gt;分类决策规则&lt;/h3&gt;
&lt;p&gt;由输入实例的k个近邻中的多数类来决定输入实例的类。其实多数表决的功能就等价于经验风险最小化。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;k近邻法的实现：kd树&lt;/h2&gt;
&lt;p&gt;实现k近邻法时，主要考虑的问题是如果对训练数据进行快速k近邻搜索。最简单的实现方法就是线性扫描，计算新的输入实例与每一个训练实例的距离。当训练集很大，计算非常耗时，不可行。&lt;/p&gt;
&lt;p&gt;为了提高k近邻搜索效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。&lt;/p&gt;
&lt;h3&gt;构造kd树&lt;/h3&gt;
&lt;p&gt;kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每一个结点对应于一个k维超矩形区域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造平衡kd树的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：k维空间数据集&lt;span class="math"&gt;\(T={x_1,x_2,...,x_N}\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(x_i=(x_i^{(1)},x_i^{(2)},...,x_i^{(k)})^T\)&lt;/span&gt;，i=1,2,...,N；&lt;/p&gt;
&lt;p&gt;输出：kd树&lt;/p&gt;
&lt;p&gt;（1）开始：构造根结点，根结点对应于包含T的k维空间的超矩形区域。
选择&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;为坐标轴，以T中所有实例的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;垂直的超平面实现。由根结点生成深度为1的左、右结点，左子结点区域的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标对应的值小于切分点的值；右子结点区域的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标对应的值大于切分点的值。将落在切分超平面上的实例点保存在根结点。&lt;/p&gt;
&lt;p&gt;（2）重复：对于深度为j的结点，选择&lt;span class="math"&gt;\(x^{(l)}\)&lt;/span&gt;为切分的坐标轴，&lt;span class="math"&gt;\(l=j \mod k + 1\)&lt;/span&gt;（如对于2维空间，（0,1）、（1,2）、（2,1）、（3,2）...），以该结点区域中所有实例的&lt;span class="math"&gt;\(x^{(l)}\)&lt;/span&gt;坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。&lt;/p&gt;
&lt;p&gt;（3）直到两个区域没有实例存在时停止（所有实例点都在超平面上）。&lt;/p&gt;
&lt;h3&gt;搜索kd树&lt;/h3&gt;
&lt;p&gt;kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用kd树的最邻近搜索的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：已构造的kd树；目标点x；&lt;/p&gt;
&lt;p&gt;输出：x的最近邻&lt;/p&gt;
&lt;p&gt;（1）在kd树中找到包含目标点x的叶结点&lt;/p&gt;
&lt;p&gt;（2）以此叶节点为“当前最近点”&lt;/p&gt;
&lt;p&gt;（3）递归向上回退&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;）如果该结点保存的实例点比当前最几点距离目标点更近，则以该实例点为“当前”最近点&lt;/span&gt;

&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;）当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。即以目标点为球心，以目标点与当前最近点间的距离为半径的球体是否与另一子结点对应的区域相交。如果相交，可能在另一个子结点对应的区域中存在更近的点。移动到另一个子结点，接着递归地进行最邻近搜索。如果不相交，则向上回退。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（4）当回退到根结点，搜索结束，此时的当前最近结点即为最邻近点&lt;/p&gt;
&lt;p&gt;如果实例点是均匀分布的，那么kd树的搜索的平均计算复杂度是O(logN)，N为训练实例数。kd树适用于训练实例远大于空间维数时的k近邻搜索。当空间维数接近训练实例的时候，几乎接近线性搜索，效率迅速下降。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第三章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 27 Jul 2014 16:18:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-27:kjin-lin-fa.html</guid><category>读书笔记</category></item><item><title>感知机</title><link>http://www.wengweitao.com/gan-zhi-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于判别模型。感知机学习旨在求出将训练数据进行线性划分的分离超平面，为此导入了基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机是神经网络与支持向量机的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;感知机模型&lt;/h2&gt;
&lt;p&gt;由输入空间到输出空间的如下函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w.x+b)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;感知机&lt;/strong&gt;。其中w和b称为感知机模型参数，&lt;strong&gt;w叫做权值&lt;/strong&gt;（weight）或权值向量，b叫做偏置（bias）。感知机（perceptron）是&lt;strong&gt;二类分类的线性分类模型&lt;/strong&gt;，属于判别模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感知机的几何解释&lt;/strong&gt;：线性方程
&lt;/p&gt;
&lt;div class="math"&gt;$$w.x+b=0$$&lt;/div&gt;
&lt;p&gt;
对应于特征空间&lt;span class="math"&gt;\(R^n\)&lt;/span&gt;中的一个超平面S，其中w是超平面的法向量，b是超平面的截距。这个超平面将特征空间划分为两个部分，位于两部分的点分别被分为正、负两类。因此，超平面S称为&lt;strong&gt;分离超平面（separating hyperplanes）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;感知机学习，就是通过训练数据集，求得感知机模型，即求的模型参数w，b。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感知机学习策略&lt;/h2&gt;
&lt;h3&gt;数据集的线性可分性&lt;/h3&gt;
&lt;p&gt;如果存在某个超平面S
&lt;/p&gt;
&lt;div class="math"&gt;$$w.x+b=0$$&lt;/div&gt;
&lt;p&gt;
能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有&lt;span class="math"&gt;\(y_i=+1\)&lt;/span&gt;的实例i，有&lt;span class="math"&gt;\(w.x_i+b&amp;gt;0\)&lt;/span&gt;，对所有&lt;span class="math"&gt;\(y_i=-1\)&lt;/span&gt;的实例i，有&lt;span class="math"&gt;\(w.x_i+b&amp;lt;0\)&lt;/span&gt;，则称数据集T为&lt;strong&gt;线性可分数据集&lt;/strong&gt;；否则为线性不可分。&lt;/p&gt;
&lt;h3&gt;感知机学习策略&lt;/h3&gt;
&lt;p&gt;假设数据集线性可分，感知机的学习目标是求得一个能够将训练集正实例点和负实例点完全正确分开的超平面。为了找到这个超平面，即确定感知机模型参数w，b，需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。&lt;/p&gt;
&lt;p&gt;损失函数的一个自然选择是误分类点的总数，但是损失函数不是w，b的连续可导函数，不易优化。损失函数的另一个选择是计算误分类点到超平面的总距离。
输入空间中任一点&lt;span class="math"&gt;\(x_0\)&lt;/span&gt;到超平面S的距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{\left \| w \right \|}|w.x_0+b|$$&lt;/div&gt;
&lt;p&gt;
对于误分类的数据点&lt;span class="math"&gt;\(-y_i(w.x_1+b)&amp;gt;0\)&lt;/span&gt;那么所有误分类点到超平面的距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$-\frac{1}{\left \| w \right \|}\sum y_i(w.x_1+b)$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;感知机&lt;span class="math"&gt;\(sign(w.x+b)\)&lt;/span&gt;学习的损失函数定义为&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b)=-\sum y_i(w.x_1+b)$$&lt;/div&gt;
&lt;p&gt;
一个特定样本的损失函数，在误分类的时候该函数是w和b的线性函数，而正确分类的时候是0，因此损失函数时w和b的连续可导函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感知机学习策略&lt;/strong&gt;就是在假设空间中选取使感知机的损失函数最小的模型参数w和b，即感知机模型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感知机学习算法&lt;/h2&gt;
&lt;p&gt;感知机学习算法转化为求解感知机损失函数的最优化问题，最优化的方法是随机梯度下降法。&lt;/p&gt;
&lt;h3&gt;感知机学习算法的原始形式&lt;/h3&gt;
&lt;p&gt;首先，任意选取一个超平面&lt;span class="math"&gt;\(w_0,b_0\)&lt;/span&gt;，然后用梯度下降法不断地极小化目标函数，极小化的过程不是一次使M中所有误分类点的梯度下降，而是&lt;strong&gt;一次随机选取一个误分类点使其梯度下降&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设误分类点集合M是固定的，那么损失函数L(w,b)的梯度由：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial L(w,b)}{\partial w}=-\sum_{x_i\in M}y_ix_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$\frac{\partial L(w,b)}{\partial b}=-\sum_{x_i\in M}y_i$$&lt;/div&gt;
&lt;p&gt;
给出。
随机选取一个误分类点&lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;，对w,b进行更新：
&lt;/p&gt;
&lt;div class="math"&gt;$$w \leftarrow  w + \eta y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b \leftarrow  b + \eta y_i $$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;是步长，又称为学习速率。这样通过迭代可以期待损失函数L(w,b)不断减小，直到0. &lt;/p&gt;
&lt;p&gt;这种学习算法直观上解释：当一个实例类被误分类，即位于分离超平面的错误一侧时，则调整w,b的值，使分离超平面向该分类点的一侧移动，以减少该误分类点与超平面的距离，直至超平面越过该误分类点使其被正确分类。&lt;/p&gt;
&lt;p&gt;感知机学习算法的原始形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;输入：训练数据集T、学习率α
输出：w,b；感知机模型f(x)=sign(w.x + b)
(1)选取初值w0,b0
(2)在训练集中选取数据(xi,yi)
(3)如果yi(w.xi + b) &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;= 0，使用随机梯度下降法更新w和b
(4)转至(2)，直至训练集中没有误分类点（重复的将误分类的点一直更新）
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当采用不同的初值或者选取不同的误分类点的顺序时，解可能不同。&lt;/p&gt;
&lt;p&gt;这种算法是感知机学习的基本算法，对应于后面的对偶形式，称为&lt;strong&gt;原始形式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;算法的收敛性&lt;/h3&gt;
&lt;p&gt;可以证明，对于&lt;strong&gt;线性可分数据集感知机学习算法原始形式收敛&lt;/strong&gt;，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分割超平面及感知机模型。
可以证明：
&lt;/p&gt;
&lt;div class="math"&gt;$$k \leq (\frac{R}{\gamma})^2$$&lt;/div&gt;
&lt;p&gt;
其中k是误分类的次数，&lt;span class="math"&gt;\(R=max\left \| x_i \right \|\)&lt;/span&gt;，&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;。
即误分类的次数k是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。感知机学习算法存在许多解，这些解依赖于初值的选择和迭代过程中误分类点的选择顺序。为了得到唯一的超平面，需要对分离超平面增加约束条件（这就是SVM的思想）。&lt;/p&gt;
&lt;h3&gt;感知机学习算法的对偶形式&lt;/h3&gt;
&lt;p&gt;感知机学习算法的原始形式和对偶形式与SVM中的原始形式和对偶形式相对应。&lt;/p&gt;
&lt;p&gt;对偶形式的基本想法是：把w和b表示成实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;与标记&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;的线性组合的形式，通过求解其系数而求得w和b。
误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;对w,b进行逐步更新：
&lt;/p&gt;
&lt;div class="math"&gt;$$w \leftarrow  w + \eta y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b \leftarrow  b + \eta y_i $$&lt;/div&gt;
&lt;p&gt;
假设误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;修改了n次w，b，则w,b关于误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的增量分别是&lt;span class="math"&gt;\(\alpha_i y_i x_i\)&lt;/span&gt;和&lt;span class="math"&gt;\(\alpha_i y_i\)&lt;/span&gt;，这里&lt;span class="math"&gt;\(\alpha_i=n_i \eta\)&lt;/span&gt;。假设初始值&lt;span class="math"&gt;\(w_0,b_0\)&lt;/span&gt;均为0，那么最后可以学习到w,b的表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$w=\sum_{i=1}^{N}\alpha_i y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b=\sum_{i=1}^{N}\alpha_i y_i$$&lt;/div&gt;
&lt;p&gt;感知机学习算法的对偶形式：&lt;/p&gt;
&lt;p&gt;输入：训练数据集T、学习率η&lt;/p&gt;
&lt;p&gt;输出：α,b；感知机模型&lt;span class="math"&gt;\(f(x)=sign(\sum_{j=1}^{N}\alpha_j y_j x_j + b)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)选取初值&lt;span class="math"&gt;\(\alpha_0,b_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2)在训练集中选取数据(xi,yi)&lt;/p&gt;
&lt;p&gt;(3)如果&lt;span class="math"&gt;\(yi(\sum_{j=1}^{N}\alpha_j y_j x_j + b) \leq 0\)&lt;/span&gt;，更新&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;和b&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_i = \alpha_i + \eta$$&lt;/div&gt;
&lt;div class="math"&gt;$$b = b + \eta y_i$$&lt;/div&gt;
&lt;p&gt;(4)转至(2)，直至训练集中没有误分类点（重复的将误分类的点一直更新）&lt;/p&gt;
&lt;p&gt;为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的Gram矩阵：
&lt;/p&gt;
&lt;div class="math"&gt;$$G=[x_i.x_j]_{N \times N}$$&lt;/div&gt;
&lt;p&gt;
如&lt;span class="math"&gt;\(G_{1,1}\)&lt;/span&gt;为向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;与&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;的相乘结果。&lt;/p&gt;
&lt;p&gt;与原始形式一样，感知机学习算法的对偶形式是收敛的，存在多个解。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第二章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 26 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-26:gan-zhi-ji.html</guid><category>读书笔记</category></item><item><title>梯度下降法</title><link>http://www.wengweitao.com/ti-du-xia-jiang-fa.html</link><description>&lt;p&gt;&lt;strong&gt;梯度下降法（Gradient Descent）&lt;/strong&gt;是一种常见的最优化算法，用于求解函数的最大值或者最小值。&lt;/p&gt;
&lt;h2&gt;梯度的概念&lt;/h2&gt;
&lt;p&gt;一个函数&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;对它的一个变量&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的梯度定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial J(\theta))}{\partial \theta} = \lim_{\delta \theta\rightarrow 0}\frac{J(\theta + \delta \theta)-J(\theta ))}{\delta \theta}$$&lt;/div&gt;
&lt;p&gt;
某一点上的梯度指向标量场增长最快的方向，梯度的长度就是最大的变化率。&lt;/p&gt;
&lt;h2&gt;梯度下降&lt;/h2&gt;
&lt;p&gt;在高数中，我们求解一个函数的最小值时，最常用的方法就是求出它的导数为0的那个点，进而判断这个点是否能够取最小值。但是，在实际很多情况，我们很难求解出使函数的导数为0的方程，这个时候就可以使用梯度下降。我们知道对于一个函数沿着梯度的那个方向是下降是最快的。例如为了选取一个&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;使&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;最小，我们可以先随机选择&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;一个初始值，然后不断的修改&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;以减小&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;，直到&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的值不再改变。对于梯度下降法，可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha \frac{\partial J(\theta))}{\partial \theta_j} $$&lt;/div&gt;
&lt;p&gt;
即不断地向梯度的那个方向（减小最快的方向）更新&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，最终使得&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;最小。其中&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;称为学习速率（learning rate），取值太小会导致迭代过慢，取值太大可能错过最值点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举一个具体的例子，假如你在一座山的山顶准备下山，往哪一个方向走下山最快呢？下山最快的方向是最陡的那个方向，每一步你都应该朝最陡的那个方向走，直到到达山底，学习速率就表示你每一步迈的步伐有多大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;为什么从函数的梯度方向下降可以得到函数的最小值&lt;/h2&gt;
&lt;p&gt;梯度下降法，基于这样的观察：如果实值函数F(x)在点a 处可微且有定义，那么函数 F(x)在a点沿着梯度相反的方向&lt;span class="math"&gt;\(-\bigtriangledown F(a)\)&lt;/span&gt;下降最快。&lt;/p&gt;
&lt;p&gt;因而，如果
&lt;/p&gt;
&lt;div class="math"&gt;$$b=a-\alpha\bigtriangledown F(a)$$&lt;/div&gt;
&lt;p&gt;
那么&lt;span class="math"&gt;\(F(b) \leq F(a)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑如下序列&lt;span class="math"&gt;\(x_0,x_1,x_2,...\)&lt;/span&gt;使得
&lt;/p&gt;
&lt;div class="math"&gt;$$x_{n+1}=x_n-\alpha\bigtriangledown F(x_n)$$&lt;/div&gt;
&lt;p&gt;
因此可以得到：
&lt;span class="math"&gt;\(F(x_0) \geq F(x_1) \geq F(x_2) \geq ...\)&lt;/span&gt;
如果顺利的话序列最终可以收敛到期望的极值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="梯度下降描述" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Gradient_descent.png/350px-Gradient_descent.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：梯度下降得到的结果可能是局部最优值。如果&lt;span class="math"&gt;\(F(x)\)&lt;/span&gt;是凸函数，则可以保证梯度下降得到的是全局最优值。&lt;/p&gt;
&lt;h2&gt;批梯度下降法&lt;/h2&gt;
&lt;p&gt;批梯度下降法（batch gradient descent）的算法描述如下：&lt;/p&gt;
&lt;p&gt;对每一个j重复以下过程直到收敛 {
    &lt;/p&gt;
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha \sum_{i=1}^{m}\frac{\partial J(\theta , z))}{\partial \theta_j} $$&lt;/div&gt;
&lt;p&gt;
}&lt;/p&gt;
&lt;p&gt;其中假设训练样本数有m个，每个样本用&lt;span class="math"&gt;\(z_i\)&lt;/span&gt;可以表示为&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;。可以看出，使用批梯度下降法每一次更新&lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt;都需要遍历训练样本中的所有样本。&lt;/p&gt;
&lt;h2&gt;随机梯度下降法&lt;/h2&gt;
&lt;p&gt;除了批梯度下降法之外，还有一种算法称为——&lt;strong&gt;随机梯度下降法（stochastic gradient descent，SGD）&lt;/strong&gt;。算法描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Loop {
for i=1 to m, {
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha\frac{\partial J(\theta , z_i))}{\partial \theta_j} $$&lt;/div&gt;
}
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一次更新只使用了一个训练样本，但更新了m次。&lt;/p&gt;
&lt;p&gt;批梯度下降法每更新一步都需要遍历所有的样本数据，如果样本数m很大的话，就会非常的耗时；而对于随机梯度下降，每一遇到一个样本数据，就可以马上更新。通常情况下，使用随机梯度下降法的速度会比批梯度下降法快很多。因此，当样本数很大的时候，我们通常都选择使用随机梯度下降法。&lt;/p&gt;
&lt;h2&gt;关于梯度下降法中学习速率的取值问题&lt;/h2&gt;
&lt;p&gt;前面提到&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;称为学习速率（learning rate），取值太小会导致迭代过慢，取值太大可能错过最值点。所以对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;还是非常重要的。最常见的对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的选择策略为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不变策略：&lt;span class="math"&gt;\(\alpha_k=\alpha_0\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;1/k策略：&lt;span class="math"&gt;\(\alpha_k=\alpha_0\frac{\tau}{\tau + k}\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的取值方法，还是需要根据实际的数据进行实验得出。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;http://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&lt;/li&gt;
&lt;li&gt;http://www.iro.umontreal.ca/~bengioy/ift6266/H12/html/gradient_en.html&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 26 Jul 2014 16:18:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-26:ti-du-xia-jiang-fa.html</guid><category>基本概念</category></item><item><title>统计学习方法概论</title><link>http://www.wengweitao.com/tong-ji-xue-xi-fang-fa-gai-lun.html</link><description>&lt;blockquote&gt;
&lt;p&gt;本文主要介绍统计学习方法的一些基本概念。首先叙述统计学习的定义、研究对象与方法；然后叙述什么是监督学习；接着提出统计学习方法的三要素：模型、测量和算法；然后又介绍了模型选择的方法，包括：正则化与交叉验证；也介绍了学习方法的泛化能力；接着介绍了监督学习中的两种模型：生成模型和判别模型；最后介绍了监督学习方法的应用：分类问题、标注问题与回归问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;统计学习&lt;/h2&gt;
&lt;h3&gt;统计学习的特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;统计学习（statistical learning）&lt;/strong&gt;是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;研究对象：数据&lt;/li&gt;
&lt;li&gt;目的：对数据进行预测和分析&lt;/li&gt;
&lt;li&gt;以方法为中心，统计学习方法构建模型并运用模型进行预测与分析&lt;/li&gt;
&lt;li&gt;是概率论、统计学等多个学科的交叉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;统计学习的对象&lt;/h3&gt;
&lt;p&gt;统计学习的对象是数据（data），并且假设同类数据具有一定的统计规律性，这是统计学习的前提。只有具有一定的统计规律性才能使用概率论的方法进行描述。&lt;/p&gt;
&lt;h3&gt;统计学习的目的&lt;/h3&gt;
&lt;p&gt;考虑学习什么样的模型和如何学习模型，以使模型能够对数据进行准确的预测与分析，同时也要尽可能考虑学习的效率。&lt;/p&gt;
&lt;h3&gt;统计学习的方法&lt;/h3&gt;
&lt;p&gt;统计学习由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监督学习（supervised learning）&lt;/li&gt;
&lt;li&gt;非监督学习（unsupervised learning）&lt;/li&gt;
&lt;li&gt;半监督学习（semi-supervised learning）&lt;/li&gt;
&lt;li&gt;强化学习（reinforcement learning）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等几种学习方法组成。这里主要讨论监督学习。这种情况下，统计学习方法可以概括如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从给定的、有限的、用于学习的&lt;strong&gt;训练数据（traning data）&lt;/strong&gt;集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为&lt;strong&gt;假设空间（hypoth space）&lt;/strong&gt;；应用某个&lt;strong&gt;评价准则（evaluation criterion）&lt;/strong&gt;，从假设空间中选取一个&lt;strong&gt;最优的模型&lt;/strong&gt;，使得它对已知训练数据及未知&lt;strong&gt;测试数据（test data）&lt;/strong&gt;在给定的评价准则下有最优的预测；最优模型的选取由算法实现；利用最优模型对新数据进行预测或分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样统计学习方法包括：模型的假设空间、模型选择的准则以及模型学习的算法。&lt;strong&gt;这也就是统计学习方法的三要素：模型、策略、算法。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;监督学习&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;监督学习（supervised learning）&lt;/strong&gt;的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。
分类和回归都属于监督学习：必须知道预测什么，即目标变量的分类信息。&lt;/p&gt;
&lt;p&gt;而与此相对的是&lt;strong&gt;无监督学习（unsupervised learning）&lt;/strong&gt;，数据没有类别信息，也不会给定目标值。&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;输入空间、特征空间与输出空间&lt;/h4&gt;
&lt;p&gt;将输入与输出所有可能取值的集合分别称为&lt;strong&gt;输入空间（input space）&lt;/strong&gt;与&lt;strong&gt;输出空间（output space）&lt;/strong&gt;。
每个具体的输入是一个&lt;strong&gt;实例（instance）&lt;/strong&gt;，通常由&lt;strong&gt;特征向量（feature vector）&lt;/strong&gt;表示。这时，所有特征向量存在的空间称为&lt;strong&gt;特征空间（feature space）&lt;/strong&gt;。特征空间的每一维对应一个特征。&lt;/p&gt;
&lt;p&gt;输入变量X和输出变量Y有不同的类型，根据不同的类型，对预测任务给予不同的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回归问题&lt;/strong&gt;：输入变量与输出变量均为连续变量的预测（房间面积预测房价）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类问题&lt;/strong&gt;：输出变量为有限个离散变量的预测问题（新闻分类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标注问题&lt;/strong&gt;：输入变量与输出变量均为变量序列的预测问题（词性标注）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;联合概率分布&lt;/h4&gt;
&lt;p&gt;假定我们知道Y的一些情况，包括它和X一起出现的概率，在数学上称作&lt;em&gt;联合概率分布(Joint Probabilily)&lt;/em&gt;。输入变量X和输出变量Y遵循联合概率分布P(X,Y)。P(X,Y)表示&lt;strong&gt;分布函数&lt;/strong&gt;，或&lt;strong&gt;分布密度函数&lt;/strong&gt;。X和Y具有联合概率分布的假设是监督学习关于数据的基本假设。&lt;/p&gt;
&lt;h4&gt;假设空间&lt;/h4&gt;
&lt;p&gt;由输入到输出的映射是由模型来表示的，学习的目的就是为了找到最好的一个模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是&lt;strong&gt;假设空间（hypoth space）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;监督学习的模型可以是概率模型也可以是&lt;strong&gt;非概率模型&lt;/strong&gt;，由条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 或决策函数（decision function） &lt;span class="math"&gt;\(Y=f(x)\)&lt;/span&gt; 表示。&lt;/p&gt;
&lt;h3&gt;问题的形式化&lt;/h3&gt;
&lt;p&gt;监督学习分为学习和预测两个过程。学习的过程需要训练数据集，而训练数据集往往是人工给出的，所以称为监督学习。&lt;/p&gt;
&lt;p&gt;如果一个模型有很好的预测能力，训练样本输出&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;和模型输出&lt;span class="math"&gt;\(f(x_i)\)&lt;/span&gt;之间的差就应该足够小。&lt;/p&gt;
&lt;h2&gt;统计学习3要素&lt;/h2&gt;
&lt;p&gt;方法 = 模型 + 策略 + 算法&lt;/p&gt;
&lt;h3&gt;模型&lt;/h3&gt;
&lt;p&gt;模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。
假设空间通常是由一个&lt;strong&gt;参数向量&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;决定&lt;/strong&gt;的族。&lt;/p&gt;
&lt;h3&gt;策略&lt;/h3&gt;
&lt;p&gt;有了模型的假设空间，接着需要考虑按照什么样的准则学习或者选择最优的模型。
需要引入损失函数与风险函数的概念。&lt;/p&gt;
&lt;h4&gt;损失函数和风险函数&lt;/h4&gt;
&lt;p&gt;用&lt;strong&gt;损失函数（loss function）或代价函数（cost function）&lt;/strong&gt;来度量预测错误的程度，记作&lt;span class="math"&gt;\(L(Y,f(X))\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;常用的损失函数有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;0-1损失函数
&lt;div class="math"&gt;$$L(Y, f(X))=\left\{\begin{matrix}
0, Y \neq f(X)\\ 
1, Y =  f(X)
\end{matrix}\right.$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方损失函数（quadratic loss function）
&lt;div class="math"&gt;$$L(Y, f(X))=(Y - f(X))^2$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝对损失函数
&lt;div class="math"&gt;$$L(Y, f(X))=|Y - f(X)|$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数损失函数或者对数似然损失函数
&lt;div class="math"&gt;$$L(Y, P(Y|X))=-log(P(Y|X))$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输出(X,Y)是随机变量，遵循联合概率分布，所以&lt;strong&gt;损失函数的期望&lt;/strong&gt;是：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{exp}(f)=E_p[L(Y, f(X))]=\int L(y,f(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;这是模型&lt;span class="math"&gt;\(f(X)\)&lt;/span&gt;在联合概率分布P(X, Y)的平均意义下的损失，称为&lt;strong&gt;风险函数（risk function）或期望损失（expected loss）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;学习的目标是选择期望风险最小的模型，由于联合分布P(X,Y)是未知的（已知那么可以直接同P(X)求出P(Y|X)了），所以风险函数无法直接计算。&lt;/p&gt;
&lt;p&gt;模型f(X)关于一个给定训练数据集的平均损失称为&lt;strong&gt;经验风险（empirical risk）或者经验损失（empirical loss）&lt;/strong&gt;，记作：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{emp}(f)=\frac{1}{N}\sum L(y,f(x))$$&lt;/div&gt;
&lt;p&gt;
根据大数定律，当N趋于无穷时，经验风险趋于期望风险。所以很自然的想到用经验风险估计期望风险。但是实际训练样本数目有限，用经验风险评估期望风险常常并不理想，要对经验风险进行一定的矫正，这就关系到监督学习中的两个基本策略：经验风险最小化和结构化风险最小化。&lt;/p&gt;
&lt;h4&gt;经验风险最小化和结构化风险最小化&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;经验风险最小化（empirical risk minimization， ERM）&lt;/strong&gt;的策略认为，经验风险最小的模型是最优的模型。
当样本容量足够大时，经营风险最小化能保证有很好的学习效果，比如极大似然估计就是一个例子。&lt;/p&gt;
&lt;p&gt;当样本容量很小时，经营风险最小化可能产生&lt;strong&gt;过拟合（over-fitting）&lt;/strong&gt;的现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构风险最小化（structural risk minimization， SRM）&lt;/strong&gt;是为了防止过拟合而提出的策略，&lt;strong&gt;结构风险最小化等价于正则化（regularization）&lt;/strong&gt;。结构风险在经验风险上加上表示模型复杂度的正则化项或罚项。结构风险的定义是：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{srm}(f)=\frac{1}{N}\sum L(y_i,f(x_i))+\lambda J(f)$$&lt;/div&gt;
&lt;p&gt;
J(f)为模型的复杂度，模型f越复杂，复杂度J(f)就越大；反之越小。也就是说复杂度表示了对复杂模型的惩罚。$\lambda \geq 0 $用以权衡经验风险和模型复杂度。&lt;/p&gt;
&lt;p&gt;贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation, MAP）就是结构化风险最小化的例子。&lt;/p&gt;
&lt;p&gt;这样，&lt;strong&gt;监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的目标函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;算法&lt;/h3&gt;
&lt;p&gt;最后需要考虑用什么样的计算方法求解最优模型。&lt;/p&gt;
&lt;p&gt;如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模型的假设空间（模型）、模型选择的准则（策略）以及模型学习的算法（算法），这3个确定了，统计学习的方法也就确定了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;模型评估与模型选择&lt;/h2&gt;
&lt;h3&gt;训练误差与测试误差&lt;/h3&gt;
&lt;p&gt;前者是基于训练数据集的平均损失，后者是根据测试数据集的平均损失。测试误差反映了学习方法对未知的测试数据集的预测能力，越小就代表预测能力越强。通常将学习方法对未知数据的预测能力称为&lt;strong&gt;泛化能力（generalization ability）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;过拟合与模型选择&lt;/h3&gt;
&lt;p&gt;对于有多个模型，如果一味追求提高对训练数据的预测能力，所选模型的复杂度往往会比真模型更高，这种现象就称为&lt;strong&gt;过拟合（over-fitting）&lt;/strong&gt;。过拟合是指学习时选择的模型包含的参数过多，以致于出现这一模型对已知数据预测很好，但对未知数据预测得很差的现象。&lt;/p&gt;
&lt;p&gt;模型选择时，不仅要考虑对已知数据的预测能力，还要考虑对未知数据的预测能力。当训练数据拟合效果较好，模型也比较简单，是一个较好的选择。&lt;/p&gt;
&lt;p&gt;在多项式函数拟合中可以看到，随着多项式次数（模型复杂度）的增加，训练误差会减小，直至趋向于0，但测试误差却并不如此，会先减小，达到最小值，然后增大。
下面介绍两种常用的&lt;strong&gt;模型选择方法&lt;/strong&gt;：正则化与交叉验证。&lt;/p&gt;
&lt;h2&gt;正则化与交叉验证&lt;/h2&gt;
&lt;h3&gt;正则化&lt;/h3&gt;
&lt;p&gt;模型选择的典型方法是正则化（regularization），正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或惩罚项。正则化的作用就是选择经验风险与模型复杂度同时较小的模型。&lt;/p&gt;
&lt;p&gt;正则化符合奥卡姆剃刀（Occam's razor）原理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若无必要，勿增实体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在所有可能的选择汇总，能够很好的解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。从贝叶斯估计的角度看，正则化对应于模型的先验概率。复杂的模型有较小的先验概率，简单的模型有较大的先验概率。&lt;/p&gt;
&lt;h3&gt;交叉验证&lt;/h3&gt;
&lt;p&gt;如果样本充足，可以将数据集分为3个部分：训练集、验证集和测试集。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。
但是，在实际中，数据样本是不充足的，为了选择好的模型，可以采用交叉验证（cross validation）的方法。交叉验证的基本思想是重复地使用数据，将给定的数据集进行切分，将切分的数据集组合为训练集与测试集，反复进行训练、测试以及模型选择。&lt;/p&gt;
&lt;p&gt;1.简单交叉验证&lt;/p&gt;
&lt;p&gt;随机地将数据集分为两部分，一部分为训练集，一部分为测试集（如70%和30%的比例切分）。选出测试误差最小的模型。&lt;/p&gt;
&lt;p&gt;2.S折交叉验证&lt;/p&gt;
&lt;p&gt;应用最多的是S折交叉验证（S-fold cross validation）。随机地将数据集切分成S个互不相交的大小相同的子集；然后利用S-1个自己训练模型，利用余下的一个子集测试模型；重复这一过程S次，每次选择不同的一份子集作为测试集；最后选出S次评测中平均测试误差最小的模型。&lt;/p&gt;
&lt;p&gt;3.留一交叉验证&lt;/p&gt;
&lt;p&gt;S折交叉验证当S=N的特例，往往在数据缺乏的情况下使用。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;泛化能力&lt;/h2&gt;
&lt;h3&gt;泛化误差&lt;/h3&gt;
&lt;p&gt;泛化能力是指该方法学习到的模型对未知数据的预测能力，通常是通过测试误差来评价学习方法的泛化能力。
如果学到的模型是f，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error）：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{exp}(f)=E_p[L(Y, f(X))]=\int L(y,f(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;
事实上，泛化误差就是所学习到的模型的期望风险。&lt;/p&gt;
&lt;h3&gt;泛化误差的上界&lt;/h3&gt;
&lt;p&gt;学习方法的泛化能力往往都是通过研究泛化误差的上界进行的。泛化误差上界通常具有如下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是样本容量的函数，当样本容易增加，泛化上界趋向于0；&lt;/li&gt;
&lt;li&gt;它是假设空间容量的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于二类分类问题，当假设空间是有限个，对任意一个函数f，至少以概率&lt;span class="math"&gt;\(1-\sigma\)&lt;/span&gt;以下不等式成立：
&lt;/p&gt;
&lt;div class="math"&gt;$$R(f) \leq R’(f) + \epsilon (d, N, \sigma)$$&lt;/div&gt;
&lt;p&gt;
左端是泛化误差，右端即为泛化误差的上界。在泛化误差的上界中，第1项是训练误差，训练误差越小，泛化误差越小。第2项是N的单调递减函数，当N趋于无穷时趋于0；同时也是&lt;span class="math"&gt;\(\sqrt{logd}\)&lt;/span&gt;阶的函数（d是函数个数），假设空间中函数个数越多，其值越大。
可以证明以上不等式，需要用到Hoeffding不等式。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;生成模型与判别模型&lt;/h2&gt;
&lt;p&gt;监督学习方法可以分为&lt;strong&gt;生成方法（generative approach）和判别方法（discriminative approach）&lt;/strong&gt;。所学到的模型分别称为生成模型和判别模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成方法&lt;/strong&gt;由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|X)=\frac{P(X,Y)}{P(X)}$$&lt;/div&gt;
&lt;p&gt;
这样的方法称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。
典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判别方法&lt;/strong&gt;由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测模型，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。
典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成方法的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以还原出P(X,Y)，而判别模型不能&lt;/li&gt;
&lt;li&gt;学习收敛速度更快，即样本容量增加，学到的模型能够更快收敛于真实模型&lt;/li&gt;
&lt;li&gt;当存在隐变量时，仍然可以用生成学习方法学习，此时判别方法就不能用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判别方法的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接学习的是P(Y|X)或决策函数f(X)，直接面对预测，学习的效率更高&lt;/li&gt;
&lt;li&gt;由于是直接学习P(Y|X)或决策函数f(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;分类问题&lt;/h2&gt;
&lt;p&gt;当&lt;strong&gt;输出变量Y取有限个离散值&lt;/strong&gt;时，预测问题便成为分类问题。&lt;/p&gt;
&lt;p&gt;评价分类器性能的指标一般是分类&lt;strong&gt;准确率（accuracy）&lt;/strong&gt;，其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。&lt;/p&gt;
&lt;p&gt;对于二类分类问题常用的评价指标是&lt;strong&gt;精确率（precision）&lt;/strong&gt;与&lt;strong&gt;召回率（recall）&lt;/strong&gt;。通常以关注的类为正类，其他类为负类。预测的4种情况出现的总数分别记作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TP：将正类预测为正类数&lt;/li&gt;
&lt;li&gt;FN：将正类预测为负类数&lt;/li&gt;
&lt;li&gt;FP：将负类预测为正类数&lt;/li&gt;
&lt;li&gt;TN：将负类预测为负类数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精确率定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$P=\frac{TP}{TP+FP}$$&lt;/div&gt;
&lt;p&gt;
即预测结果为正类中的确是正类的概率。&lt;/p&gt;
&lt;p&gt;召回率定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$R=\frac{TP}{TP+FN}$$&lt;/div&gt;
&lt;p&gt;
即预测结果中与正类的概率占数据集中总的正类的概率。&lt;/p&gt;
&lt;p&gt;此外，还有&lt;span class="math"&gt;\(F_1\)&lt;/span&gt;值，是精确率和召回率的调和均值，即：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}$$&lt;/div&gt;
&lt;p&gt;
精确率和召回率都高时，&lt;span class="math"&gt;\(F_1\)&lt;/span&gt;值也会高。&lt;/p&gt;
&lt;p&gt;许多统计学习方法可以用于分类，包括k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯谛回归模型、支持向量机、提升方法、贝叶斯网络、神经网络等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;标注问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标注（taggging）&lt;/strong&gt;也是一个监督学习问题，可以认为是分类问题的一个推广，标注问题是对更复杂的结构预测问题的简单形式。标注问题的输入是一个观察序列，输出是一个标记序列或状态序列。注意，可能的标记个数是有限的，但其组合缩成的标记序列的个数是依序列长度呈指数级增长。&lt;/p&gt;
&lt;p&gt;标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。&lt;/p&gt;
&lt;p&gt;标注问题在信息抽取、自然语言处理等领域被广泛应用，如自然语言处理中的词性标注。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;回归问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;回归（regression）&lt;/strong&gt;是监督学习的另一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系。回归模型是表示从输入变量到输出变量之间的映射函数。回归问题的学习等价于函数拟合。&lt;/p&gt;
&lt;p&gt;回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间的关系的类型，分为线性回归和非线性回归。&lt;/p&gt;
&lt;p&gt;回归学习最常用的损失函数时平方损失函数，在此情况下，回归问题可以用著名的最小二乘法（least square）求解。&lt;/p&gt;
&lt;p&gt;回归问题可以用于预测股票，如将影响股票价格的各种因素作为自变量（输入特征），而将股价作为因变量（输出的值），将过去的数据作为训练数据，就可以学习一个回归模型，对未来的股价进行预测。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第一章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 25 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-25:tong-ji-xue-xi-fang-fa-gai-lun.html</guid><category>读书笔记</category></item><item><title>Hello, world</title><link>http://www.wengweitao.com/hello-world.html</link><description>&lt;p&gt;Hello, world!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 20 Jul 2014 00:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-20:hello-world.html</guid><category>测试</category></item></channel></rss>