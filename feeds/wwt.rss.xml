<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wwt's blog</title><link>http://www.wengweitao.com/</link><description></description><atom:link href="http://www.wengweitao.com/feeds%5Cwwt.rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 06 Jun 2015 11:19:00 +0800</lastBuildDate><item><title>[leetcode] Count Complete Tree Nodes</title><link>http://www.wengweitao.com/leetcode-count-complete-tree-nodes.html</link><description>&lt;h3&gt;题目&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://leetcode.com/problems/count-complete-tree-nodes/"&gt;Count Complete Tree Nodes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Given a complete binary tree, count the number of nodes.&lt;/p&gt;
&lt;h3&gt;分析&lt;/h3&gt;
&lt;p&gt;给定一棵完全二叉树，求出该树的结点数目。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees"&gt;完全二叉树&lt;/a&gt;的定义为：&lt;/p&gt;
&lt;p&gt;高度为h，有n个结点的二叉树，当前仅当其每一个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树。即叶节点只可能出现在层次最大的两层上，最大层上的叶节点从左到右依次排列。&lt;/p&gt;
&lt;p&gt;本题利用递归实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果当前结点的左右子树的高度相同，那么是一棵满二叉树，利用公式&lt;span class="math"&gt;\(n = 2^h -1\)&lt;/span&gt;计算出结点个数&lt;/li&gt;
&lt;li&gt;如果当前结点的左右子树高度不相同，那么递归求解其左子树的结点数left和右子树的结点数righ。返回left + right + 1即为结点总数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;参考代码&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * Definition for a binary tree node.&lt;/span&gt;
&lt;span class="cm"&gt; * struct TreeNode {&lt;/span&gt;
&lt;span class="cm"&gt; *     int val;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode *left;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode *right;&lt;/span&gt;
&lt;span class="cm"&gt; *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}&lt;/span&gt;
&lt;span class="cm"&gt; * };&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;countNodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;leftHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rightHeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pLeft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pLeft&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;leftHeight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pLeft&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pLeft&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pRight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pRight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;rightHeight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pRight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pRight&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;leftHeight&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;rightHeight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;leftHeight&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;countNodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;countNodes&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 06 Jun 2015 11:19:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-06-06:leetcode-count-complete-tree-nodes.html</guid><category>leetcode</category><category>面试题</category></item><item><title>算法中的灵机一动</title><link>http://www.wengweitao.com/suan-fa-zhong-de-ling-ji-yi-dong.html</link><description>&lt;p&gt;研究算法能给程序员带来许多好处，减少开发的时间，同时使执行速度更快。有些看起来很困难的问题，可能也存在着一个简单的、意想不到的答案。这些就是灵机一动的算法，需要在大量的研究之后才能出现。本文围绕三个小问题，来说明算法的灵机一动。&lt;/p&gt;
&lt;h2&gt;无处不在的二分搜索&lt;/h2&gt;
&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;给定一个最多包含40亿个随机排列的32位整数的&lt;strong&gt;顺序&lt;/strong&gt;文件，找出一个不在文件中的32位整数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在具有足够的内存情况下，如何解决该问题？&lt;/li&gt;
&lt;li&gt;如果有几个外部的临时文件可以用，但是仅有几百字节的内存，该如何解决该问题？&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;程序设计&lt;/h3&gt;
&lt;h4&gt;内存足够的情况&lt;/h4&gt;
&lt;p&gt;如果内存足够，就可以考虑位图的技术。使用一个大小为&lt;span class="math"&gt;\(2^{32}/8\)&lt;/span&gt;字节（512MB）形成的位图来表示出现的整数。然后，可以判断位图集合中的每一个数是否为-1，若为-1（-1的二进制表示全为1），表示该元素表示的数均出现在序列中，若不为-1，则未出现的整数在其中。&lt;/p&gt;
&lt;h4&gt;内存有限的情况&lt;/h4&gt;
&lt;p&gt;如果仅有几百个字节内存和几个稀疏顺序文件的情况下如何找到缺失的整数？&lt;/p&gt;
&lt;p&gt;考虑二分搜索算法。第一趟需要读入40亿个数，并判断每一个数32bit中的第一位（最高位开始）是1还是0，将第一位是0的写入一个文件，第一位是1的写入另一个文件。这样就按照第一位是1还是0，将所有40亿个数分成了两段，而缺失的数必定会在较小的那一段里面。然后，选取较小的那个段，再按照第二位是否为1，分成两段。依次处理每个位，直到有一个分组的个数为0.&lt;/p&gt;
&lt;p&gt;第一次需要处理n个数，第二次最多需要处理n/2个数，第三次最多需要处理n/3个数，...，因此时间复杂度为O(n)。每次只需在原来一半的范围内进行搜索，这就是二分问题的一个主要的思想。&lt;/p&gt;
&lt;p&gt;举一个具体的例子，假设给定一个包含10个4bit的整数{1,2,3,4,5,6,7,8,9,10}。首先按照第一位进行分组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;第一位为&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt; &lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="err"&gt;个）&lt;/span&gt;
&lt;span class="err"&gt;第一位为&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="err"&gt;个）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第一次分组，第一位为1的一组数目较小只有3个（3 &amp;lt; 16/2=8），所以缺失的数必定在这个段里存在（第一位为0的分组里也有数缺失0）。然后，选择第二个分组，按照第二位继续分组：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;第二位为&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;
&lt;span class="err"&gt;第二位为&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt; &lt;span class="n"&gt;None&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有一个分组的个数为0，那么就找到10之后的数11~15之内就全是缺失的数。&lt;/p&gt;
&lt;h2&gt;基本操作的威力&lt;/h2&gt;
&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;将一个n元一维数组向量向左旋转i个位置。例如，n=8且i=3时，向量abcdefgh旋转之后的结果为defghabc。如何完成该操作？&lt;/p&gt;
&lt;h3&gt;程序设计&lt;/h3&gt;
&lt;p&gt;我们可以将问题看做是把数组ab转换成ba，同时假定我们拥有一个函数可以将数组中特定部分的元素求逆。从ab开始，首先对a求逆得到&lt;span class="math"&gt;\(a^rb\)&lt;/span&gt;，然后对b求逆得到&lt;span class="math"&gt;\(a^rb^r\)&lt;/span&gt;。最后对整体求逆，得到的结果恰好是ba。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;rotate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上利用翻转实现的左旋转操作，在时间和空间上都非常高效，而且代码非常简短，不容易出错。&lt;/p&gt;
&lt;h2&gt;排序&lt;/h2&gt;
&lt;h3&gt;问题描述&lt;/h3&gt;
&lt;p&gt;给定一个英语字典，找出其中所有的变位词组合。例如，“pots”、"stop"和"tops"互为变位词，因为每一个单词都可以通过改变其他单词中字母的顺序得到。&lt;/p&gt;
&lt;h3&gt;程序设计&lt;/h3&gt;
&lt;p&gt;解决这个问题的许多方法都非常低效和复杂。任何一种考虑单词中所有字母排列的方法都是不可行的。例如一个长度为22的单词，有22!种排列，即使计算速度非常快，也需要花费数十年才能比较完。&lt;/p&gt;
&lt;p&gt;对于这个问题巧妙的解法就是标识字典中的每一个单词，使得在相同变位词类中的单词具有相同的标识。然后，将所有具有相同标识的单词集中在一起。这样就将原始的问题化为两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择标识；&lt;/li&gt;
&lt;li&gt;集中具有相同标识的单词。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第一个问题，我们可以将单词中的字母按照字母表顺序排列，如"pots"的标识就是"opst"，互为变位词的单词其标识都是相同的。对于第二个问题，我们将所有单词按照其标识的顺序进行排序。&lt;/p&gt;
&lt;h3&gt;变位词程序的实现&lt;/h3&gt;
&lt;p&gt;首先，创建第一个程序用于标识单词：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* sign.c -- sign each line of a file for finding anagrams                      &lt;/span&gt;
&lt;span class="cm"&gt;   For example: the input line &amp;quot;stop&amp;quot; gives the output line &amp;quot;opst&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define WORDMAX 100   &lt;/span&gt;&lt;span class="cm"&gt;/* word size is smaller than 100 */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;charcomp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WORDMAX&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WORDMAX&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;qsort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;charcomp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sign程序每次读入一个单词，然后输出单词的标识和单词本身的对(sign, word)。&lt;/p&gt;
&lt;p&gt;第二个程序用来实现对每个标识和单词对的排序。可以直接利用sort系统程序。&lt;/p&gt;
&lt;p&gt;第三个程序用来将变位词输出在同一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* squash.c -- print anagrams in the same line                                  &lt;/span&gt;
&lt;span class="cm"&gt;   The input lines &amp;quot;opst stop&amp;quot; and &amp;quot;opst post&amp;quot; go to &amp;quot;stop post&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define WORDMAX 100&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WORDMAX&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WORDMAX&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;oldSign&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;WORDMAX&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;linenum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;linenum&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oldSign&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sign&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;linenum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用一个测试文件dictionary对以上程序进行测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./sign &amp;lt; dictionary | sort | ./squash &amp;gt; result
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用hash的另一种实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;anagrams&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;strs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;unordered_map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt; 
            &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;auto&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]]);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将标识作为hash表的键，值为一个数组保存了对应单词在strs中的下标。如果值中保存的下标个数大于等于2，那么就存在变位词，输出之。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3227098/"&gt;编程珠玑&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/burningsheep/article/details/7814591/"&gt;关于《编程珠玑》中一个找出一个不存在的数的问题的探讨&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.cnblogs.com/wuyuegb2312/p/3139926.html#title12/"&gt;珠玑之椟:二分思想与分治法、排序思想&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 03 Jun 2015 20:37:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-06-03:suan-fa-zhong-de-ling-ji-yi-dong.html</guid><category>读书笔记</category></item><item><title>二叉树的三种遍历方式（递归、非递归和Morris遍历）</title><link>http://www.wengweitao.com/er-cha-shu-de-san-chong-bian-li-fang-shi-di-gui-fei-di-gui-he-morrisbian-li.html</link><description>&lt;p&gt;二叉树遍历是二叉树的最基本的操作，其实现方式主要有三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归遍历&lt;/li&gt;
&lt;li&gt;非递归遍历&lt;/li&gt;
&lt;li&gt;Morris遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;递归遍历的实现非常容易，非递归实现需要用到栈。而Morris算法可能很多人都不太熟悉，其强大之处在于只需要使用O(1)的空间就能实现对二叉树O(n)时间的遍历。&lt;/p&gt;
&lt;h2&gt;二叉树结点的定义&lt;/h2&gt;
&lt;p&gt;每个二叉树结点包括一个值以及左孩子和右孩子结点，其定义如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;TreeNode&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nl"&gt;public:&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;二叉树的遍历&lt;/h2&gt;
&lt;p&gt;二叉树的遍历，就是按照某条搜索路径访问树中的每一个结点，使得每个结点均被访问一次，而且仅被访问一次。常见的遍历次序有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先序遍历：先访问根结点，再访问左子树，最后访问右子树&lt;/li&gt;
&lt;li&gt;中序遍历：先访问左子树，再访问根结点，最后访问右子树&lt;/li&gt;
&lt;li&gt;后序遍历：先访问左子树，再访问右子树，最后访问根结点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面介绍，二叉树3种遍历方式的实现。&lt;/p&gt;
&lt;h2&gt;递归遍历&lt;/h2&gt;
&lt;p&gt;递归实现非常简单，按照遍历的次序，对当前结点分别调用左子树和右子树即可。&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;preOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;preOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;preOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;inOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;inOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;inOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;后序遍历&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;postOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;postOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;postOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;复杂度分析&lt;/h3&gt;
&lt;p&gt;二叉树遍历的递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了递归，最差情况下递归调用的深度为O(n)，所以空间复杂度为O(n)。&lt;/p&gt;
&lt;h2&gt;非递归遍历&lt;/h2&gt;
&lt;p&gt;二叉树遍历的非递归实现，可以借助栈。&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将根结点入栈；&lt;/li&gt;
&lt;li&gt;每次从栈顶弹出一个结点，访问该结点；&lt;/li&gt;
&lt;li&gt;把当前结点的右孩子入栈；&lt;/li&gt;
&lt;li&gt;把当前结点的左孩子入栈。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按照以上顺序入栈，这样出栈顺序就与先序遍历一样：先根结点，再左子树，最后右子树。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;preOrder2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;                                                                                                                                                                            
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;初始化一个二叉树结点pNode指向根结点；&lt;/li&gt;
&lt;li&gt;若pNode非空，那么就把pNode入栈，并把pNode变为其左孩子；（直到最左边的结点）&lt;/li&gt;
&lt;li&gt;若pNode为空，弹出栈顶的结点，并访问该结点，将pNode指向其右孩子（访问最左边的结点，并遍历其右子树）&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;inOrder2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;后序遍历&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;设置两个栈stk, stk2；&lt;/li&gt;
&lt;li&gt;将根结点压入第一个栈stk；&lt;/li&gt;
&lt;li&gt;弹出stk栈顶的结点，并把该结点压入第二个栈stk2；&lt;/li&gt;
&lt;li&gt;将当前结点的左孩子和右孩子先后分别入栈stk；&lt;/li&gt;
&lt;li&gt;当所有元素都压入stk2后，依次弹出stk2的栈顶结点，并访问之。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一个栈的入栈顺序是：根结点，左孩子和右孩子；于是，压入第二个栈的顺序是：根结点，右孩子和左孩子。因此，弹出的顺序就是：左孩子，右孩子和根结点。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;postOrder2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stk2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;stk2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stk2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;stk2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;stk2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，二叉树的后序遍历的非递归实现，也可以只使用一个栈来实现。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;postOrder2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// traverse down&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

         &lt;span class="cm"&gt;/* else {&lt;/span&gt;
&lt;span class="cm"&gt;                cout &amp;lt;&amp;lt; pNode-&amp;gt;val &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="cm"&gt;                stk.pop();&lt;/span&gt;
&lt;span class="cm"&gt;            }&lt;/span&gt;
&lt;span class="cm"&gt;        */&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;prev&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// traverse up from left&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* else if(pNode-&amp;gt;right == prev) { // traverse up from right&lt;/span&gt;
&lt;span class="cm"&gt;                cout &amp;lt;&amp;lt; pNode-&amp;gt;val &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="cm"&gt;                stk.pop();&lt;/span&gt;
&lt;span class="cm"&gt;        }&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;

        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;stk&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;prev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;复杂度分析&lt;/h3&gt;
&lt;p&gt;二叉树遍历的非递归实现，每个结点只需遍历一次，故时间复杂度为O(n)。而使用了栈，空间复杂度为二叉树的高度，故空间复杂度为O(n)。&lt;/p&gt;
&lt;h2&gt;Morris遍历&lt;/h2&gt;
&lt;p&gt;Morris遍历算法最神奇的地方就是，只需要常数的空间即可在O(n)时间内完成二叉树的遍历。O(1)空间进行遍历困难之处在于在遍历的子结点的时候如何重新返回其父节点？在Morris遍历算法中，通过修改叶子结点的左右空指针来指向其前驱或者后继结点来实现的。&lt;/p&gt;
&lt;h3&gt;中序遍历&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果当前结点pNode的左孩子为空，那么输出该结点，并把该结点的右孩子作为当前结点；&lt;/li&gt;
&lt;li&gt;如果当前结点pNode的左孩子非空，那么就找出该结点在中序遍历中的前驱结点pPre&lt;ul&gt;
&lt;li&gt;当第一次访问该前驱结点pPre时，其右孩子必定为空，那么就将其右孩子设置为当前结点，以便根据这个指针返回到当前结点pNode中，并将当前结点pNode设置为其左孩子；&lt;/li&gt;
&lt;li&gt;当该前驱结点pPre的右孩子为当前结点，那么就输出当前结点，并把前驱结点的右孩子设置为空（恢复树的结构），将当前结点更新为当前结点的右孩子&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复以上两步，直到当前结点为空。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;inOrder3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为只使用了两个辅助指针，所以空间复杂度为O(1)。对于时间复杂度，每次遍历都需要找到其前驱的结点，而寻找前驱结点与树的高度相关，那么直觉上总的时间复杂度为O(nlogn)。其实，并不是每个结点都需要寻找其前驱结点，只有左子树非空的结点才需要寻找其前驱，所有结点寻找前驱走过的路的总和至多为一棵树的结点个数。因此，整个过程每条边最多走两次，一次使定位到该结点，另一次是寻找某个结点的前驱，所以时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;如以下一棵二叉树。首先，访问的是根结点F，其左孩子非空，所以需要先找到它的前驱结点（寻找路径为B-&amp;gt;D-&amp;gt;E），将E的右指针指向F，然后当前结点为B。依然需要找到B的前驱结点A，将A的右指针指向B，并将当前结点设置为A。下一步，输出A，并把当前结点设置为A的右孩子B。之后，会访问到B的前驱结点A指向B，那么令A的右指针为空，继续遍历B的右孩子。依次类推。
&lt;img alt="一棵二叉树" src="http://blog.codinghonor.com/images/2014/threaded_binary_tree.jpg" /&gt;&lt;/p&gt;
&lt;h3&gt;前序遍历&lt;/h3&gt;
&lt;p&gt;与中序遍历类似，区别仅仅是输出的顺序不同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;preOrder3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPre&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;后序遍历&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先建立一个临时结点dummy，并令其左孩子为根结点root，将当前结点设置为dummy；&lt;/li&gt;
&lt;li&gt;如果当前结点的左孩子为空，则将其右孩子作为当前结点；&lt;/li&gt;
&lt;li&gt;如果当前结点的左孩子不为空，则找到其在中序遍历中的前驱结点&lt;ul&gt;
&lt;li&gt;如果前驱结点的右孩子为空，将它的右孩子设置为当前结点，将当前结点更新为当前结点的左孩子；&lt;/li&gt;
&lt;li&gt;如果前驱结点的右孩子为当前结点，倒序输出从当前结点的左孩子到该前驱结点这条路径上所有的结点。将前驱结点的右孩子设置为空，将当前结点更新为当前结点的右孩子。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重复以上过程，直到当前结点为空。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;printReverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   

    &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;postOrder3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TreeNode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;TreeNode&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;pPrev&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;printReverse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;pPrev&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="n"&gt;pNode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pNode&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;http://noalgo.info/832.html&lt;/p&gt;
&lt;p&gt;http://www.cnblogs.com/AnnieKim/archive/2013/06/15/morristraversal.html&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 27 May 2015 21:41:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-27:er-cha-shu-de-san-chong-bian-li-fang-shi-di-gui-fei-di-gui-he-morrisbian-li.html</guid><category>二叉树</category></item><item><title>CORS（跨域资源共享，Cross-Origin Resource Sharing）</title><link>http://www.wengweitao.com/corskua-yu-zi-yuan-gong-xiang-cross-origin-resource-sharing.html</link><description>&lt;p&gt;使用Django在服务器端写了一个API，返回一个JSON数据。使用Ajax调用该API：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;!DOCTYPE HTML&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;charset=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;meta&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;viewport&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;content=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;maximum-scale=1.0,minimum-scale=1.0,user-scalable=0,width=device-width,initial-scale=1.0&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;test&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;button&lt;/span&gt; &lt;span class="na"&gt;onclick=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;showPersonInfo()&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;点我获取数据&lt;span class="nt"&gt;&amp;lt;/button&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script &lt;/span&gt;&lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
        &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;showPersonInfo&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getJSON&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="s1"&gt;&amp;#39;http://xxx/account/getuserinfo/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;username&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;abc&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
                &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;br&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;用户名：&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;username&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;br&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;姓：&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;first_name&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;br&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;名:&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;last_name&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&amp;lt;br&amp;gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;邮箱&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="nx"&gt;json&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;email&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        
                    &lt;span class="nb"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;html&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，Chrome浏览器提示错误：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No 'Access-Control-Allow-Origin' header is present on the requested resource.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经过一番Google发现这个问题是——&lt;strong&gt;CORS&lt;/strong&gt;导致的。&lt;/p&gt;
&lt;h3&gt;什么是CORS？&lt;/h3&gt;
&lt;p&gt;CORS（跨域资源共享，Cross-Origin Resource Sharing）是一种跨域访问的机制，可以让Ajax实现跨域访问。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;API部署在DomainA上；&lt;/li&gt;
&lt;li&gt;Ajax文件部署在DomainB上，Ajax文件会向API发送请求，返回数据；&lt;/li&gt;
&lt;li&gt;用户通过DomainC访问DomainB的Ajax文件，请求数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上过程就发生了跨域访问。如果直接使用Ajax来请求就会失败，就像Chrome提示的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;No 'Access-Control-Allow-Origin' header is present on the requested resource.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;如何解决Ajax跨域访问问题？&lt;/h3&gt;
&lt;p&gt;本文以Django为例说明如何解决Ajax跨域访问问题。&lt;/p&gt;
&lt;h4&gt;1.使用JSONP&lt;/h4&gt;
&lt;p&gt;使用Ajax获取json数据时，存在跨域的限制。不过，在Web页面上调用js的script脚本文件时却不受跨域的影响，JSONP就是利用这个来实现跨域的传输。因此，我们需要将Ajax调用中的dataType从JSON改为JSONP（相应的API也需要支持JSONP）格式。&lt;/p&gt;
&lt;p&gt;JSONP只能用于GET请求。&lt;/p&gt;
&lt;h4&gt;2.直接修改Django中的views.py文件&lt;/h4&gt;
&lt;p&gt;修改views.py中对应API的实现函数，允许其他域通过Ajax请求数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myview&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HttpResponse&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;key&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;key2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Access-Control-Allow-Origin&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Access-Control-Allow-Methods&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;POST, GET, OPTIONS&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Access-Control-Max-Age&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1000&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Access-Control-Allow-Headers&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;*&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3.安装django-cors-headers&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/ottoyiu/django-cors-headers"&gt;django-cors-headers&lt;/a&gt;是Django的一个第三方APP，可以用来处理跨域访问的问题。&lt;/p&gt;
&lt;p&gt;安装django-cors-headers：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install django-cors-headers
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在settings.py中增加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;INSTALLED_APPS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;corsheaders&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;MIDDLEWARE_CLASSES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;corsheaders.middleware.CorsMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;django.middleware.common.CommonMiddleware&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以配置允许跨域访问的白名单或者直接设置为允许所有的跨域访问。具体配置可以参考&lt;a href="https://github.com/ottoyiu/django-cors-headers#configuration"&gt;这里&lt;/a&gt;。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 24 May 2015 16:49:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-24:corskua-yu-zi-yuan-gong-xiang-cross-origin-resource-sharing.html</guid><category>Python</category></item><item><title>怎样给一个磁盘文件排序？</title><link>http://www.wengweitao.com/zen-yang-gei-yi-ge-ci-pan-wen-jian-pai-xu.html</link><description>&lt;h3&gt;问题描述：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个最多包含n个正整数的文件，每个数都小于n，其中n=10^7（即每个数都是7位的正整数）。输入的文件中没有任何重复的数，并且没有其他数据与该整数关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按升序排列的输入整数的列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最多大约有1MB的内存空间可用，有充足的磁盘空间，运行的理想时间是10秒左右。&lt;/p&gt;
&lt;h3&gt;程序设计&lt;/h3&gt;
&lt;h4&gt;思路1：&lt;/h4&gt;
&lt;p&gt;如果每个号码使用一个32bit的int类型表示的话，那么在可用的1MB的存储空间中大约可以存入：
&lt;/p&gt;
&lt;div class="math"&gt;$$10^6 / 4 = 25000个数字。$$&lt;/div&gt;
&lt;p&gt;
因此，可以利用多路归并的思想。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将一千万个数字分成40份，每次将一份大小为25000个的正整数读入内存，利用快速排序对其进行排序。&lt;/li&gt;
&lt;li&gt;然后使用多路归并将各个已排好序的部分中的数据再次整体排好序后存入输出文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方法需要多次读入或者写出文件多次。&lt;/p&gt;
&lt;h4&gt;思路2：&lt;/h4&gt;
&lt;p&gt;使用位图或者位向量来表示集合。例如，如下字符串可以表示集合{1,3,4,5}:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代表集合中数值的位都置为1，其他所有位都置为0.&lt;/p&gt;
&lt;p&gt;1MB的内存空间大约可以存储800万个位，每个7位十进制数最多不超过1000万个整数。我们使用一个具有1000万个位的字符串来表示这个文件，其中，当且仅当整数i在文件中存在时，第i位为1.具体步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化：将所有的位都置为0；&lt;/li&gt;
&lt;li&gt;读入文件中的每一个整数来建立集合，将每个对应的位都置1；&lt;/li&gt;
&lt;li&gt;检查每一位，如果该位为1，就输出对应的整数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面，我们来实现利用位向量排序的算法。&lt;/p&gt;
&lt;h3&gt;代码实现&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;                                                              &lt;/span&gt;
&lt;span class="cp"&gt;#define N 10000000&lt;/span&gt;
&lt;span class="cp"&gt;#define MASK 0x1F&lt;/span&gt;
&lt;span class="cp"&gt;#define SHIFT 5&lt;/span&gt;
&lt;span class="cp"&gt;#define BITSPERWORD 32&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;BITSPERWORD&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;clr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SHIFT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;MASK&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SHIFT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;MASK&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;SHIFT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;MASK&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* initialize the set to empty */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;BITSPERWORD&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;top&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* initialize the set to empty &lt;/span&gt;
&lt;span class="cm"&gt;       can also be done as:&lt;/span&gt;
&lt;span class="cm"&gt;    for(int i = 0; i &amp;lt; N; ++i)&lt;/span&gt;
&lt;span class="cm"&gt;        clr(i);&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;


    &lt;span class="cm"&gt;/* insert present element to the set */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;scanf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* write sorted output */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;i&amp;gt;&amp;gt;SHIFT: 当前数i对应的是集合中的第几个数。一个int整数可以表示32个数字，如0~31对应为a[0]，32~63对应a&lt;a href="http://book.douban.com/subject/3227098/"&gt;1&lt;/a&gt;...相当于i/32&lt;/p&gt;
&lt;p&gt;1 &amp;lt;&amp;lt; (i &amp;amp; MASK): 将当前读入的整数在对应的5bit中的位置设置为1.如：i = 36, i &amp;amp; MASK = 00100, 1 &amp;lt;&amp;lt; 4 = 10000,即将36对应的bit上设置为1（这5bit分别对应的是32,33,34,35,36）.&lt;/p&gt;
&lt;p&gt;算法的实现非常清晰易懂。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;对于以上排序问题，我们首先需要明确问题之所在，然后利用待排序数字的特点，利用位图解决。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;正确的问题。真正写代码实现之前，需要仔细分析问题的特点，明确了问题，这场战役就成功了90%。&lt;/li&gt;
&lt;li&gt;位图数据结构。利用位图排序需要满足条件：输入数据限制在较小的范围内；数据没有重复；对于每条记录而言，除了单一整数之外，没有任何其他关联数据。&lt;/li&gt;
&lt;li&gt;简单的设计。简单的程序通常比具有相同功能复杂的程序更可靠、更安全、更健壮、更高效，而且更易于实现和维护。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/3227098/"&gt;编程珠玑&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 23 May 2015 12:32:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-23:zen-yang-gei-yi-ge-ci-pan-wen-jian-pai-xu.html</guid><category>读书笔记</category></item><item><title>LintCode Single Number I II III 落单的数</title><link>http://www.wengweitao.com/lintcode-single-number-i-ii-iii-luo-dan-de-shu.html</link><description>&lt;h2&gt;&lt;a href="http://www.lintcode.com/zh-cn/problem/single-number/"&gt;Single Number I&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;题目描述：&lt;/h3&gt;
&lt;p&gt;给出2*n + 1 个的数字，除其中一个数字之外其他每个数字均出现两次，找到这个数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;样例&lt;/strong&gt;
给出 [1,2,2,1,3,4,3]，返回 4&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;挑战&lt;/strong&gt;
一次遍历，常数级的额外空间复杂度&lt;/p&gt;
&lt;h3&gt;题目分析：&lt;/h3&gt;
&lt;p&gt;这道题利用了异或位运算的一个性质，即：一个数与自身异或的结果为0。我们只需遍历数组中的每一个元素，并将其进行异或。因为，异或满足交换律，所以最终的异或结果将仅仅包含只出现一次的那个数。&lt;/p&gt;
&lt;p&gt;如：1 ^ 2 ^ 2 ^ 1 ^3 ^ 4 ^ 3 = 1 ^ 1 ^ 2 ^ 2 ^ 3 ^ 3 ^ 4 = 4&lt;/p&gt;
&lt;h3&gt;参考代码：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * @param A: Array of integers.&lt;/span&gt;
&lt;span class="cm"&gt;     * return: The single number.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;singleNumber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间复杂度为O(n)，空间复杂度为O(1)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href="http://www.lintcode.com/zh-cn/problem/single-number-ii/"&gt;Single Number II&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;题目描述：&lt;/h3&gt;
&lt;p&gt;给出3*n + 1 个的数字，除其中一个数字之外其他每个数字均出现三次，找到这个数字。&lt;/p&gt;
&lt;p&gt;样例
给出 [1,1,2,3,3,3,2,2,4,1] ，返回 4&lt;/p&gt;
&lt;p&gt;挑战
一次遍历，常数级的额外空间复杂度&lt;/p&gt;
&lt;h3&gt;题目分析：&lt;/h3&gt;
&lt;p&gt;与Single Number I 类似，所不同的是这道题除了一个数字之外都出现3次，仍然考虑使用位操作，尝试消除掉出现3次的数字。&lt;/p&gt;
&lt;p&gt;若一个数字出现3次，则该数字的二进制表示中每个位置的数值为1的出现次数为3次，如：5的二进制表示为101，若5出现3次，则其二进制表示中的第一个位置和第二个位置出现1的次数和均为3。那么对该位1出现的次数对3取余，最终的结果所对应的就是所要求的Sing Number。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对int的32bit的各个位中1出现的次数，对数组中所有元素的逐个进行统计，然后对每个bit对3取余，最终的结果就是只出现一次的数字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路2：&lt;/strong&gt;
利用掩码的思想。&lt;/p&gt;
&lt;h3&gt;参考代码：&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;思路1对应代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * @param A : An integer array&lt;/span&gt;
&lt;span class="cm"&gt;     * @return : An integer &lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;singleNumberII&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;依次统计出32bit上每个位1出现的次数，分别保存在count变量中；&lt;/li&gt;
&lt;li&gt;从低位到高位，每次得到最终结果的一个位&lt;/li&gt;
&lt;li&gt;虽然有两层的循环，但是外层循环是常量，所以时间复杂度还是O(n)，空间复杂度为O(1)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;思路2对应代码&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * @param A : An integer array&lt;/span&gt;
&lt;span class="cm"&gt;     * @return : An integer &lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;singleNumberII&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;twice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;twice&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
            &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
            &lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;twice&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
            &lt;span class="n"&gt;once&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;third&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
            &lt;span class="n"&gt;twice&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;=&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;third&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;once&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;变量once作为一个掩码，若once的二进制表示中的一个位置为1，表示目前使该位为1的数只出现一次&lt;/li&gt;
&lt;li&gt;变量twice作为一个掩码，若twice的二进制表示中的一个位置为1，表示目前使该位置为1的数出现了2次&lt;/li&gt;
&lt;li&gt;变量third作为一个掩码，若third的二进制表示中的一个位置为1，表示目前使该位置为1的数出现了3次&lt;/li&gt;
&lt;li&gt;若之前出现一次（表示为once中对应的位为1），A[i]中又出现（表示为A[i]中对应的位置为1），那么twice中对应的位就为1；&lt;/li&gt;
&lt;li&gt;若之前的once中出现，而A[i]中又出现，那么就不是出现一次，将对应的位取0&lt;/li&gt;
&lt;li&gt;once中出现一次，twice出现两次，也就是出现了3次&lt;/li&gt;
&lt;li&gt;需要将once和twice中出现3次的位都置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的代码涉及到比较多的位运算，可能不大好理解。举个具体的例子：&lt;/p&gt;
&lt;p&gt;once： 100101 使第1、3、6个bit为1的数出现3次&lt;/p&gt;
&lt;p&gt;twice： 010101  使第1、3、5个bit为1的数出现了2次&lt;/p&gt;
&lt;p&gt;third： 000101  根据once和twice可以得到third，第1和3个bit为1的数出现了3次。&lt;/p&gt;
&lt;p&gt;以上算法的时间复杂度为O(n)，空间复杂度为O(1)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;&lt;a href="http://www.lintcode.com/zh-cn/problem/single-number-iii/"&gt;Single Number III&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;题目描述：&lt;/h3&gt;
&lt;p&gt;给出2*n + 2个的数字，除其中两个数字之外其他每个数字均出现两次，找到这两个数字。&lt;/p&gt;
&lt;p&gt;样例
给出 [1,2,2,3,4,4,5,3]，返回 1和5&lt;/p&gt;
&lt;p&gt;挑战
O(n)时间复杂度，O(1)的额外空间复杂度&lt;/p&gt;
&lt;h3&gt;题目分析：&lt;/h3&gt;
&lt;p&gt;与以上两题不同的是，这道题有两个数只出现一次。基本的思路还是利用位运算，除去出现次数为2次的数。&lt;/p&gt;
&lt;p&gt;如果对所有元素进行异或操作，最后剩余的结果是出现次数为1次的两个数的异或结果，此时无法直接得到这两个数具体的值。但是，因为这两个数一定是不同的，所以最终异或的值至少有一个位为1。我们可以找出异或结果中第一个值为1的位，然后根据该位的值是否为1，将数组中的每一个数，分成两个部分。这样每个部分，就可以采用Sing number I中的方法得到只出现一次的数。&lt;/p&gt;
&lt;h3&gt;参考代码：&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;public:&lt;/span&gt;
    &lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;     * @param A : An integer array&lt;/span&gt;
&lt;span class="cm"&gt;     * @return : Two integers&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;findFirstBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;isBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;singleNumberIII&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;indexOfBit1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;findFirstBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;isBit1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;indexOfBit1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;num1&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="n"&gt;num2&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间复杂度为O(n)，空间复杂度为O(1)。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 20 May 2015 21:15:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-20:lintcode-single-number-i-ii-iii-luo-dan-de-shu.html</guid><category>面试题</category></item><item><title>排序算法总结</title><link>http://www.wengweitao.com/pai-xu-suan-fa-zong-jie.html</link><description>&lt;p&gt;在前面的几篇文章中，分别介绍了几种最常见的算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/cha-ru-pai-xu.html"&gt;直接插入排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/mou-pao-pai-xu.html"&gt;冒泡排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/gui-bing-pai-xu.html"&gt;归并排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/dui-pai-xu.html"&gt;堆排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/kuai-su-pai-xu.html"&gt;快速排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/ji-shhtml"&gt;计数排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/ji-shu-pai-xu-radix-sort.html"&gt;基数排序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.wengweitao.com/tong-pai-xuww.wengweitao.com/ji-shu-pai-xu-radix-sort.html"&gt;桶排序&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将对这8种排序进行总结。&lt;/p&gt;
&lt;h2&gt;比较排序与非比较排序算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;比较排序算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;插入排序、冒泡排序、归并排序、堆排序和快速排序都是比较排序算法。它们都是通过对元素进行比较操作来确定输入数组的有序次序。使用决策树模型，可以证明任意比较排序算法排序n个元素的最坏运行时间的下界为&lt;span class="math"&gt;\(\Omega(nlogn)\)&lt;/span&gt;。归并排序和堆排序的最坏运行时间都为O(nlogn)都是渐近最优的比较算法。快速排序平均运行时间也为O(nlogn)，而且在实际应用中速度通常都比较快，是排序大数组最常用的算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非比较排序算法：&lt;/strong&gt;：
计数排序、基数排序和桶排序都是非比较排序算法。通过比较操作之外的方法来获得序列的有序次序的信息，就有可能打破&lt;span class="math"&gt;\(\Omega(nlogn)\)&lt;/span&gt;的时间下界。&lt;/p&gt;
&lt;h2&gt;从时间复杂度上看&lt;/h2&gt;
&lt;p&gt;直接插入排序、冒泡排序的平均情况下的时间复杂度都是&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，并且实现也比较简单。但是，插入排序和冒泡排序在最好情况下，时间复杂度可以达到O(n)。&lt;/p&gt;
&lt;p&gt;归并排序、堆排序和快速排序的平均情况下的时间复杂度都是O(nlogn)。归并排序基于分治的思想，由于其分割的子序列与初始序列的排列无关，它最好、最坏和平均时间复杂度均为O(nlogn)。堆排序利用堆的数据结构，可以在线性时间内完成建堆，每次调整堆只需要O(logn)，并且能够在O(nlogn)时间内完成排序。快速排序也是基于分治的思想，虽然最坏情况下的运行时间会达到&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，但快速排序平均性能可以达到O(nlogn)，在实际应用中通常优于其他排序算法。&lt;/p&gt;
&lt;p&gt;计数排序、基数排序和桶排序在输入服从一定条件下可以达到O(n)的时间复杂度。计数排序算法假定输入元素的值的范围为0~k之间，可以在O(k+n)的时间内将n个数排好序。基数排序扩展了计数排序的使用范围，对n个整数进行排序，每个元素有d位，并且每个数字的可能取值为0~k，那么基数排序可以在O(d(n+k))的时间内完成排序工作。桶排序算法，假设输入数据在[0,1)内服从均匀分布，平均情况运行时间为O(n)。&lt;/p&gt;
&lt;h2&gt;从空间复杂度上看&lt;/h2&gt;
&lt;p&gt;插入排序、冒泡排序和堆排序都仅需要常数个辅助空间，即时间复杂度为O(1)。&lt;/p&gt;
&lt;p&gt;快速排序虽然是原址排序，但是使用了递归调用。需要一个小的辅助栈，用来保存信息，最坏情况下，快速排序递归调用的次数是n-1，其空间复杂度为O(n)，在平均情况下快速排序的空间复杂度为O(logn)。&lt;/p&gt;
&lt;p&gt;归并排序每一次递归调用都要用到一个长度等于带排序列长度的辅助数组空间，所以空间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;计数排序和基数排序需要两个额外的数组用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)，其中k为每个元素最大的取值范围，n为元素的个数。&lt;/p&gt;
&lt;p&gt;桶排序需要m个桶，并且还需要存储n个待排的元素，所以桶排序的空间复杂度为O(m + n)。&lt;/p&gt;
&lt;h2&gt;从稳定性上看&lt;/h2&gt;
&lt;p&gt;插入排序、冒泡排序、归并排序、计数排序、基数排序和桶排序都是稳定的排序方法，而快速排序和堆排序都是不稳定的排序方法。&lt;/p&gt;
&lt;p&gt;下面用一个表格总结排序算法的性质。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;排序算法&lt;/th&gt;
&lt;th&gt;时间复杂度（最好、平均、最坏）&lt;/th&gt;
&lt;th&gt;空间复杂度&lt;/th&gt;
&lt;th align="left"&gt;是否稳定&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;冒泡排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;归并排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;堆排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;快速排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(logn)&lt;/td&gt;
&lt;td align="left"&gt;否&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;计数排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(k+n)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;基数排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(d(n+k))\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(d(n+k))\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(d(n+k))\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(k+n)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;桶排序&lt;/td&gt;
&lt;td&gt;&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;、&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;O(m + n)&lt;/td&gt;
&lt;td align="left"&gt;是&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 19 May 2015 20:35:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-19:pai-xu-suan-fa-zong-jie.html</guid><category>排序 算法 基础 总结</category></item><item><title>桶排序</title><link>http://www.wengweitao.com/tong-pai-xu.html</link><description>&lt;p&gt;本文继续介绍一种非比较排序算法——&lt;strong&gt;桶排序（bucket sort）&lt;/strong&gt;。通排序假设输入数据服从均匀分布，平均情况下它的时间复杂度为O(n)。与计数排序类似，因为对输入数据作了某种假设，桶排序的速度也很快。具体的，计数排序假设输入数据都属于一个小区间的整数，而桶排序则假设输入数据是由一个随机过程产生，该过程将元素均匀、独立地分布在[0,1)区间上。&lt;/p&gt;
&lt;h2&gt;桶排序的基本思想&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;桶排序将[0,1)区间划分成大小相同的n个子区间，称为桶&lt;/li&gt;
&lt;li&gt;将n个输入分别放入各个桶中&lt;/li&gt;
&lt;li&gt;对桶中的数进行排序&lt;/li&gt;
&lt;li&gt;遍历每个桶，按照次序把各个桶中的元素列出来&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;桶排序的代码实现&lt;/h2&gt;
&lt;p&gt;在桶排序的代码中，我们假设输入是一个包含n个元素的数组A，且每个元素A[i]满足&lt;span class="math"&gt;\(0 \leq A[i] &amp;lt; 1\)&lt;/span&gt;。此外，算法还需要一个临时数组B[0..n-1]来存放链表（即桶），并假设存在一种用于维护这些链表的机制。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;double&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bucketSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cur_index&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="c1"&gt;//cout &amp;lt;&amp;lt; cur_index &amp;lt;&amp;lt; &amp;#39; &amp;#39; &amp;lt;&amp;lt; A[i]&amp;lt;&amp;lt; endl;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;insertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;         
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;待排序列A中的每个元素都分布在区间[0,1)之间；&lt;/li&gt;
&lt;li&gt;利用 (int)(A[i] * 10 ) 得出将A[i]分配到哪个链表（桶）中；&lt;/li&gt;
&lt;li&gt;这里将桶的个数设置为n（可以设置为其他有限数量的桶）；&lt;/li&gt;
&lt;li&gt;利用插入排序对，每个链表的内部进行排序；&lt;/li&gt;
&lt;li&gt;最后将各个桶对应的链表都联结起来，就是最终的排序序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;桶排序的复杂度&lt;/h2&gt;
&lt;p&gt;从以上的代码可以看出，在最坏情况下，除了桶内使用插入排序外，其余步骤的时间代价都是O(n)。可以证明，桶排序在平均情况下的运行时间为：
&lt;/p&gt;
&lt;div class="math"&gt;$$O(n) + n.O(2-\frac{1}{n}) = O(n)$$&lt;/div&gt;
&lt;p&gt;桶排序需要m个桶，并且还需要存储n个待排的元素，所以桶排序的空间复杂度为O(m + n)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 18 May 2015 16:13:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-18:tong-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>基数排序（radix sort）</title><link>http://www.wengweitao.com/ji-shu-pai-xu-radix-sort.html</link><description>&lt;p&gt;本文继续介绍另外一种非比较排序算法——&lt;strong&gt;基数排序（radix sort）&lt;/strong&gt;，最早用在卡片排序机上。基数排序的原理是将整数按位切割成不同的数字，然后按每个位数分别比较。对于十进制的数字，每列只会用到10个位置，一个d位数将占用d列。&lt;/p&gt;
&lt;p&gt;基数排序&lt;strong&gt;先按最低有效位进行排序&lt;/strong&gt;，然后按次低有效位进行排序，直到对所有的d位数字都进行了排序。为了确保基数排序的正确性，&lt;strong&gt;一位数的排序算法必须是稳定的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们有时会用基数排序来对具有多关键字域的记录进行排序。例如，我们希望用3个关键字（年、月、日）来对日期进行排序。我们可以使用基于特殊比较函数的排序算法，先比较年，如果相同再比较月，如果还相同再比较日。我们也可以采用基数排序，用一种稳定排序算法对这些信息进行三次排序：先日，再月，最后年。&lt;/p&gt;
&lt;h2&gt;基数排序的实现&lt;/h2&gt;
&lt;p&gt;基数排序的代码实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 每个位的数值大小为从0~9&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;countingSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_base&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;base&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 每个元素的当前排序位数所对应的值进行统计&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cur_base&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cur_num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cur_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;cur_base&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cur_num&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;cur_num&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;                                                                                                                                                                                     
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="c1"&gt;// 将B中的元素复制到A中&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;radixSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// 数组A的个数&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;countingSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;A是待排序的数组；d是A中待排序元素的位数；k是10表示0~9个数字&lt;/li&gt;
&lt;li&gt;对每一位的排序，调用计数排序（计数排序是稳定的）&lt;/li&gt;
&lt;li&gt;需要将原始的计数排序进行修改，使之只对1位数进行排序&lt;/li&gt;
&lt;li&gt;cur_num = A[i] / cur_base % 10 得到A[i]元素对应的第j位的数值&lt;/li&gt;
&lt;li&gt;对每一位的排序结束后，需要把已排序的数组复制给A&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基数排序的复杂度&lt;/h2&gt;
&lt;p&gt;给定n个d位数，其中每一个数位有k个可能的取值。如果RADIX-SORT使用的稳定排序方法耗时O(n+k)，那么它就可以在O(d(n+k))时间内将这些数排好序。当d为常数且k=O(n)时，级数排序具有线性的时间代价。&lt;/p&gt;
&lt;p&gt;另外，可以证明：给定一个b位数和任何正整数&lt;span class="math"&gt;\(r \leq b\)&lt;/span&gt;，如果RADIX-SORT使用的稳定排序算法对数据取值区间是0到k的输入进行排序耗时O(n+k)，那么它就可以在&lt;span class="math"&gt;\(O(
\frac{b}{r}(n+2^r)\)&lt;/span&gt;)时间内将这些数排好序。&lt;/p&gt;
&lt;p&gt;因为调用了计数排序，所以空间复杂度与计数排序一样都是O(k+n)。&lt;/p&gt;
&lt;h2&gt;基数排序与快速排序的比较&lt;/h2&gt;
&lt;p&gt;基数排序是否比基于比较的排序算法（如快速排序）更好呢？虽然基数排序的运行时间O(n)，看上去要比快速排序的期望运行时间O(nlogn)更好一些。但是这两个表达式中隐含的常数因子是不同的。虽然基数排序执行循环的轮数会比快速排序要少，但每一轮它所耗费的时间要长得多。&lt;/p&gt;
&lt;p&gt;此外，利用计数排序的基数排序不是原址排序，当主存容量比较有限时，我们可能会更倾向于像快速排序那样的原址排序算法。&lt;/p&gt;
&lt;p&gt;选择哪一个排序算法依赖于具体实现和底层硬件的特性（如快速排序通常比基数排序更有效地利用硬件的缓存）以及输入数据的特征。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 17 May 2015 14:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-17:ji-shu-pai-xu-radix-sort.html</guid><category>排序 算法 基础</category></item><item><title>计数排序</title><link>http://www.wengweitao.com/ji-shu-pai-xu.html</link><description>&lt;p&gt;之前介绍的都是基于比较的排序算法，对于包含n个元素的输入序列来说，任何比较排序在最坏情况下都要经过O(nlogn)次比较。本文将介绍第一种非比较排序算法——&lt;strong&gt;计数排序&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;计数排序的基本思想&lt;/h2&gt;
&lt;p&gt;计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，计数排序的运算时间为O(n)。&lt;/p&gt;
&lt;p&gt;基本思想：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于每一个输入元素x，确定小于x的输入元素的个数&lt;/li&gt;
&lt;li&gt;根据这一信息将x放到它在输出数组中的位置上&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计数排序的代码实现&lt;/h2&gt;
&lt;p&gt;在计数排序算法的代码中，假设输入是一个数组A[1...n]，A.length = n。我们还需要两个数组：B[1..n]存放排序的输出，C[0..k]提供临时存储空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// B: output of the sorted array&lt;/span&gt;
&lt;span class="c1"&gt;// k: every element in A: 0 &amp;lt;= A[i] &amp;lt;= k&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;countingSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// let C[0..k] be a new array for counting&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;  &lt;span class="c1"&gt;// C[i] contains the number of elements equal to i&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  &lt;span class="c1"&gt;// C[i] contains the number of elements less than or equal to i&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;建立一个初始元素都为0的数组C，用来存储0~k范围内数字出现的个数；&lt;/li&gt;
&lt;li&gt;统计出每个元素出现的次数保存在数组C中；&lt;/li&gt;
&lt;li&gt;依次统计出C[i]表示数组中小于等于i的元素出现的个数；&lt;/li&gt;
&lt;li&gt;从带排序列A的最后一个元素开始，将A[i]放到正确的位置（从后往前保证了排序的稳定性）。即前面又几个元素小于等于它，它就放在第几个位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计数排序的复杂度&lt;/h2&gt;
&lt;p&gt;由计数排序的代码实现可以看出，计数排序总的时间代价为O(k+n)。在实际工作中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为O(n)。&lt;/p&gt;
&lt;p&gt;计数排序需要两个额外的数组用来对元素进行计数和保存排序的输出结果，所以空间复杂度为O(k+n)。&lt;/p&gt;
&lt;h2&gt;计数排序是稳定的&lt;/h2&gt;
&lt;p&gt;计数排序的一个重要性质是它是稳定的：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的。也就是说，对两个相同的数来说，在输入数组中先出现的数，在输出数组中也位于前面。&lt;/p&gt;
&lt;p&gt;计数排序的稳定性很重要的一个原因是：计数排序经常会被用于基数排序算法的一个子过程。我们将在下一篇文章中介绍，为了使基数排序能够正确运行，计数排序必须是稳定的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 17 May 2015 11:21:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-17:ji-shu-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>快速排序</title><link>http://www.wengweitao.com/kuai-su-pai-xu.html</link><description>&lt;p&gt;本文介绍的是实际排序应用中最常用的一种排序算法——&lt;strong&gt;快速排序&lt;/strong&gt;。快速排序虽然在最坏情况下时间复杂度为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，但是它的平均性能非常好，它的期望运行时间是O(nlogn)，而且O(nlogn)所隐含的常数因子非常小。另外，它还能够进行原址排序。&lt;/p&gt;
&lt;h2&gt;快速排序描述&lt;/h2&gt;
&lt;p&gt;与归并排序一样，快速排序也使用了分治的思想。下面是对一个数组A[p..r]进行快速排序的三步分治过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分解：数组A[p..r]被划分成两个子数组A[p..q-1]和A[q+1..r]，使得A[p..q-1]中的每一个元素都小于等于A[q]，A[q+1..r]中的每个元素都大于等于A[q]；&lt;/li&gt;
&lt;li&gt;解决：通过递归调用快速排序，对两个子数组A[p..q-1]和A[q+1..r]进行排序；&lt;/li&gt;
&lt;li&gt;合并：因为子数组是原址排序的，所以不需要合并操作，数组A[p..r]已经有序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;快速排序的关键部分是&lt;strong&gt;对数组的划分PARTITION过程&lt;/strong&gt;，它总是选择一个x=A[r]作为主元（pivot element），并围绕它将数组划分成两个部分，然后返回主元的下标。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;容易看出PARTITION过程的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;下面的程序实现快速排序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了排序一个数组A的全部元素，初始调用quickSort(A, start, end)。&lt;/p&gt;
&lt;h2&gt;快速排序的性能&lt;/h2&gt;
&lt;p&gt;快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于划分的元素。如果划分是平衡的，那么快速排序算法的性能与归并排序一样都是O(nlogn)，如果划分是不平衡的，那么快速排序的性能就接近于插入排序了。&lt;/p&gt;
&lt;h3&gt;最坏情况划分&lt;/h3&gt;
&lt;p&gt;当划分产生了两个子问题分别包含n-1个元素和0个元素时，快速排序的最坏情况发生。如果在算法的每一层递归上，划分都是最大程度的不平衡，那么算法时间复杂度为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。此外，当数组完全有序的时候，快速排序的复杂度为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，而同样情况下插入排序的时间复杂度为O(n)。&lt;/p&gt;
&lt;h3&gt;最好情况划分&lt;/h3&gt;
&lt;p&gt;在可能的最平衡划分中，PARTITION得到的两个子问题的规模都不大于n/2.通过在每一层递归中都平衡划分子数组，我们得到了渐近时间上更快的算法，时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;h3&gt;平衡的划分&lt;/h3&gt;
&lt;p&gt;快速排序的实际运行时间更接近于其最好的情况，而非最坏的情况。例如，假设划分算法总是产生9:1的划分，直观上非常不平衡，但快速排序的运行时间还是O(nlogn)，与恰好在中间划分的渐近运行时间是一样的。实际上，即使是99:1的划分，其时间复杂度仍然是O(nlogn)。即，&lt;strong&gt;只要是常数比例的划分，算法运行时间都是O(nlogn).&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，当好和差的划分交替出现时，快速排序的时间复杂度与全是好的划分是一样的，仍然是O(nlogn)。&lt;/p&gt;
&lt;h2&gt;快速排序的随机化版本&lt;/h2&gt;
&lt;p&gt;我们可以通过在算法中引入随机性，从而使得算法对于所有的输入都能获得期望的较好的性能。与始终采用A[r]作为主元的方法不同，随机抽样是&lt;strong&gt;从子数组中随机选择一个元素作为主元&lt;/strong&gt;。因为主元素是随机选取的，我们期望在平均情况下，对输入数组的划分是比较均衡的。&lt;/p&gt;
&lt;p&gt;以下是随机化的快速排序的完整代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;iostream&amp;gt;                                                                                                                                                                                       &lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;vector&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;ctime&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;cstdlib&amp;gt;&lt;/span&gt;
&lt;span class="k"&gt;using&lt;/span&gt; &lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;quickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;randomInRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;srand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rand_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rand_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;randomizedPartition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;randomInRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt; &lt;span class="c1"&gt;// 将主元放在数组的最后一个位置&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;randomizedQuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;randomizedPartition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;randomizedQuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;randomizedQuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;randomizedQuickSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;快速排序复杂度总结&lt;/h2&gt;
&lt;h3&gt;最坏情况&lt;/h3&gt;
&lt;p&gt;快速排序最坏情况下运行时间是&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;期望运行时间&lt;/h3&gt;
&lt;p&gt;使用RANDOMIZED-PARTION，在输入元素互异的情况下，快速排序的期望运行时间是&lt;span class="math"&gt;\(O(nlogn)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;空间复杂度&lt;/h3&gt;
&lt;p&gt;快速排序虽然是原址排序，但是使用了递归调用。所以，快速排序的空间复杂度主要是由递归造成的栈空间的使用，每一次递归调用需要额外的常数空间来进行存储信息。最坏情况下，快速排序递归调用的次数是n-1，其空间复杂度为O(n)；在最好情况下，快速排序递归调用的次数是logn次，其空间复杂度为O(logn)；在平均情况下快速排序的空间复杂度也为O(logn)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 16 May 2015 10:22:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-16:kuai-su-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>归并排序</title><link>http://www.wengweitao.com/gui-bing-pai-xu.html</link><description>&lt;p&gt;本文介绍利用分治法思想的一种排序算法——&lt;strong&gt;归并排序&lt;/strong&gt;。直观上其操作如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分解&lt;/strong&gt;：分解待排序的n个元素的序列成2个具有n/2个元素的子序列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决&lt;/strong&gt;：使用归并排序递归地排序两个子序列&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合并&lt;/strong&gt;：合并两个已排序的子序列并产生已排序的答案&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当待排序的序列的长度为1时，递归“开始回升”，在这种情况下，我们不需要做任何工作，因为只有一个元素的序列已经是有序的了。&lt;/p&gt;
&lt;h2&gt;合并操作&lt;/h2&gt;
&lt;p&gt;归并排序算法的关键操作是“合并”步骤中将两个已排序的子序列进行合并。我们通过函数MERGE(A, p, q, r)来完成合并，其中A是一个数组，p、q和r是数组下标，该过程假设A[p..q]和A[q+1..r]都已有序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 对A[p..q] 和 A[q+1..r]两个有序子序列进行合并&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 

    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; 
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; 

    &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INT_MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;INT_MAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MERGE的详细过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;求解两个子序列的长度n1和n2；&lt;/li&gt;
&lt;li&gt;创建两个新的长度分别为n1 + 1和n2 + 1的数组，分别将两个子序列复制进去，其中每个数组的最后一个位置用来保存哨兵&lt;sup id="fnref:sb"&gt;&lt;a class="footnote-ref" href="#fn:sb" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;依次比较两个子序列中的两个元素，将较小的放入A中，执行 r - p + 1次。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;归并排序实现&lt;/h2&gt;
&lt;p&gt;下面就可以利用MERGE过程写出归并排序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 排序A[p..r]中的元素&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;mergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;mergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;mergeSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;merge&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;q&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若 &lt;span class="math"&gt;\(p \geq r\)&lt;/span&gt;那么数组中只有一个元素，此时已经有序；若&lt;span class="math"&gt;\(p &amp;lt; q\)&lt;/span&gt;那么就将数组分为两个子数组A[p..q]和A[q+1..r]两个子数组。归并排序随着算法自底向上推进，待合并的已排序的各序列的长度不断增加，直到两个长度为n/2的子序列被合并最终形成长度为n的有序序列。&lt;/p&gt;
&lt;h2&gt;归并排序算法复杂度分析&lt;/h2&gt;
&lt;h3&gt;时间复杂度&lt;/h3&gt;
&lt;p&gt;当一个算法包含对其自身的递归调用，我们往往可以用递归方程或递归式来描述其运行时间。对于分治算法，假设我们把原问题分解为a个子问题，每个子问题的规模是原来的1/b，所以我们需要aT(n/b)的时间来求解a个子问题。如果将问题分解为子问题需要的时间为D(n)，合并子问题的解成原问题所需要的时间为C(n)，那么可以得到递推式：
&lt;/p&gt;
&lt;div class="math"&gt;$$T(n)=\left\{\begin{matrix}
\Theta(1) &amp;amp; 若n \leq c\\ 
aT(n/b) + D(n) + C(n) &amp;amp; 其他 
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;对于归并排序，a = 2, b = 2，分解子问题时间复杂度为O(1)，合并子问题时间复杂度为O(n)，所以归并排序最坏情况运行时间T(n)的递归式为：
&lt;/p&gt;
&lt;div class="math"&gt;$$T(n)=\left\{\begin{matrix}
\Theta(1) &amp;amp; 若n = 1\\ 
2T(n/2) + \Theta(n)  &amp;amp; 若n &amp;gt; 1
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;由主定理可以求得归并排序的时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;h3&gt;空间复杂度&lt;/h3&gt;
&lt;p&gt;由归并排序的代码可以看出，归并排序每一次递归调用都要用到一个长度等于带排序列长度的辅助数组空间。虽然总的递归次数是O(logn)，但每次递归调用都释放掉之前所占的辅助空间，所以归并排序的空间复杂度是O(n)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:sb"&gt;
&lt;p&gt;哨兵的作用是避免每个基本步骤都需要检查是否有数组为空。这里将哨兵设置为无穷大，这样即使一个数组的所有元素都已检查完毕，另外一个数组的元素肯定小于哨兵，会直接输入到数组A中。当直线完 r - p + 1个基本步骤之后，算法就可以停止了。&amp;#160;&lt;a class="footnote-backref" href="#fnref:sb" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 15 May 2015 19:45:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-15:gui-bing-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>堆排序</title><link>http://www.wengweitao.com/dui-pai-xu.html</link><description>&lt;p&gt;本文将介绍一种排序算法，称为&lt;strong&gt;堆排序（heapsort）&lt;/strong&gt;。堆排序最坏情况下运行时间为O(nlogn)，并且具有空间原址性：任何时候只需要常数个额外的元素空间存储临时数据。堆排序中使用了堆这个数据结构进行管理，堆这种数据结构也可以用来构造一种 有效的优先级队列。&lt;/p&gt;
&lt;h2&gt;堆&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;堆&lt;/strong&gt;（二叉堆）是一个数组，可以看成一个近似的完全二叉树，树中每一个结点对应数组中的一个元素，除了最底层外，该树是完全满的，而且是从左至右填充。二叉堆有两种形式：最大堆和最小堆。在最大堆中，除了根结点之外的所有结点的值小于等于其父节点的值，因此，堆中最大的元素存放在根结点中，并且在任一子树中，该子树所包含的所有结点的值都不大于该子树根结点的值。最小堆的组织方式正好相反。&lt;/p&gt;
&lt;p&gt;在堆排序算法中，我们使用最大堆，而最小堆通常用于构造优先级队列。&lt;/p&gt;
&lt;p&gt;如果把堆看成一棵树，那么堆的高度就是O(logn)。我们会发现在堆上进行的很多基本操作的运行时间至多与树的高度成正比，即时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;p&gt;表示堆的数组A包括的基本属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A.length() ： 返回数组元素的个数&lt;/li&gt;
&lt;li&gt;A.heap-size()：返回有多少个堆元素存放在该数组中（通常小于等于length）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于数组A[1..A.length]，树的根结点为A&lt;a href="http://book.douban.com/subject/1885170/"&gt;1&lt;/a&gt;，给定一个结点的下标i，我们可以很容易得到其父节点、左孩子和右孩子结点的下标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点： i/2&lt;/li&gt;
&lt;li&gt;左孩子： 2 * i&lt;/li&gt;
&lt;li&gt;右孩子： 2 * i + 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;堆结构上的一些基本操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MAX-HEAPIFY：用于维护最大堆的性质，时间复杂度为O(logn)。&lt;/li&gt;
&lt;li&gt;BUILD-MAX-HEAP：用于把无序的输入数据数组构造为一个最大堆，时间复杂度为O(n)。&lt;/li&gt;
&lt;li&gt;HEAPSORT：对一个数组进行原址排序，时间复杂度为O(nlogn)。&lt;/li&gt;
&lt;li&gt;MAX-HEAP-INSERT、HEAP-EXTRACT-MAX、HEAP-INCREASE-KEY和HEAP-MAXIMUM：利用这些操作可以实现一个优先队列，时间复杂度为O(nlogn)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;维护堆的性质&lt;/h2&gt;
&lt;p&gt;MAX-HEAPIFY 是用于维护最大堆性质的一个重要的过程。它的输入为一个数组A和一个下标i，并且假定此时根结点为LEFT(i)和RIGHT(i)的二叉树都是最大堆，通过让A[i]的值在最大堆中逐级下降，从而使得以下标i为根结点的二叉树满足最大堆的性质。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 根结点的下标为0&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;MAX-HEAPIFY 的时间代价包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调整A[i]与A[LEFT(i)]和A[RIGHT(i)]的时间代价&lt;span class="math"&gt;\(\Theta(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;以i为根结点的子树上运行MAX-HEAPIFY的时间代价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为每个孩子的子树的大小至多为2n/3，即其中一边的子树的最后一层全满，另外一边的子树全空的情况。假设结点i为根结点的树高为h，且左子树最后一层全满，右子树最后一层全空，那么结点i的左子树的结点数目l为&lt;span class="math"&gt;\(2^{h-1}-1\)&lt;/span&gt;，右子树的结点数目r为&lt;span class="math"&gt;\(2^{h-2}-1\)&lt;/span&gt;，树的结点总数为n = l + r + 1，那么&lt;span class="math"&gt;\(\frac{l}{n}=\frac{2^{h-1}-1}{2^{h-2}-1} \leq \frac{2}{3}\)&lt;/span&gt;。所以，我们可以用以下递归式刻画MAX-HEAPIFY的运行时间：
&lt;/p&gt;
&lt;div class="math"&gt;$$T(n) \leq T(2n/3) + \Theta(1)$$&lt;/div&gt;
&lt;p&gt;
根据主定理，上面递归式的解为T(n)=O(logn)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，MAX-HEAPIFY的时间复杂度为O(h)，其中h为树的高度。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;建堆&lt;/h2&gt;
&lt;p&gt;当用数组表示存储n个元素的堆时，叶结点的下标为n/2+1,...,n，而下标小于等于n/2的都是分支结点（下标从1开始）。对于每一个叶结点可以把它们看出只有一个元素的堆，因此建堆的过程就是对树中每一个分支结点调用MAX-HEAPIFY。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;buildMaxHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;每次调用MAX-HEAPIFY的时间复杂度为O(logn)，需要O(n)次调用，所以总的时间复杂度为O(nlogn)，但这不是渐近紧确的。我们可以进一步得到一个更紧确的界。因为不同结点运行MAX-HEAPIFY的时间复杂度与其高度相关，而且大部分结点的高度都比较小。可以得到，建堆BUILD-MAX-HEAP的时间复杂度为O(n)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，我们可以在线性时间内把一个无序数组构造成为一个最大堆。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;堆排序算法&lt;/h2&gt;
&lt;p&gt;现在，我们可以完成堆排序算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用BUILD-MAX-HEAP将输入数组A[1..n]建成一个最大堆，其中n = A.length&lt;/li&gt;
&lt;li&gt;将数组最大元素所在的A&lt;a href="http://book.douban.com/subject/1885170/"&gt;1&lt;/a&gt;位置的值与A[n]位置的值进行交换，然后从堆中去掉结点n&lt;/li&gt;
&lt;li&gt;在新的根结点1可能会违背最大堆的性质，因此需要利用MAX-HEAPIFY进行调整&lt;/li&gt;
&lt;li&gt;不断重复2,3步，直到堆中只剩下一个元素，此时排序完成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;堆排序的完整代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                                                                                                                                                                      
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;buildMaxHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heapSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;buildMaxHeap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;heap_length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出，堆排序的时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;h2&gt;优先队列&lt;/h2&gt;
&lt;p&gt;堆除了能够运用在排序中，还常用用于实现一个高效的优先队列。和堆一样，优先队列也分为：最大优先队列和最小优先队列。&lt;/p&gt;
&lt;p&gt;最大优先队列可以用于在共享计算机系统的作业调度，每次选取一个优先级最高的作业进行调度。而最小优先队列可以用于基于事件驱动的模拟器，每个时间都有一个时间作为关键字，事件必须按照时间的顺序进行模拟，每次选取一个“优先级”最低的事件作为下一个要模拟的事件。&lt;/p&gt;
&lt;p&gt;这里，我们关注于使用最大堆实现最大优先队列。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;heapMaximum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;heapExtracMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// heap underflow&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;maxHeapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heapIncreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// new key should not be smaller than current key&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;maxHeapInsert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INT_MIN&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;heapIncreaseKey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;heap_size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个最大优先级队列支持以下次操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;heapMaximum：返回优先级队列中优先级最高的元素；&lt;/li&gt;
&lt;li&gt;heapExtracMax：取出并返回具有最大优先级的元素；&lt;/li&gt;
&lt;li&gt;heapIncreaseKey：将结点i的优先级增加到key；&lt;/li&gt;
&lt;li&gt;maxHeapInsert： 往优先级队列中增加一个元素x；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在一个包含n个元素的堆中，所有优先队列的操作都可以在O(logn)时间内完成。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 14 May 2015 22:23:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-14:dui-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>插入排序</title><link>http://www.wengweitao.com/cha-ru-pai-xu.html</link><description>&lt;p&gt;本文介绍一种非常简单的排序算法——&lt;strong&gt;插入排序&lt;/strong&gt;。对于少量元素的排序，它是一个有效的算法。插入排序可以形象的类比为手中扑克牌的排序。开始时，左手为空并且桌子上的扑克牌的牌面朝下。然后我们每次从桌子上拿一张扑克牌，插入左手中正确的位置，我们从右向左将它与手中的每张牌进行比较，任何时候左手上的牌总是有序的。&lt;/p&gt;
&lt;p&gt;对数组A[1..n]进行插入排序步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始时只含有一个元素A&lt;a href="http://book.douban.com/subject/1885170/"&gt;1&lt;/a&gt;，所以是有序的&lt;/li&gt;
&lt;li&gt;依次将A[2]~A[n]依次插入到前面已经排好序的子序列中&lt;/li&gt;
&lt;li&gt;n - 1次即可得到一个有序的表&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;insertionSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="c1"&gt;// Insert A[j] into the sorted sequence A[1..j-1]&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出插入排序是原址排序的算法空间复杂度为O(1)，时间复杂度为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。最好的情况下，数组中所有的元素都是有序的，每一步只需要一次比较，不需要移动，最好情况的时间复杂度为O(n)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 13 May 2015 18:34:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-13:cha-ru-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>冒泡排序</title><link>http://www.wengweitao.com/mou-pao-pai-xu.html</link><description>&lt;p&gt;冒泡排序算法比较简单，假设待排序列的长度为n，其思想是：&lt;/p&gt;
&lt;p&gt;从后往前（或者从前往后）两两比较相邻元素的值，若为逆序（即前一个大于后一个），则交换它们，直到序列比较完，我们称进行了一趟冒泡排序，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡排序，第一个元素不再参与比较，待排序列的个数减少1，每趟冒泡排序的结果把子序列中最小元素放到了最终的位置。关键字如同气泡一般逐渐往上漂浮至水面，这就是冒泡排序名字的由来。最多n-1趟就能把所有元素排好序。&lt;/p&gt;
&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;bubbleSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 表示本趟冒泡是否发生了交换的标志&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//本趟冒泡没有发生元素的交换，说明此时序列已经有序了&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;冒泡排序最坏和平均时间复杂度均为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。
空间复杂度为O(1)。
并且，冒泡排序是稳定的排序方法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/1885170/"&gt;算法导论&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 13 May 2015 16:13:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-13:mou-pao-pai-xu.html</guid><category>排序 算法 基础</category></item><item><title>CentOS 升级 gcc 和 g++ 的方法</title><link>http://www.wengweitao.com/centos-sheng-ji-gcc-he-g-de-fang-fa.html</link><description>&lt;p&gt;CentOS 系统自带的 gcc 或者 g++ 的版本是：g++ (GCC) 4.4.6. GCC 版本太旧，导致了很多使用上的不便，如：无法使用g++ -std=c++11 命令来编译 C++11、无法使用Vim的很多插件（YouCompleteMe等）。因此，有必要对它进行升级。&lt;/p&gt;
&lt;p&gt;对 GCC 升级无法直接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;yum update gcc
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以下是升级的详细过程。&lt;/p&gt;
&lt;h3&gt;1.使用 redhat developer toolset 1.1 的repo，安装GCC&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /etc/yum.repos.d

wget http://people.centos.org/tru/devtools-1.1/devtools-1.1.repo 

yum --enablerepo&lt;span class="o"&gt;=&lt;/span&gt;testing-1.1-devtools-6 install devtoolset-1.1-gcc devtoolset-1.1-gcc-c++
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 替换系统中原来的GCC&lt;/h3&gt;
&lt;p&gt;通过通过第一步会把 GCC 安装到以下目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;/opt/centos/devtoolset-1.1/root/usr/bin/
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来需要修改系统的配置，使默认的 gcc 和 g++ 命令使用的是新安装的版本。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;ln -s /opt/centos/devtoolset-1.1/root/usr/bin/* /usr/local/bin/
&lt;span class="nb"&gt;hash&lt;/span&gt; -r
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在查看 g++ 的版本号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;g++ --version
g++ &lt;span class="o"&gt;(&lt;/span&gt;GCC&lt;span class="o"&gt;)&lt;/span&gt; 4.7.2 20121015 &lt;span class="o"&gt;(&lt;/span&gt;Red Hat 4.7.2-5&lt;span class="o"&gt;)&lt;/span&gt;
Copyright &lt;span class="o"&gt;(&lt;/span&gt;C&lt;span class="o"&gt;)&lt;/span&gt; 2012 Free Software Foundation, Inc.
This is free software; see the &lt;span class="nb"&gt;source &lt;/span&gt;&lt;span class="k"&gt;for &lt;/span&gt;copying conditions.  There is NO
warranty; not even &lt;span class="k"&gt;for &lt;/span&gt;MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;已经从4.4.6升级到4.7.2了。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;http://superuser.com/questions/381160/how-to-install-gcc-4-7-x-4-8-x-on-centos/542091#542091&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 12 May 2015 19:02:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-12:centos-sheng-ji-gcc-he-g-de-fang-fa.html</guid><category>教程、Linux</category></item><item><title>终端窗口管理神器——tmux</title><link>http://www.wengweitao.com/zhong-duan-chuang-kou-guan-li-shen-qi-tmux.html</link><description>&lt;h2&gt;什么是tmux&lt;/h2&gt;
&lt;p&gt;tmux是一个终端的复用器（terminal multiplexer），可以简单理解为一个终端的窗口管理程序。相比系统自带的 screen 功能要强大许多。其使用场景和特性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当你使用SSH连接到服务器的时候，由于网络掉线导致连接中断（这是经常发生的。。。）。当你重新连接后，所有的工作现场丢失了。你还得重新打开之前的各种窗口，进入各种很深的目录，非常麻烦。而如果使用tmux，即时掉线之后，重新连接也能直接回到之前的工作环境，极大提高工作的效率。&lt;/li&gt;
&lt;li&gt;可以完全通过键盘操控&lt;/li&gt;
&lt;li&gt;支持自定义的按键绑定模式，例如设置成vim按键绑定模式&lt;/li&gt;
&lt;li&gt;可以在一个SSH连接下打开多个会话、窗口，也可以对窗口进行各种分割，效果如下图所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="tmux示例" src="http://tmux.sourceforge.net/tmux4.png" /&gt;&lt;/p&gt;
&lt;h2&gt;tmux的基本概念&lt;/h2&gt;
&lt;p&gt;首先，需要先安装tmux：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo yum install tmux
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;安装好后，直接输入 &lt;strong&gt;tmux&lt;/strong&gt; 即可运行 tmux. &lt;/p&gt;
&lt;p&gt;tmux 包括以下3个基本概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;session：&lt;/strong&gt;会话，是一组窗口的集合，通常同一个任务可以放入一个session。可以同时打开多个session，每个session可以有自己的名字方便任务的切换。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;window：&lt;/strong&gt;窗口，一个会话包含多个窗口，类似于一个tab，各个window也可以有自己的编号。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;panel：&lt;/strong&gt;面板，一个窗口包含多个面板，就是窗口中不同的小块窗口。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="session" src="http://cenalulu.github.io/images/linux/tmux/concept.jpg" /&gt;
&lt;em&gt;&lt;a href="http://cenalulu.github.io/images/linux/tmux/concept.jpg"&gt;图片来源&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;session会在tmux窗口的左下角显示，window会以tab形式显示在其后，并且会以当前活动的程序自动命名。以上图为例，这是第3个session，一共有3个window，分别是vim, bash, ssh。而panel就是用格子分割开的各个区块。&lt;/p&gt;
&lt;h2&gt;tmux的基本用法&lt;/h2&gt;
&lt;p&gt;tmux 指令必须包含一个前缀（就是一组按键），你必须先按下前缀以后，系统才知道你后面的命令是tmux指令。系统默认的前缀指令是 &lt;strong&gt;ctrl + b&lt;/strong&gt;，例如你要新建一个窗口就先按下：&lt;strong&gt;ctrl + b&lt;/strong&gt;，然后再按：&lt;strong&gt;c&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是几组常用的tmux指令（所有的前缀用prefix代替）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prefix + ? ： 帮助，可以查看所有的tmux指令，使用q退出&lt;/li&gt;
&lt;li&gt;prefix + s： 列出所有session编号,并进行选择切换&lt;/li&gt;
&lt;li&gt;prefix + d： 离开当前session&lt;/li&gt;
&lt;li&gt;prefix + $： 重命名当前session&lt;/li&gt;
&lt;li&gt;prefix  + c：新建一个窗口&lt;/li&gt;
&lt;li&gt;prefix  + &amp;amp;： 关闭当前窗口&lt;/li&gt;
&lt;li&gt;prefix + n： 切换到下一个窗口&lt;/li&gt;
&lt;li&gt;prefix + w：列出所有窗口编号,并进行选择切换&lt;/li&gt;
&lt;li&gt;prefix + 窗口号： 切换到某个窗口&lt;/li&gt;
&lt;li&gt;prefix + "： 垂直拆分出一个panel&lt;/li&gt;
&lt;li&gt;prefix + %： 水平拆分出一个panel&lt;/li&gt;
&lt;li&gt;prefix + o： 切换到下一个panel&lt;/li&gt;
&lt;li&gt;prefix + !： 关闭所有的panel&lt;/li&gt;
&lt;li&gt;prefix + x： 关闭当前panel&lt;/li&gt;
&lt;li&gt;prefix + z： 暂时将当前的panel放到最大&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多的tmux指令，可以参考&lt;a href="http://www.openbsd.org/cgi-bin/man.cgi/OpenBSD-current/man1/tmux.1?query=tmux&amp;amp;sec=1"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;对tmux进行个性化配置&lt;/h2&gt;
&lt;p&gt;默认的配置，可以比较不习惯，可以编辑 $HOME/.tmux.conf 文件，对tmux进行配置。&lt;/p&gt;
&lt;p&gt;1.将前缀更改为 &lt;strong&gt;ctrl + a&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;set&lt;/span&gt; -g prefix ^a
unbind ^b
&lt;span class="nb"&gt;bind &lt;/span&gt;a send-prefix
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保存后，为了使配置生效：
先按 &lt;strong&gt;ctrl+b&lt;/strong&gt;，然后输入&lt;strong&gt;：&lt;/strong&gt;，进入命令行模式， 在命令行模式下输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;source&lt;/span&gt;-file ~/.tmux.conf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在就把前缀改为了ctrl + a了。&lt;/p&gt;
&lt;p&gt;2.水平或垂直分割窗口&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;unbind &lt;span class="s1"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;
&lt;span class="nb"&gt;bind&lt;/span&gt; - splitw -v &lt;span class="c"&gt;# 分割成上下两个窗口&lt;/span&gt;
unbind %
&lt;span class="nb"&gt;bind&lt;/span&gt; | splitw -h &lt;span class="c"&gt;# 分割成左右两个窗口&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;3.切换窗格设置为和Vim一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# navigate panes with hjkl&lt;/span&gt;
&lt;span class="nb"&gt;bind &lt;/span&gt;h &lt;span class="k"&gt;select&lt;/span&gt;-pane -L
&lt;span class="nb"&gt;bind &lt;/span&gt;j &lt;span class="k"&gt;select&lt;/span&gt;-pane -D
&lt;span class="nb"&gt;bind &lt;/span&gt;k &lt;span class="k"&gt;select&lt;/span&gt;-pane -U
&lt;span class="nb"&gt;bind &lt;/span&gt;l &lt;span class="k"&gt;select&lt;/span&gt;-pane -R
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;4.panel大小调整&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;bind&lt;/span&gt; ^k resizep -U 10 &lt;span class="c"&gt;# 跟选择窗格的设置相同，只是多加 Ctrl（Ctrl-k）&lt;/span&gt;
&lt;span class="nb"&gt;bind&lt;/span&gt; ^j resizep -D 10 &lt;span class="c"&gt;# 同上&lt;/span&gt;
&lt;span class="nb"&gt;bind&lt;/span&gt; ^h resizep -L 10 &lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;span class="nb"&gt;bind&lt;/span&gt; ^l resizep -R 10 &lt;span class="c"&gt;# ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;5.交换两个窗格&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;bind&lt;/span&gt; ^u swapp -U &lt;span class="c"&gt;# 与上窗格交换 Ctrl-u&lt;/span&gt;
&lt;span class="nb"&gt;bind&lt;/span&gt; ^d swapp -D &lt;span class="c"&gt;# 与下窗格交换 Ctrl-d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里就不一一列举，所有的配置。大家可以根据自己的习惯和喜好进行更改。以下是几个配置供大家参考：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;https://github.com/gpakosz/.tmux&lt;/li&gt;
&lt;li&gt;https://github.com/tony/tmux-config&lt;/li&gt;
&lt;li&gt;https://gist.github.com/spicycode/1229612&lt;/li&gt;
&lt;li&gt;http://zanshin.net/2013/09/05/my-tmux-configuration/&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 11 May 2015 09:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-11:zhong-duan-chuang-kou-guan-li-shen-qi-tmux.html</guid><category>tmux</category></item><item><title>选择问题及复杂度分析</title><link>http://www.wengweitao.com/xuan-ze-wen-ti-ji-fu-za-du-fen-xi.html</link><description>&lt;p&gt;选择问题是在实际应用中经常碰到的问题，最常见的选择问题有：选最大、选最小、选中位数、选第二大等。&lt;/p&gt;
&lt;p&gt;可以描述为从n个元素的集合L中选出第k小的元素，其中&lt;span class="math"&gt;\(1 \leq k \leq n\)&lt;/span&gt;。这里的第k小表示：将L中的元素按照升序排列，排在第k个位置的元素。如k=1时，选出的就是最小元素。&lt;/p&gt;
&lt;p&gt;本文将对选择问题进行总结并对它们的复杂度进行分析。&lt;/p&gt;
&lt;h2&gt;选最大最小问题&lt;/h2&gt;
&lt;h3&gt;选最大算法&lt;/h3&gt;
&lt;p&gt;选最大问题，最容易想到的方法就是顺序比较算法，从第一个元素开始依次往后比较n个元素，用一个变量max保存当前的最大值，算法实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于需要遍历集合L的n个元素，所以算法的时间复杂度为W(n-1)。可以证明，这个算法是求解选最大问题在时间上最优的算法。&lt;/p&gt;
&lt;h3&gt;选最小算法&lt;/h3&gt;
&lt;p&gt;只需要将上面选最大问题的算法稍微改动即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;时间复杂度也与选最大问题相同。&lt;/p&gt;
&lt;h3&gt;同时选最大和最小算法&lt;/h3&gt;
&lt;p&gt;我们可以利用findMax和findMin算法得到选最大和最小的算法。设计思想为：先选出最大，然后将这个最大从L中删除，接着选最小。这样时间复杂度可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$W(n) = n - 1 + n - 2 = 2n - 3$$&lt;/div&gt;
&lt;p&gt;下面考虑分组比赛的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将L中的元素两两一组，分成&lt;span class="math"&gt;\(\frac{n}{2}\)&lt;/span&gt;组，若n为奇数，有一个元素轮空；&lt;/li&gt;
&lt;li&gt;每组中通过一次比较可以得出每组中较大的和较小的数&lt;/li&gt;
&lt;li&gt;把至多&lt;span class="math"&gt;\(\frac{n}{2} + 1\)&lt;/span&gt;个小组较大数的放到一起，利用findMax算法找出其中最大的元素；&lt;/li&gt;
&lt;li&gt;把至多&lt;span class="math"&gt;\(\frac{n}{2} + 1\)&lt;/span&gt;个小组较小数的放到一起，利用findMin算法找出其中最小的元素；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;findMaxMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//用于保存两两比较之后较大的数&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//用于保存两两比较之后较小的数&lt;/span&gt;

    &lt;span class="c1"&gt;// 每个小组分别比较&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 若n为奇数，最后一个元素轮空&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;findMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;  &lt;span class="c1"&gt;// n/2 + 1个元素&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;findMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个算法的实现要比第一个要复杂些，但是效率会高一些。从上面的代码可以看出，每个小组分别比较找出较大和较小的数的比较次数为&lt;span class="math"&gt;\(\frac{n}{2}\)&lt;/span&gt;次，从两个子集中找出最大和最小的数的比较次数都为&lt;span class="math"&gt;\(\lceil\frac{n}{2}\rceil-1\)&lt;/span&gt;次，那么总的比较次数就是：
&lt;/p&gt;
&lt;div class="math"&gt;$$W(n) = \frac{n}{2} + 2 * (\lceil\frac{n}{2}\rceil-1)=\lceil\frac{3n}{2}\rceil-2$$&lt;/div&gt;
&lt;p&gt;
可以证明这个算法是所有同时找最大和最小算法中时间复杂度最低的算法。&lt;/p&gt;
&lt;p&gt;等效的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;findMaxMin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 每两个元素需要3次比较&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;min&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不需要使用额外的数组来保存每次的较大值集合。如果n是奇数，就将最大值和最小值都设为第一个元素的值，然后剩余的元素两两比较，把较大的元素与当前的最大值进行比较，把较小的元素与当前的最小值进行比较，这样每两个元素就需要3次比较；如果n是偶数，就将最大值初始化为前两个元素较大的那个，较小的那个就作为最小值的初始值，然后与n为奇数的情况一样。&lt;/p&gt;
&lt;h2&gt;选第二大问题&lt;/h2&gt;
&lt;p&gt;最简单方法的就是调用findMax找到最大的元素，然后从L中删除max，再调用findMax找出剩下元素的最大元素，就是L中的第二大元素second。时间复杂度为
&lt;/p&gt;
&lt;div class="math"&gt;$$W(n)=n - 1 + n - 2 = 2n - 3$$&lt;/div&gt;
&lt;p&gt;下面考虑锦标赛算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将L的元素两两一组，分为&lt;span class="math"&gt;\(\frac{n}{2}\)&lt;/span&gt;组（若n为奇数，有一个数轮空）；&lt;/li&gt;
&lt;li&gt;每组内进行比较，将较小的淘汰，每组中较大的元素和轮空的元素（如果有的话）进入下一轮；&lt;/li&gt;
&lt;li&gt;进入下一轮的元素个数为&lt;span class="math"&gt;\(\lceil\frac{n}{2}\rceil\)&lt;/span&gt;个，对这些元素仍然两两一组进行比较，较大进入下一轮，知道产生“冠军”，即最大元素为止；那么如何找到第二个大元素呢？&lt;/li&gt;
&lt;li&gt;首先，可以观察到，第二大的元素只能在与第一大的元素直接比较所淘汰的元素中产生（如果这个元素被max之外的元素淘汰，那么这个元素就最大只能第三大了）。这样，我们只需在被max比较中淘汰的元素。&lt;/li&gt;
&lt;li&gt;在比较的过程中，将每个元素所淘汰的元素记录下来，等找到max后，只需找出max淘汰记录中的最大元素即可，这就是第二大元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;算法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;findSecond&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 一直进行比较，直到L中只有一个元素，即最大值&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 保存本轮比较较大的数&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
            &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]].&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;                                                                                                                                                               
            &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// 若当前序列中元素的个数为奇数&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max_group&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;findMax&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]],&lt;/span&gt; &lt;span class="n"&gt;table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]].&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;second&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个算法的时间复杂度是多少呢？算法所做的比较次数分为两部分：&lt;/p&gt;
&lt;p&gt;（1）找最大元素max过程中的比较次数。每次比较都淘汰一个元素，淘汰n-1个元素的比较次数就是n-1；&lt;/p&gt;
&lt;p&gt;（2）在产生max后在其淘汰序列中找最大所需要的比较次数。这个比较次数等于max淘汰序列中的元素个数减1，而不难看出经过&lt;span class="math"&gt;\(\lceil logn \rceil\)&lt;/span&gt;次淘汰后只剩下一个元素max，所以max淘汰序列中的元素个数为&lt;span class="math"&gt;\(\lceil logn \rceil\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;所以，该算法的时间复杂度为：
&lt;/p&gt;
&lt;div class="math"&gt;$$W(n) = n - 1 + \lceil logn \rceil - 1 = n + \lceil logn \rceil - 2$$&lt;/div&gt;
&lt;p&gt;可以证明，对于找第二大的问题，以上的算法是时间复杂度最低的算法。&lt;/p&gt;
&lt;h2&gt;选第k小问题&lt;/h2&gt;
&lt;p&gt;以上讨论了选择问题的一些特例情况，下面考虑一般性的选择第k小的问题。&lt;/p&gt;
&lt;p&gt;容易想到的一种做法是对数组S进行排序，然后输出第k小的元素，时间复杂度为O(nlogn)。&lt;/p&gt;
&lt;p&gt;那么是否存在O(n)时间复杂度的算法？下面我们考虑分治算法。为了叙述方便，不妨假设S中的元素彼此不相等。&lt;/p&gt;
&lt;p&gt;（1）以S中某元素&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;作为标准将S划分成两个子数组&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;和&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;中的元素都比&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;小，&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;中的元素都比&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;大。&lt;/p&gt;
&lt;p&gt;（2）令&lt;span class="math"&gt;\(|S_1|\)&lt;/span&gt;表示&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;子数组中元素的个数，&lt;span class="math"&gt;\(|S_2|\)&lt;/span&gt;表示&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;子数组中元素的个数。&lt;/p&gt;
&lt;p&gt;（3）如果&lt;span class="math"&gt;\(k \leq |S_1|\)&lt;/span&gt;，那么原问题就转化为求：在&lt;span class="math"&gt;\(S_1\)&lt;/span&gt;中找第k小的元素；&lt;/p&gt;
&lt;p&gt;（4）如果&lt;span class="math"&gt;\(k = |S_1|+1\)&lt;/span&gt;，那么&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;就是所要找的第k小的元素；&lt;/p&gt;
&lt;p&gt;（5）如果&lt;span class="math"&gt;\(k \gt |S_1|+1\)&lt;/span&gt;，那么原问题就转化为在&lt;span class="math"&gt;\(S_2\)&lt;/span&gt;中找出第&lt;span class="math"&gt;\(k'\)&lt;/span&gt;小的元素，其中&lt;span class="math"&gt;\(k' = k - |S_1| - 1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看出，算法的关键就是如何确定划分S的元素&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;，它需要满足以下条件：&lt;/p&gt;
&lt;p&gt;（1）寻找&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;的代价不能太高，如果是O(nlogn)那么不如直接使用排序的方法求解。如果直接寻找&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;，时间应该是O(n)。设选择算法的时间复杂度为T(n)，递归调用这个算法在S的一个真子集上寻找&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;，应该使用T(cn)时间，这里c是一个小于1的常数，反映了M的规模与S相比缩小了多少。&lt;/p&gt;
&lt;p&gt;（2）考虑最坏的情况，每次递归调用都进入一个规模较大的一个，即子问题规模为&lt;span class="math"&gt;\(max(|S_1|, |S_2|)\)&lt;/span&gt;，每次调用时，子问题规模与原问题的规模n的比都不超过某个小于1的常数d，调用时间为T(dn)。在采用递归算法寻找&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;时，要保证c+d&amp;lt;1，否则方程
&lt;/p&gt;
&lt;div class="math"&gt;$$T(n)=T(cn)+T(dn)+O(n)$$&lt;/div&gt;
&lt;p&gt;
的解不会达到O(n)。&lt;/p&gt;
&lt;h3&gt;期望为线性时间的选择算法&lt;/h3&gt;
&lt;p&gt;与快速排序一样，我们将输入数组进行递归划分。但与快速排序不同的是，选择问题只需处理划分的一边即可。这一差异会在性能分析中体现出来：快排的期望运行时间为O(nlogn)，而选择问题的期望运行时间为O(n)。&lt;/p&gt;
&lt;p&gt;算法实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;randomInRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;srand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;rand_num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;rand_num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;randomInRange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   

    &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;partition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;select&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用了partition过程，它的部分行为是由随机数的输出决定的。以上的select算法的期望运行时间为O(n)，但是最坏运行时间为&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，因为每次划分如果不走运的话可能出现总是按余下元素中最大的来进行划分，而划分操作的时间复杂度为O(n)。&lt;/p&gt;
&lt;h3&gt;最坏情况为线性时间的选择算法&lt;/h3&gt;
&lt;p&gt;现在来看最坏运行时间为O(n)的选择算法，仍然采用递归划分来寻找所需数组，但是，该算法能够保证数组得到很好的划分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将S进行分组，5个元素一组，共分成&lt;span class="math"&gt;\(\lceil \frac{n}{5} \rceil\)&lt;/span&gt;组；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每组找一个本组的中位数，然后将这些中位数放入集合M中。可以对每组元素进行插入排序，然后确定每组有序元素的中位数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在M中调用select选择算法选出一个M的中位数，这个中位数就是我们要找的&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;对数组S进行划分；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num比划分的低区中的元素数目多1，因此&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;就是第k小的元素，那么就返回&lt;span class="math"&gt;\(m^*\)&lt;/span&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果num &amp;gt; k在低区递归调用select选择算法；如果num &amp;lt; k在高区递归查找第k-num小的元素&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以证明，该算法最坏情况下的时间复杂度为O(n)。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://book.douban.com/subject/6434299/"&gt;算法设计与分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://book.douban.com/subject/20432061/"&gt;算法导论&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 06 May 2015 11:10:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-06:xuan-ze-wen-ti-ji-fu-za-du-fen-xi.html</guid><category>算法分析</category></item><item><title>Linux上搭建VPN服务器</title><link>http://www.wengweitao.com/linuxshang-da-jian-vpnfu-wu-qi.html</link><description>&lt;p&gt;今天是五一劳动节，也就是五月份的第一天，不巧的是校园上网账号欠费了，导致无法通过认证上网。于是，就琢磨着如何不通过认证直接上网。实验室有几台服务器，这些服务器都无需认证可直接访问外网，很自然的就想到以下两种方法：&lt;/p&gt;
&lt;p&gt;（1）在服务器上设置代理服务器，然后在自己的PC和iPhone上设置代理上网&lt;/p&gt;
&lt;p&gt;（2）在服务器上搭建一个VPN PPTP服务器，在PC和iPhone上新建一个VPN连接上网。&lt;/p&gt;
&lt;p&gt;根据校园网的环境和平时的使用情况，最终决定采用VPN的方式。接下来，我以Red Hat系统为例，详细说明搭建的过程。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;1. 判断PPP是否可用&lt;/h2&gt;
&lt;p&gt;首先，我们需要检查服务器是否支持搭建PPTP，在shell中输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ppp&lt;/span&gt;

&lt;span class="nl"&gt;cat:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ppp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;没有那个设备或地址&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果出现以上提示，说明这台服务器PPP可用；若出现"Permission denied"提示，则无法使用PPP，考虑更换一台服务器。&lt;/p&gt;
&lt;h2&gt;2. 安装所需的软件包&lt;/h2&gt;
&lt;p&gt;主要需要以下3个软件包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PPP：点对点协议&lt;/li&gt;
&lt;li&gt;PPTP：点对点通道协议&lt;/li&gt;
&lt;li&gt;IPtables：设定IP包转发规则&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;（1）安装PPP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用yum安装即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;ppp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;（2）安装IPtables&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常Linux系统上都自带安装好了iptables，如果没有可以使用yum进行安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt;
&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rpf&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sysconfig&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sysconfig&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;iptables&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pptpsave&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;src&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;（3）安装PPTP套件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的系统直接yum那么可以直接通过yum进行安装，但是我的系统是Red Hat 4.4.6-4，yum中没有提供pptp套件的rpm包，只能自己先下载到本地。&lt;/p&gt;
&lt;p&gt;到&lt;a href="http://poptop.sourceforge.net/yum/stable/"&gt;这里&lt;/a&gt;下载适合你系统的rpm包。可以使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;查看Linux系统信息。&lt;/p&gt;
&lt;p&gt;注意：一定要正确选择适合自己系统的rpm包，如果下载错误将无法完成安装。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//poptop.sourceforge.net/yum/stable/rhel6/x86_64/pptpd-1.4.0-1.el6.x86_64.rpm&lt;/span&gt;

&lt;span class="n"&gt;rpm&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ivh&lt;/span&gt; &lt;span class="n"&gt;pptpd&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.4.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="n"&gt;el6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x86_64&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;（4）进行配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用Vim编辑 /etc/sysctl.conf 文件，将其中的一行内容修改为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ipv4&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ip_forward&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;复制以下所有命令，粘贴在shell中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;sysctl&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;localip 192.168.240.1&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pptpd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;remoteip 192.168.240.101-200&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;pptpd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ms-dns 8.8.8.8&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ppp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pptpd&lt;/span&gt;
&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;ms-dns 8.8.4.4&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ppp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;options&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pptpd&lt;/span&gt;
&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt; &lt;span class="n"&gt;POSTROUTING&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;table&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt;
&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;flush&lt;/span&gt; &lt;span class="n"&gt;FORWARD&lt;/span&gt;
&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;1723&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;gre&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;POSTROUTING&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="mf"&gt;192.168.240.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;MASQUERADE&lt;/span&gt;
&lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="n"&gt;save&lt;/span&gt;
&lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;pptpd&lt;/span&gt; &lt;span class="n"&gt;restart&lt;/span&gt;
&lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="n"&gt;restart&lt;/span&gt;
&lt;span class="n"&gt;chkconfig&lt;/span&gt; &lt;span class="n"&gt;pptpd&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;span class="n"&gt;chkconfig&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上主要设置了VPN所使用的IP地址段、包转发规则等。VPN客户端将分配到的地址为：192.168.240.* 地址段，通过VPN服务器的eth0以太网接口转发对外的数据包（可以使用ifconfig查看本机对外通信的接口是否为eth0，若不是可自行更改）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（5）设置VPN账号和密码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你任意添加VPN账户，使用Vim编辑文件 /etc/ppp/chap-secrets 一行一个账户，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;wwt&lt;/span&gt;  &lt;span class="n"&gt;pptpd&lt;/span&gt;  &lt;span class="mi"&gt;123456&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分别表示账户名、VPN服务、密码、IP。&lt;/p&gt;
&lt;p&gt;现在，就可以在PC或者iPhone上连接VPN上网了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（6）客户端连接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以Windows8.1为例。&lt;/p&gt;
&lt;p&gt;①打开网络和共享中心，点击“设置新的连接或网络”&lt;/p&gt;
&lt;p&gt;②选择“连接到工作区”，创建新的连接，一直下一步&lt;/p&gt;
&lt;p&gt;③填入VPN服务器IP地址和名称（名称可以任意），点击“创建”&lt;/p&gt;
&lt;p&gt;④点击桌面右下角网络网络连接的图标，选择创建的那个VPN连接，输入刚刚设置的用户名和密码即可。&lt;/p&gt;
&lt;p&gt;⑤访问http://ip.cn 可以看到你的IP已经变成了VPN服务器的IP。&lt;/p&gt;
&lt;p&gt;同样，在Mac OS X和iPhone上也可以非常容易的创建VPN连接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过连接校园网内的VPN服务器上网，不仅不需要认证，而且当你不在学校的时候，还可以连接VPN下载文献论文，非常有用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.vixual.net/blog/archives/32"&gt;CentOS 5/6 快速安裝 VPN Server (PPTP)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/sixiweb/archive/2012/11/20/2778732.html"&gt;Linux下搭建VPN服务器（CentOS、pptp）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 01 May 2015 21:21:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-05-01:linuxshang-da-jian-vpnfu-wu-qi.html</guid><category>教程</category></item><item><title>Go语言入门教程（1）</title><link>http://www.wengweitao.com/goyu-yan-ru-men-jiao-cheng-1.html</link><description>&lt;h2&gt;什么是Go？&lt;/h2&gt;
&lt;p&gt;以下是&lt;a href="https://golang.org/doc/"&gt;Go官方网站&lt;/a&gt;对其解释：&lt;/p&gt;
&lt;p&gt;Go 编程语言是一个使得程序员更加有效率的开源项目。Go是有表达力、简洁、清晰和有效率的。它的并行机制使其很容易编写多核和网络应用，而新奇的类型系统允许构建有弹性的模块化程序。Go编译到机器码非常快速，同时具有便利的垃圾回收和强大的运行时反射。它是快速的、静态类型编译语言，但是感觉上是动态类型的，解释型语言。&lt;/p&gt;
&lt;h2&gt;Go的特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;清晰并且简洁&lt;/li&gt;
&lt;li&gt;并行。很容易让函数变成一个轻量的线程，这些线程被称为goroutines。&lt;/li&gt;
&lt;li&gt;Channel。goroutines直接的通信由channel完成。&lt;/li&gt;
&lt;li&gt;快速。编译和执行都很快。&lt;/li&gt;
&lt;li&gt;安全。类型转换遵循严格的规则并且需要显式的转换；有垃圾收集，无序free()。&lt;/li&gt;
&lt;li&gt;标准格式化。gofmt的输出是官方认可的格式&lt;/li&gt;
&lt;li&gt;类型后置。与类C语言不同，Go的类型在变量名之后&lt;/li&gt;
&lt;li&gt;UTF-8。任何地方都是UTF-8（用过Python的人应该体会到不是UTF-8的痛苦。。。）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Go语言与Erlang比较类似，区别在于Erlang是函数式编程语言，而Go是命令式；Erlang运行在虚拟机上，而Go是编译后运行的。&lt;/p&gt;
&lt;h2&gt;安装Go&lt;/h2&gt;
&lt;p&gt;这里以Linux平台为例。&lt;/p&gt;
&lt;p&gt;下载&lt;a href="https://golang.org/dl/"&gt;Go的压缩包&lt;/a&gt;并解压到 /usr/local 目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xzf&lt;/span&gt; &lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;VERSION&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;OS&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;ARCH&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将 /usr/local/go/bin 添加到PATH环境变量中，添加如下一行内容到 /etc/profile (系统范围)或者 $HOME/.profile(如果没有这个文件需要新建一个):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在shell中输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果出现go的帮助提示，则安装完成。&lt;/p&gt;
&lt;h2&gt;第一个Go程序：Hello World&lt;/h2&gt;
&lt;p&gt;编写hello.go：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;  &lt;span class="c1"&gt;//用于输出&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello, world\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                                                                                                                                                                         
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（1）声明本文件的package名，所有go文件以package &amp;lt; name &amp;gt;开头，对于独立运行的执行文件必须是package main；&lt;/p&gt;
&lt;p&gt;（2）将fmt包引入main中，用于格式输出，不是main的其他包都被称为库。末尾//是注释，另外Go也支持/&lt;em&gt; ... &lt;/em&gt;/注释&lt;/p&gt;
&lt;p&gt;（3）定义了main函数，Go程序在执行的时候，首先调用的函数是main.main()&lt;/p&gt;
&lt;p&gt;（4）调用fmt包的函数输出字符串到屏幕。&lt;/p&gt;
&lt;h2&gt;编译和运行&lt;/h2&gt;
&lt;p&gt;有两种方式运行：&lt;/p&gt;
&lt;p&gt;（1）解释执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）编译执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;go&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt; &lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时，会在当前目录生成hello的可执行文件，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;变量、类型和关键字&lt;/h2&gt;
&lt;h3&gt;变量声明&lt;/h3&gt;
&lt;p&gt;Go的变量声明使用关键字var，Go声明的时候把变量的类型写在变量名的后面。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;//相同的类型可以在同一行声明&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一种将声明和变量和在一起：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
&lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
&lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello, world&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;  &lt;span class="c1"&gt;//平行赋值&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种情况下变量的类型是由值推导出来的。&lt;/p&gt;
&lt;p&gt;Go中存在一个特殊的变量名_。任何赋给它的值都会被丢弃。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;  &lt;span class="c1"&gt;//将35赋值给b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果有多个var声明或者const和import，可以采用组的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Go对声明了却未使用的变量会报错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;数字类型&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="c1"&gt;//通用整数类型&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="kt"&gt;int32&lt;/span&gt;   &lt;span class="c1"&gt;//32位整数类型&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;15&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="c1"&gt;//不能混合使用这些类型，非法！&lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt; &lt;span class="c1"&gt;// ok                                                                                                                                                                                       &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;常量&lt;/h3&gt;
&lt;p&gt;常量使用const进行声明，它们在编译时被创建。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

&lt;span class="kd"&gt;const&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;itoa&lt;/span&gt;   &lt;span class="c1"&gt;// a = 0 &lt;/span&gt;
    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;itoa&lt;/span&gt;   &lt;span class="c1"&gt;// b = 1&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;字符串&lt;/h3&gt;
&lt;p&gt;双引号包裹的是字符串(string)，如果使用单引号那么就是字符。Go中字符串一旦赋值后，就不能再修改了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;   &lt;span class="c1"&gt;// error&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要修改，可以：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;hello&amp;quot;&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="nb"&gt;rune&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//将s转换为rune数组&lt;/span&gt;
    &lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;                                                                                                                                                                                            
    &lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的rune是int32的别名，用UTF-8进行编码，当需要遍历字符串中的字符时，为了获取实际的字符，需要使用rune类型。&lt;/p&gt;
&lt;h3&gt;错误&lt;/h3&gt;
&lt;p&gt;Go有一个为了错误而存在的内建类型：error。&lt;/p&gt;
&lt;p&gt;var e error定义了一个error类型的变量e。&lt;/p&gt;
&lt;h2&gt;控制结构&lt;/h2&gt;
&lt;h3&gt;if语句&lt;/h3&gt;
&lt;p&gt;if语句无需圆括号，而语句体必须有花括号&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;// 必须与if同一行&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Negative&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                                                                                                                                                                           
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;//必须同一行&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Zero&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Positive&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;for语句&lt;/h3&gt;
&lt;p&gt;Go中没有while语句。对于for语句有3种形式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// 第一种， init; condition; post&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="c1"&gt;// 第二种，类似while，condition&lt;/span&gt;
    &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
        &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="c1"&gt;// 第三种， 死循环&lt;/span&gt;
    &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
        &lt;span class="nx"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
        &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;                                                                                                                                                                                               
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Go没有逗号表达式，如果想执行多个变量，应当使用平行赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Reverse a&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关键字range可用于循环中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;list&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;b&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;c&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;// 创建一个字符串的slice&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;list&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 每次返回int类型序号和值，如0和&amp;quot;a&amp;quot;&lt;/span&gt;
    &lt;span class="c1"&gt;// doSomething()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;switch语句&lt;/h3&gt;
&lt;p&gt;Go的switch表示式不必是常量或整数，case可以有多个值，没有break，。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;//空的case体&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;  &lt;span class="c1"&gt;//当 i == 0 时， f 不会被调用&lt;/span&gt;
    &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="c1"&gt;//  , 相当于 or&lt;/span&gt;
        &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;   
    &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;内建函数&lt;/h2&gt;
&lt;p&gt;Go中预定义了不少函数，不用引进任何包就可以直接使用它们。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;close：关闭channel&lt;/li&gt;
&lt;li&gt;delete：在map中删除实例&lt;/li&gt;
&lt;li&gt;len和cap：返回字符串等的长度和容量&lt;/li&gt;
&lt;li&gt;new：各种类型的内存分配&lt;/li&gt;
&lt;li&gt;make：用于内建类型（map, slice和channel）的内存分配&lt;/li&gt;
&lt;li&gt;copy：复制slice&lt;/li&gt;
&lt;li&gt;append：追加slice&lt;/li&gt;
&lt;li&gt;panic和recover：异常处理&lt;/li&gt;
&lt;li&gt;print和println：打印函数，主要用于调试&lt;/li&gt;
&lt;li&gt;complex, real和imag：处理复数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;array、slices和map&lt;/h2&gt;
&lt;h3&gt;array&lt;/h3&gt;
&lt;p&gt;array由[n]type定义，n表示数组的长度，type表示数组元素的类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//默认初始化为0&lt;/span&gt;

    &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//改变其中一个元素的值&lt;/span&gt;

    &lt;span class="nx"&gt;b&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;//复合声明&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


    &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;  &lt;span class="c1"&gt;//也可以简写&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;d&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;  &lt;span class="c1"&gt;// 将一个数组赋值给另一个数组，会复制所有的元素，而不是数组的指针&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 多维数组&lt;/span&gt;
    &lt;span class="nx"&gt;e&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;f&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 简写&lt;/span&gt;
    &lt;span class="nx"&gt;g&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;                                                                                                                                                                 
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[0 0 0 0 0]&lt;/span&gt;
&lt;span class="k"&gt;[0 1 0 0 0]&lt;/span&gt;
&lt;span class="k"&gt;[1 2 3]&lt;/span&gt;
&lt;span class="k"&gt;[1 2 3]&lt;/span&gt;
&lt;span class="k"&gt;[0 1 0 0 0]&lt;/span&gt;
&lt;span class="k"&gt;[[1 2] [3 4] [5 6]]&lt;/span&gt;
&lt;span class="k"&gt;[[1 2] [3 4] [5 6]]&lt;/span&gt;
&lt;span class="k"&gt;[[1 2] [3 4] [5 6]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;slice&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;slice与array相似，但是新元素加入的时候可以增加长度。&lt;/li&gt;
&lt;li&gt;slice是一个指向array的指针；&lt;/li&gt;
&lt;li&gt;slice是引用类型，赋值某个slice到了一个变量，两个引用会指向同一个array&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;s1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 使用make创建一个保存有10个元素的slice&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nx"&gt;a1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;s2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;span class="c1"&gt;//从array创建一个slice&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;s3&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;[:]&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;array&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="nx"&gt;slice&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;cap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nb"&gt;cap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;// capacity=100, len=99&lt;/span&gt;

    &lt;span class="nx"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;98&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;a&amp;#39;&lt;/span&gt; 
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;98&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;

    &lt;span class="c1"&gt;// append&lt;/span&gt;
    &lt;span class="nx"&gt;s4&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;s5&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;s6&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s4&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// 注意这3个点&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// copy(dst, src)，返回复制元素的个数&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;([]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  
    &lt;span class="nx"&gt;n1&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:])&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;n2&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:])&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;n2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[0 0 0 0 0 0 0 0 0 0]&lt;/span&gt;
&lt;span class="k"&gt;[3 4]&lt;/span&gt;
&lt;span class="k"&gt;[1 2 3 4 5]&lt;/span&gt;
&lt;span class="err"&gt;100&lt;/span&gt; &lt;span class="err"&gt;100&lt;/span&gt;
&lt;span class="err"&gt;99&lt;/span&gt; &lt;span class="err"&gt;100&lt;/span&gt;
&lt;span class="err"&gt;97&lt;/span&gt;
&lt;span class="k"&gt;[0 0 2 3 4]&lt;/span&gt;
&lt;span class="k"&gt;[0 0 2 3 4 0 0]&lt;/span&gt;
&lt;span class="err"&gt;6&lt;/span&gt; &lt;span class="k"&gt;[0 1 2 3 4 5]&lt;/span&gt;
&lt;span class="err"&gt;4&lt;/span&gt; &lt;span class="k"&gt;[2 3 4 5 4 5]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;map&lt;/h3&gt;
&lt;p&gt;map类似于Python中的字典，定义方法是：map[&amp;lt; from type &amp;gt;]&amp;lt; to type &amp;gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;//声明一个map&lt;/span&gt;

    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="cm"&gt;/* 也可以直接初始化一个map：&lt;/span&gt;
&lt;span class="cm"&gt;    m := map[string]int{&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;quot;one&amp;quot;: 1,&lt;/span&gt;
&lt;span class="cm"&gt;    &amp;quot;two&amp;quot;: 2,&lt;/span&gt;
&lt;span class="cm"&gt;    }&lt;/span&gt;
&lt;span class="cm"&gt;    */&lt;/span&gt;

    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%d\n&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// 每次输出顺序可能不同&lt;/span&gt;

    &lt;span class="c1"&gt;// range每次返回一个键值对&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;num&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="k"&gt;range&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 检查元素是否存在&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;present&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;
    &lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;present&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="c1"&gt;// 如果存在present为true&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;present&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;ok&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;ok&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                                                                                                                                                                                     

    &lt;span class="c1"&gt;// 直接从map取值&lt;/span&gt;
    &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;one&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;// 删除元素&lt;/span&gt;
    &lt;span class="nb"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;two&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;m&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;map&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;one&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://github.com/mikespook/Learning-Go-zh-cn"&gt;学习Go语言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://coolshell.cn/articles/8460.html"&gt;Go语言简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tour.go-zh.org/list"&gt;Go指南&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 30 Apr 2015 22:30:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-30:goyu-yan-ru-men-jiao-cheng-1.html</guid><category>Go</category></item><item><title>False is False is False 的结果是 True ?</title><link>http://www.wengweitao.com/false-is-false-is-false-de-jie-guo-shi-true.html</link><description>&lt;p&gt;在&lt;a href="https://www.youtube.com/channel/UCgxzjK6GuOHVKR_08TT4hJQ"&gt;PyCon 2015&lt;/a&gt;中提到一个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python中运行，以上命令得到的结果是：&lt;strong&gt;True&lt;/strong&gt;！
而&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python中运行，以上命令得到的结果是：&lt;strong&gt;False&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;对于很多Python的初学者肯定会对第一个的运行结果感到有点出乎意料。&lt;/p&gt;
&lt;p&gt;在关于比较运算的Python官方文档中提到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Formally, if a, b, c, ..., y, z are expressions and op1, op2, ..., opN are comparison operators, then a op1 b op2 c ... y opN z is equivalent to a op1 b and b op2 c and ... y opN z, except that each expression is evaluated at most once.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;

&lt;span class="c"&gt;# 相当于&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样上面的第一个例子的结果就容易解释了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

&lt;span class="c"&gt;#相当于&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这也是为什么我们可以在Python中直接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似的这种表达式的原因（而在C/C++中是无法这么写的）。这种写法从某种程度上来说，更符合英语的写法，但是为了避免让人误解，最好还是在适当的地方使用圆括号括起来。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 25 Apr 2015 10:37:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-25:false-is-false-is-false-de-jie-guo-shi-true.html</guid><category>Python</category></item><item><title>Vim入门教程</title><link>http://www.wengweitao.com/vimru-men-jiao-cheng.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Vim 在编辑器中是神一样的存在，熟练掌握Vim将极大提高编辑文本的效率。本文将介绍Vim最基本的操作和技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;操作篇&lt;/h2&gt;
&lt;h3&gt;模式&lt;/h3&gt;
&lt;p&gt;Vim中一共有4种模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普通模式：启动Vim后，为普通模式，所有键都为功能键。&lt;/li&gt;
&lt;li&gt;插入模式：按下键i，进入插入模式，此时可以输入文本，返回普通模式，按Esc键。&lt;/li&gt;
&lt;li&gt;可视模式：按下键v，进入可视模式，可以移动光标对文本进行选择&lt;/li&gt;
&lt;li&gt;命令行模式：输入":"进入命令行模式，运行Vim的命令&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;最基本的移动&lt;/h3&gt;
&lt;p&gt;将光标上下左右移动，分别对应kjhl四个键。可以在前面加数字代表移动多个单位。如10j下移10行。&lt;/p&gt;
&lt;h3&gt;在文件中的移动&lt;/h3&gt;
&lt;p&gt;G-----移动到最后一行&lt;/p&gt;
&lt;p&gt;gg ------ 移动到第一行&lt;/p&gt;
&lt;p&gt;10G ------ 跳到第10行&lt;/p&gt;
&lt;p&gt;75% ----- 跳转到全文75%的地方&lt;/p&gt;
&lt;h3&gt;移动到指定字符&lt;/h3&gt;
&lt;p&gt;使用f,t,F,T可以再当前行快速移动。&lt;/p&gt;
&lt;p&gt;fx ----- 移动到光标右边的第一个’x'字符上&lt;/p&gt;
&lt;p&gt;Fx ----- 反方向查找，也就是移动到光标左边的指定字符上。&lt;/p&gt;
&lt;p&gt;tx ----- 移动到光标右边的第一个’x'字符之前&lt;/p&gt;
&lt;p&gt;Tx ----- 它移动到光标右边的指定字符'x'之后。&lt;/p&gt;
&lt;p&gt;; ----- 重复前一次输入的f, t, F, T命令&lt;/p&gt;
&lt;p&gt;, ----- 反方向重复前一次输入的f, t, F,T命令。&lt;/p&gt;
&lt;p&gt;";"和","这两个命令前也可以使用数字来表示倍数。也可以在命令前面使用数字，表示倍数。例如：
3fx ----- 移动到光标右边的第3个’x'字符上。&lt;/p&gt;
&lt;h3&gt;移动到行首行尾&lt;/h3&gt;
&lt;p&gt;0 ------ 移动到行首&lt;/p&gt;
&lt;p&gt;$ ------ 移动到行尾&lt;/p&gt;
&lt;p&gt;^ -------移动到第一个非空白字符行首&lt;/p&gt;
&lt;h3&gt;按单词移动&lt;/h3&gt;
&lt;p&gt;w ------ 移动光标的下一个单词的词首&lt;/p&gt;
&lt;p&gt;b ------ 移动光标的上一个单词的词首&lt;/p&gt;
&lt;p&gt;e ------ 移动光标的下一个单词的词尾&lt;/p&gt;
&lt;p&gt;ge ------ 移动光标的上一个单词的词尾&lt;/p&gt;
&lt;h3&gt;按窗口移动&lt;/h3&gt;
&lt;p&gt;H ------ 让光标跳到当前窗口的顶部
M ------ 让光标跳到当前窗口的中部
L ------ 让光标跳到当前窗口的底部&lt;/p&gt;
&lt;h3&gt;相对于光标滚屏&lt;/h3&gt;
&lt;p&gt;zt ------ 把光标所在行移动窗口的顶端
zz ------ 把光标所在行移动窗口的中间
zb ------ 把光标所在行移动窗口的底部&lt;/p&gt;
&lt;h3&gt;各种插入&lt;/h3&gt;
&lt;p&gt;i ------ 在光标处插入
a ------ 在光标后插入
o ------ 在当前行后插入一个新行
O ------ 在当前行前插入一个新行
cw ------ 替换从光标所在位置后到一个单词结尾的字符（c键和w键）&lt;/p&gt;
&lt;h3&gt;复制和粘贴&lt;/h3&gt;
&lt;p&gt;yy ------ 拷贝当前行
p ------ 粘贴
也可以在yy和p的前面加上数字：
3yy ------ 拷贝当前行起的3行
3p ------ 粘贴文本3次&lt;/p&gt;
&lt;h3&gt;查找&lt;/h3&gt;
&lt;p&gt;在normal模式下进行查找。
/ ------ 在Normal模式下输入”/“，然后输入你想查询的字符串，回车，就跳转到第一个匹配的地方了。
? ------ 与/相反的方向查找
n ------ 重复上一次的查找命令
N ------ 按相反方向重复上一次的查找命令&lt;/p&gt;
&lt;p&gt;在输入”/“或”?“后，用上、下光标键(或CTRL-P/CTRL-N)翻看历史记录，然后再次执行这个查找。
你还可以使用”q/“和”q?“命令，在vim窗口最下面打开一个新的窗口，这个窗口会列出你的查找历史记录，你可以使用任何vim编辑命令对此窗口的内容进行编辑，然后再按回车，就会对光标所在的行的内容进行查找。如下图所示：
&lt;img alt="q_search" src="./imgs/q_search.png" /&gt;&lt;/p&gt;
&lt;p&gt;* ------ 查找光标所在位置的单词，所有匹配的单词将高亮显示，并跳到下一个匹配项上
# ------ 查找光标所在位置的单词，所有匹配的单词将高亮显示，并跳到上一个匹配项上&lt;/p&gt;
&lt;p&gt;% ------ 括号匹配移动，即移动到与当前光标所在括号匹配的括号的位置&lt;/p&gt;
&lt;h3&gt;替换字符串&lt;/h3&gt;
&lt;p&gt;%s/源字符串/目的字符串/g ------ 将当前文档中所有的源字符串替换为目的字符串&lt;/p&gt;
&lt;h3&gt;删除、撤销和重做&lt;/h3&gt;
&lt;p&gt;dd ------ 删除当前行
dt ------ 删除当前行直到遇到它后面跟的符号
u ------ 撤销上一次操作
ctrl + r ------ redo重做 
如我用dd删除了当前行，如果后悔了不想删除可以使用u命令撤销，如果还是想删除可以使用ctrl + r继续删除。&lt;/p&gt;
&lt;h3&gt;打开、保存和退出&lt;/h3&gt;
&lt;p&gt;以下操作除非特别说明都在命令模式下操作，即每个命令前都要加入":"，如:q退出。
q ------ 退出当前文件
q! ------ 强制退出当前文件，不保存
w ------ 写入文件，存盘
wq ------ 保存退出当前文件
x ------ 保存退出当前文件
ZZ ------ 保存退出当前文件（普通模式下运行）
e filepath ------ 打开一个文件
saveas filepath ------ 另存为
bn ------ 当同时打开很多文件后，可以使用bn切换下一个文件。
bp ------ 当同时打开很多文件后，可以使用bp切换上一个文件。&lt;/p&gt;
&lt;h3&gt;重复命令&lt;/h3&gt;
&lt;p&gt;. ------ 重复上一次离开插入模式之前的全部命令
n&amp;lt; command &amp;gt; ------ 之前提到过的重复command命令n次&lt;/p&gt;
&lt;h3&gt;光标移动和命令配合使用&lt;/h3&gt;
&lt;p&gt;0y&lt;span class="math"&gt;\( ------ 复制本行（0移动到行首，y从这里开始复制，\)&lt;/span&gt;直到本行最后一个字符） 
ye ------ 复制从当前位置到下一个单词的词尾&lt;/p&gt;
&lt;h2&gt;技巧篇&lt;/h2&gt;
&lt;h3&gt;找出当前文档中相同的行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;
&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;(.&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;$\&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;按时间撤消&lt;/h3&gt;
&lt;p&gt;Vim 7 包括了一个让用户跳转到任何编辑点之前或之后的新特性。如使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;earlier&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以返回到 10 分钟以前的编辑状态。
又如使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;later&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以跳转到 5 秒以后的编辑点。另外，可以使用 :undolist 命令查看缓冲区存在的撤销分支列表。而通过 :undo &amp;lt; number&amp;gt; 命令则能够移到撤销的某个分支。&lt;/p&gt;
&lt;h3&gt;删除当前文档的所有空行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;/^&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;在每行的行首或行尾插入指定字符串&lt;/h3&gt;
&lt;p&gt;行首插入： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^/&lt;/span&gt;&lt;span class="n"&gt;your_word&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;行尾插入：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;your_word&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;例如在每行前面插入行号如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/^/&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;读取shell命令&lt;/h3&gt;
&lt;p&gt;如插入日期：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;:r 是:read的缩写，!是表明要运行一个shell命令，意思是我要把shell命令的输出读到vim里来。&lt;/p&gt;
&lt;h3&gt;统计某个单词出现的次数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="c1"&gt;//gn&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;统计的结果会在底部的状态栏显示。&lt;/p&gt;
&lt;h3&gt;Vim粘贴缩进问题&lt;/h3&gt;
&lt;p&gt;在Vim中粘贴Python代码后，缩进就全乱了。进入paste模式以后，可以在插入模式下粘贴内容，不会有任何变形。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;paste&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后使用:set nopaste恢复普通模式。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;好了，这篇文章已经说了不少关于Vim的基本操作和技巧，如果能掌握这些就可以比较流畅的使用Vim了。之后会有更多关于Vim操作的文章。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 16 Apr 2015 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-16:vimru-men-jiao-cheng.html</guid><category>Vim</category></item><item><title>使用Pelican + Github Pages搭建个人博客</title><link>http://www.wengweitao.com/shi-yong-pelican-github-pagesda-jian-ge-ren-bo-ke.html</link><description>&lt;blockquote&gt;
&lt;p&gt;最近有不少同学问我，如何使用Python的Pelican搭建一个像我这样的一个个人博客。今天正好论文投稿结束，于是便抽出时间写这篇教程，希望对大家有用。有任何疑问欢迎在评论里说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;静态网站&lt;/h2&gt;
&lt;p&gt;早在多年之前，我就使用过WordPress + MySQL + Apache在国外的主机上搭建过个人博客。但是，对于个人博客而言，使用WordPress这种动态网站，还需要后台支持各种数据库，就显得过于臃肿。最近几年人们纷纷转向静态博客，加之Github Pages和Dropbox这些地方可以免费的放置这些静态页面，于是各种静态网站生成器便如雨后春笋出现，不完全统计的就有392种之多，这里由列出了所有的&lt;a href="https://staticsitegenerators.net/"&gt;Static site generator 列表及 Github 关注度排名&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;什么是静态网站&lt;/h3&gt;
&lt;p&gt;静态的网站全部由静态网页构成，这些网页都是提前生成好的，不需要与后台数据库进行交交互，并且内容不会动态改变。静态网站具有如下特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不需要数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;访问速度更快&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本没有安全性的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使写作者更加专注于内容本身&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们只需要使用任何一个编辑器利用markdown写出文章，生成静态html即可，不需要php，也不需要数据库，你可以发布在任何你喜爱的服务器上。 也可以运行在 GitHub Page 上，也就是说，你可以使用 GitHub 的服务来搭建你的项目页面、博客或者网站，而且是完全免费的！&lt;/p&gt;
&lt;h3&gt;几种常见的静态博客&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.&lt;a href="https://github.com/jekyll/jekyll"&gt;Jekyll&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jekyll可以说是静态网站的鼻祖，也是最著名的静态博客引擎。它是由GitHub创始人之一使用Ruby写的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.&lt;a href="https://github.com/imathis/octopress"&gt;Octopress&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Octopress是Jekyll的一个框架，但是降低了使用和部署的难度，目前也有大量的人在使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.&lt;a href="https://github.com/hexojs/hexo"&gt;Hexo&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hexo是使用Node.js编写的快速、简单且功能强大静态博客框架，值得一提的是Hexo作者来自中国台湾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.&lt;a href="https://github.com/spf13/hugo"&gt;Hugo&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hugo是使用Go语言编写的，特点是网站编译的速度非常快。记得在听IPN旗下的博客节目&lt;a href="https://ipn.li/kernelpanic/3/"&gt;内核恐慌&lt;/a&gt;中Rio谈到，使用Jekyll编译2000+网页需要12分钟左右，使用未经优化的Python多核程序进行编译需要5分钟左右，而使用Hugo只用了12秒！可见速度之快。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.&lt;a href="https://github.com/getpelican/pelican"&gt;Pelican&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是本博客使用的框架，是Python编写的静态博客框架中最流行的一种。Pelican作者来自法国，pelican在法语中的是记事本的意思，非常适合用来作为个人博客，作为一名Pythoner使用Pelican也就理所当然了。&lt;/p&gt;
&lt;h2&gt;如何搭建静态博客&lt;/h2&gt;
&lt;p&gt;这一部分，我将详细介绍如何使用Github Pages + Pelican搭建一个非常cool且完全免费的个人博客。&lt;/p&gt;
&lt;h3&gt;在本地搭建Pelican&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;直接使用pip安装Pelican即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通常我们都是使用Markdown来书写文章，所以还需要Pelican支持Markdown：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;markdown&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;2.生成站点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在你的电脑上，建立一个目录，作为博客的主目录。我们假定，它的名称为blog。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt;
&lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;quickstart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行一下命令后，就生成了一个站点，包含以下目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;blog&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;              &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;存放输入的源文件&lt;/span&gt;
&lt;span class="err"&gt;│&lt;/span&gt;   &lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;          &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;存放手工创建的静态页面&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;               &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;生成的输出文件&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;develop_server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt;    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便开启测试服务器&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;Makefile&lt;/span&gt;             &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;方便管理博客的&lt;/span&gt;&lt;span class="n"&gt;Makefile&lt;/span&gt;
&lt;span class="err"&gt;├──&lt;/span&gt; &lt;span class="n"&gt;pelicanconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;       &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主配置文件&lt;/span&gt;
&lt;span class="err"&gt;└──&lt;/span&gt; &lt;span class="n"&gt;publishconf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;       &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;主发布文件，可删除&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;另外，生成的过程中需要配置一些东西，大部分都可以一路回车，选择默认设置，其中有一步需要你填写自己的网站域名，如果暂时没有，可以先随便设置，之后可以在pelicanconf.py文件中进行修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.创建文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，就可以使用你喜欢的任何编辑器用markdown语法写你的第一篇文章。需要在每篇文章的开头填入以下关于文章的元信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;Title:&lt;/span&gt; &lt;span class="err"&gt;文章标题&lt;/span&gt;
&lt;span class="nl"&gt;Date:&lt;/span&gt; &lt;span class="err"&gt;创建日期&lt;/span&gt;
&lt;span class="nl"&gt;Modified:&lt;/span&gt; &lt;span class="err"&gt;修改日期&lt;/span&gt;
&lt;span class="nl"&gt;Category:&lt;/span&gt; &lt;span class="err"&gt;文章分类，标志本文处于该分类下&lt;/span&gt;
&lt;span class="nl"&gt;Tags:&lt;/span&gt; &lt;span class="err"&gt;文章标签，标志本文处于该标签下&lt;/span&gt;
&lt;span class="nl"&gt;Slug:&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="err"&gt;中该文章的链接地址&lt;/span&gt;
&lt;span class="nl"&gt;Author:&lt;/span&gt; &lt;span class="err"&gt;作者&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中Title和Category是必选的，其他的选择可以不写。在这些元信息的后面就是文章的内容了，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Title&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;title&lt;/span&gt;
&lt;span class="n"&gt;Date&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;03&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;
&lt;span class="n"&gt;Modified&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2010&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;05&lt;/span&gt; &lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;
&lt;span class="n"&gt;Category&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt;
&lt;span class="n"&gt;Tags&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;publishing&lt;/span&gt;
&lt;span class="n"&gt;Slug&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;post&lt;/span&gt;
&lt;span class="n"&gt;Authors&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Alexis&lt;/span&gt; &lt;span class="n"&gt;Metaireau&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Conan&lt;/span&gt; &lt;span class="n"&gt;Doyle&lt;/span&gt;
&lt;span class="n"&gt;Summary&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Short&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;feeds&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="kd"&gt;super&lt;/span&gt; &lt;span class="n"&gt;blog&lt;/span&gt; &lt;span class="n"&gt;post&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;把以上的文件保存在content目录下，如保存为./content/test.md&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.生成静态页面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回博客的主目录（即包含pelican文件的目录），然后在命令行中运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样就会自动在output目录下生成content目录下markdown文件对应的静态页面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.预览站点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以先在本地预览站点，在博客主目录下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;python&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;SimpleHTTPServer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在通过在浏览器中访问 http://localhost:8000/ 就可以看到你的站点了。&lt;/p&gt;
&lt;h3&gt;部署到Github上&lt;/h3&gt;
&lt;p&gt;Github就提供了&lt;a href="https://pages.github.com/"&gt;Pages&lt;/a&gt;功能，允许用户自定义项目首页，用来替代默认的源码列表。所以，github Pages可以被认为是用户编写的、托管在github上的静态网页。于是，我们就可以将生成的静态网页部署在Github Pages上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.建立一个repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;登陆自己的Github主页，创建一个名字为：username.github.io 的repository。
其中必须修改username为自己账号的username，如：nurnoch.github.io&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.将生成的静态网站上传到repository&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进入到output目录下，运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/username/username.github.com.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将username替换为自己的github用户名，初始化，并添加远程repository，将会生成 .git的目录，然后我们将output目录下的所有文件上传到github：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;update&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时可能需要输入账户和密码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.开始访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;访问http://username.github.io 就可以看到自己的个人博客站点了。
注意：第一次需要等待一段时间后才能看到。&lt;/p&gt;
&lt;h2&gt;配置Pelican&lt;/h2&gt;
&lt;p&gt;通过修改在博客根目录下的pelicanconf.py文件，可以对Pelican进行配置，具体配置可以&lt;a href="http://docs.getpelican.com/en/3.4.0/settings.html"&gt;参考这里&lt;/a&gt;。以下，是官方文档给出的一个配置例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;

&lt;span class="n"&gt;AUTHOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Alexis Métaireau&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Alexis&amp;#39; log&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;SITEURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://blog.notmyidea.org&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;TIMEZONE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Europe/Paris&amp;quot;&lt;/span&gt;

&lt;span class="c"&gt;# can be useful in development, but set to False when you&amp;#39;re ready to publish&lt;/span&gt;
&lt;span class="n"&gt;RELATIVE_URLS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

&lt;span class="n"&gt;GITHUB_URL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://github.com/ametaireau/&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;blog-notmyidea&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;PDF_GENERATOR&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="n"&gt;REVERSE_CATEGORY_ORDER&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;span class="n"&gt;LOCALE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;C&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_PAGINATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_DATE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;FEED_ALL_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/all.rss.xml&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;CATEGORY_FEED_RSS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;feeds/&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.rss.xml&amp;#39;&lt;/span&gt;

&lt;span class="n"&gt;LINKS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Biologeek&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://biologeek.org&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Filyb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://filyb.info/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Libert-fr&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://www.libert-fr.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;N1k0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://prendreuncafe.com/blog/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Tarek Ziadé&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://ziade.org/blog&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Zubin Mithra&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://zubin71.wordpress.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="n"&gt;SOCIAL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;twitter&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://twitter.com/ametaireau&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;lastfm&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://lastfm.com/user/akounet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;github&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http://github.com/ametaireau&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="c"&gt;# global metadata to all the contents&lt;/span&gt;
&lt;span class="n"&gt;DEFAULT_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;yeah&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;it is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),)&lt;/span&gt;

&lt;span class="c"&gt;# path-specific metadata&lt;/span&gt;
&lt;span class="n"&gt;EXTRA_PATH_METADATA&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;extra/robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;path&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# static paths will be copied without parsing their contents&lt;/span&gt;
&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;pictures&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;#39;extra/robots.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# custom page generated with a jinja2 template&lt;/span&gt;
&lt;span class="n"&gt;TEMPLATE_PAGES&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pages/jinja2_template.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;jinja2_template.html&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# code blocks with line numbers&lt;/span&gt;
&lt;span class="n"&gt;PYGMENTS_RST_OPTIONS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;linenos&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;table&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c"&gt;# foobar will not be used, because it&amp;#39;s not in caps. All configuration keys&lt;/span&gt;
&lt;span class="c"&gt;# have to be in caps&lt;/span&gt;
&lt;span class="n"&gt;foobar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;barbaz&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以根据自己的需求修改其中的：站点信息、时区和日期格式、默认语言和环境、主题、插件等。&lt;/p&gt;
&lt;h3&gt;增加sitemap&lt;/h3&gt;
&lt;p&gt;Pelican有着丰富的插件，可以配置sitemap插件, 生成 sitemap.xml 供搜索引擎使用。
首先，下载Pelican的所有插件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//github.com/getpelican/pelican-plugins.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改pelicanconf.py文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sitemap&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="c"&gt;# 配置sitemap 插件&lt;/span&gt;
&lt;span class="n"&gt;SITEMAP&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;format&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;priorities&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;},&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;changefreqs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;articles&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;indexes&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;daily&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s"&gt;&amp;quot;pages&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;monthly&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用浏览器访问 &lt;em&gt;your domain name&lt;/em&gt;/sitemap.xml即可看到生成的 Sitemap 了。&lt;/p&gt;
&lt;h3&gt;增加评论功能&lt;/h3&gt;
&lt;p&gt;Pelican支持Disqus评论, 可以在Disqus上申请一个账号, 然后在pelicanconf.py里添加或修改DISQUS_SITENAME项:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;DISQUS_SITENAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;*your Disqus username*&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样你的博客就自动支持评论功能了。&lt;/p&gt;
&lt;h3&gt;在文章中插入本地图片&lt;/h3&gt;
&lt;p&gt;content目录下建立一个 imgs目录
然后在 pelicanconf.py 中添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;STATIC_PATHS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;u&amp;quot;imgs&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在文章中引用图片：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;aimg&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;imgs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;png&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;插入数学公式&lt;/h3&gt;
&lt;p&gt;Pelican默认是不支持数学公式的，如果想要方便的使用Pelican书写数学公式，可以&lt;a href="http://www.wengweitao.com/shi-pelicanzhi-chi-latexshu-xue-gong-shi.html"&gt;参考这里&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;绑定域名&lt;/h2&gt;
&lt;p&gt;你现在可以通过https://username.github.io 访问你的博客，但是如果拥有一个自己的域名不是更酷吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.购买一个域名&lt;/strong&gt;
很多地方都能买到域名，如godaddy等。价格基本都差不多，我是在&lt;a href="http://client.gegehost.com/domainchecker.php"&gt;GegeHost&lt;/a&gt;上买的。现在有好多种顶级域名，不过我还是推荐.com的。输入一个域名，如果没有人注册过，你就可以注册，付款后这个域名就归你了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.增加CNAME文件&lt;/strong&gt;
在repo的根目录下面，新建一个名为CNAME的文本文件，里面写入你要绑定的域名，如：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;www.wengweitao.com&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在DNS要新建一条CNAME记录，指向username.github.com（请将username换成你的用户名）。这里推荐将你的域名添加到&lt;a href="https://www.dnspod.cn/"&gt;DNSPod&lt;/a&gt;，方便管理。&lt;/p&gt;
&lt;p&gt;Ok，现在你的个人博客站点就搭建好了！搭建容易，写博客难，希望各位都能坚持下去，把自己的心得体会分享给大家！&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;REFERENCES&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Static Site Generators: https://staticsitegenerators.net/&lt;/li&gt;
&lt;li&gt;Pelican Docs: http://docs.getpelican.com/en/3.5.0/&lt;/li&gt;
&lt;li&gt;github Pages和Jekyll入门：http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 16 Apr 2015 13:46:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-16:shi-yong-pelican-github-pagesda-jian-ge-ren-bo-ke.html</guid><category>教程</category></item><item><title>互联网实验室河源游玩</title><link>http://www.wengweitao.com/hu-lian-wang-shi-yan-shi-he-yuan-you-wan.html</link><description>&lt;p&gt;4月份，春暖花开，正是出游的好时间。实验室一年一度的集体出游（当然是老板全部报销啦~），就定在了4月11日和12日这两天，今年去的地方是——河源。实验室一群小伙伴度过了非常欢乐的一个周末。&lt;/p&gt;
&lt;h3&gt;河源&lt;/h3&gt;
&lt;p&gt;在去&lt;a href="http://zh.wikipedia.org/wiki/%E6%B2%B3%E6%BA%90%E5%B8%82"&gt;河源&lt;/a&gt;游玩之前，仅仅是听过有河源这个地方，其他的都是这次旅游完才了解到的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;河源在广东的东北部，从深圳坐大巴过去大概2个半小时。&lt;/li&gt;
&lt;li&gt;河源是一个地级市，河源市辖1个市辖区、5个县，但是地方感觉不太大。市区里面还分新城区和老城区，虽然是新城区不过高楼大厦仍然极少。&lt;/li&gt;
&lt;li&gt;大量客家人&lt;/li&gt;
&lt;li&gt;河源菜是东江菜的典型代表，而东江菜是粤菜的主要流派之一，其特点是偏重“肥、咸、熟”&lt;/li&gt;
&lt;li&gt;景点：&lt;ul&gt;
&lt;li&gt;万绿湖&lt;/li&gt;
&lt;li&gt;镜花缘&lt;/li&gt;
&lt;li&gt;野趣沟&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;行程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;野趣沟风景区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟1" src="./imgs/河源1.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟2" src="./imgs/河源2.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="野趣沟3" src="./imgs/河源5.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;山上的风景还挺不错&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;镜花缘&lt;/strong&gt;
&lt;img alt="镜花缘" src="./imgs/河源8.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;镜花缘里面实验室大合影&lt;/p&gt;
&lt;p&gt;&lt;img alt="镜花缘2" src="./imgs/河源7.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;通过镜子合影，有创意&lt;/p&gt;
&lt;p&gt;&lt;img alt="镜花缘3" src="./imgs/河源9.JPG" /&gt;&lt;/p&gt;
&lt;p&gt;女儿国表演&lt;/p&gt;
&lt;p&gt;此外，晚上我们还泡了温泉，一共60多个池子，牛奶的、艾草的、薰衣草的等等，非常舒服。&lt;/p&gt;
&lt;h3&gt;聚餐&lt;/h3&gt;
&lt;p&gt;回到深圳，还剩了不少经费，就实验室集体聚餐一次。除了研三忙着写毕业论文的师兄师姐，大家基本都到了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="聚餐" src="./imgs/聚餐1.jpg" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;这次河源之行大家还是非常欢乐。平时大家一直在实验室待着，天天对着电脑和论文，难得有这么好的机会，实验室12级，13级，14级的小伙伴们能够聚在一起出去游玩，彼此之间的感情也更加好了。今后，应该多组织大家出去。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 14 Apr 2015 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-14:hu-lian-wang-shi-yan-shi-he-yuan-you-wan.html</guid><category>玩</category></item><item><title>编写高质量Python代码（4）——设计模式</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-4-she-ji-mo-shi.html</link><description>&lt;blockquote&gt;
&lt;p&gt;本文将介绍如何写出Pythonic的设计模式代码，让设计模式更好的应用在实际的Python编程当中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议50：利用模块设计实现单例模式&lt;/h3&gt;
&lt;p&gt;GOF的23种设计模式中，单例是最常用的模式，通过单例模式可以保证系统中一个类只有一个实例而且该实例易于被外界访问，从而方便对实例个数的控制并节约系统资源。&lt;/p&gt;
&lt;p&gt;Python语言实现实例没有那么方便，因为缺乏声明私有构造函数的语法元素，实例又带有类型信息。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;_Singleton&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;span class="n"&gt;Singleton&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_Singleton&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;_Singleton&lt;/span&gt;
&lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Singleton&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__class__&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;another&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c"&gt;# 输出 &amp;lt;class &amp;#39;__main__._Singleton&amp;#39;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;虽然把Singleton的类定义删除了，但是还是可以通过已有实例的__class__属性生成一个新的实例。&lt;/p&gt;
&lt;p&gt;其实模块采用的方法是天然的单例实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有变量都会绑定到模块&lt;/li&gt;
&lt;li&gt;模块只初始化一次&lt;/li&gt;
&lt;li&gt;import 机制是线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# World.py&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Sun&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;Sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rise&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;Sun&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c"&gt;# 在入口文件main.py里导入&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;World&lt;/span&gt;
&lt;span class="n"&gt;World&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Borg模式：“实例的唯一性”本身是有问题的，实际更关注的是实例的状态，只要所有的实例共享状态（可以简单理解为属性）、行为（简单理解为方法）一致就可以了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Borg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;__shared_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__dict__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__shared_state&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议51：用mixin模式让程序更加灵活&lt;/h3&gt;
&lt;p&gt;在理解mixin之前，需要重温下模板方法模式。所谓&lt;strong&gt;模板方法模式&lt;/strong&gt;就是在一个方法中定义一个算法（行为）的骨架，并将一些实现步骤延迟到子类中。可以使子类在不改变算法结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;
&lt;p&gt;每一个类都有一个__bases__属性，它是一个元组，用来存放所有的基类。与其他静态语言不同，Python中的基类在运行中可以动态改变。所以当我们向其中增加新的基类时，这个类就拥有了新的方法，也就是所谓的&lt;strong&gt;混入(mixin)&lt;/strong&gt;。这种动态性的好处就是代码获得了更丰富的扩展功能。可以后期增加基类，就可以增强功能，多么方便！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_teapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;SimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;UseKungfuTeapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_teapot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;KungfuTeapot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;simple_tea_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;coffee_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseCoffeepot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;tea_and_coffee_people&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__bases__&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UseSimpleTeapot&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;UseCoffeepot&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;people&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议52：用发布订阅模式实现松耦合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;发布订阅模式(publis/subscribe或者pub/sub)&lt;/strong&gt;是一种编程模式，消息的发送者不会发送其消息给特定接收者，而是将发布消息分为不同类别直接发布，并不关注订阅者是谁。而订阅者可以对一个或者多个类别感兴趣，且只接收感兴趣的消息，并且不关注是哪个发布者发布的消息。
发布订阅模式的优点是发布者与订阅者松散的耦合，双方不需要知道对方的存在。要实现这个模式需要一个中间代理人，在实现中一般称为Broker，它维护着发布者和订阅者的关系：订阅者把感兴趣的主题告诉它，而发布者的信息也通过它路由到各个订阅者处。简单的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Broker.py&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;
&lt;span class="n"&gt;route_table&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;defaultdict&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;
    &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;route_table&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;topic&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
        &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;它的应用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Broker&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;Broker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;greeting&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Broker&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Hello&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;wwt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是简化的实现，blinker和Python-message两个模块提供了更加完备的实现。下面以python-message为例说明。
首先需要安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;message&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;greet&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了sub()/pub()之外，Python-message还支持取消订阅和终止消息传递。&lt;/p&gt;
&lt;h3&gt;建议53：用状态模式美化代码&lt;/h3&gt;
&lt;p&gt;所谓&lt;strong&gt;状态模式&lt;/strong&gt;，就是当一个对象的内在状态改变时允许改变其行为，但这个对象看起来像是改变了其类。
状态模式主要用于控制一个对象状态的条件表达式过于复杂的情况，其可把状态的判断逻辑转移到表示不同状态的一系列类中，进而把复杂的判断逻辑简化。
例如，一个人，工作日和周日的日常生活是不同的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;workday&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;work hard&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;weekend&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;play harder!&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;People&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;

&lt;span class="n"&gt;people&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;People&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;xrange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;weekend&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;workday&lt;/span&gt;
        &lt;span class="n"&gt;people&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;day&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过在不同条件下将实例的方法替换掉，就实现了状态模式。&lt;/p&gt;
&lt;p&gt;在网络编程中，需要判断用户是否登录，只有登录后才能调用某些函数，如果每个函数前面都加上if ... raise ... 那么这样代码会很难看。一个解决方法是使用decorator:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ensure_signin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;_signin&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="n"&gt;NeedSignin&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nd"&gt;@ensure_signin&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;do_sth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kw&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是如果需要检查的不仅仅是用户是否登陆，还有其他需求，那么如果在每个函数前面都加上4,5个装饰器，那样也很难看。这时候就可以使用state的状态转移。&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 13 Apr 2015 23:31:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-13:bian-xie-gao-zhi-liang-pythondai-ma-4-she-ji-mo-shi.html</guid><category>Python</category></item><item><title>使Pelican支持LaTex数学公式</title><link>http://www.wengweitao.com/shi-pelicanzhi-chi-latexshu-xue-gong-shi.html</link><description>&lt;p&gt;作为一个技术博客，在写文章的时候，肯定需要经常输入各种公式符号。在之前写一篇文章的时候，发现Pelican默认是不支持编辑数学公式的。之前用过一些在线的markdonw编辑器，都是通过&lt;a href="https://github.com/mathjax/mathjax"&gt;MathJax&lt;/a&gt;来支持在markdown中书写数学公式，而且用起来非常的方便，语法基本和LaTex一样。于是，就找到了一种简单的使Pelican支持LaTex语法的数学公式，在这里分享给大家。&lt;/p&gt;
&lt;h2&gt;如何使Pelican支持渲染数学公式&lt;/h2&gt;
&lt;p&gt;最简单的方法就是使用Pelican的一个插件——&lt;a href="https://github.com/barrysteyn/pelican_plugin-render_math"&gt;pelican_plugin-render_math&lt;/a&gt;。
这个插件可以通过使用MathJax使pelican拥有渲染数学公式的能力，并且同时支持Markdown 和reStructuredText，用起来也非常的方便！&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;在Pelican的安装目录中找到Pelican的配置文件pelicanconf.py，在文件中增加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;PLUGIN_PATH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;u&amp;quot;pelican-plugins&amp;quot;&lt;/span&gt;

&lt;span class="n"&gt;PLUGINS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;render_math&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使插件生效，必须保证插件render_path所在的目录是可以访问的。通常，这个插件同其他插件都一起放在pelican-plugins目录中。&lt;/p&gt;
&lt;p&gt;没错，只要这一步你的pelican网站就可以通过mathjax渲染数学公式了！不需要更改任何模板文件。&lt;/p&gt;
&lt;p&gt;Just use and enjoy!&lt;/p&gt;
&lt;h2&gt;开始使用&lt;/h2&gt;
&lt;p&gt;对于内联的公式，将公式用\&lt;span class="math"&gt;\(...\\)&lt;/span&gt;包含起来，对于需要单独另起一行显示的公式使用\&lt;span class="math"&gt;\(\\)&lt;/span&gt;...\&lt;span class="math"&gt;\(\\)&lt;/span&gt;包含起来。例如：&lt;span class="math"&gt;\(1 + 1 = 2\)&lt;/span&gt; 和
&lt;/p&gt;
&lt;div class="math"&gt;$$1 + 1 = 2$$&lt;/div&gt;
&lt;h3&gt;书写一个质能守恒公式&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nb"&gt;E &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt; mc^&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="math"&gt;$$E=mc^2$$&lt;/div&gt;
&lt;h3&gt;希腊字母&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;\alpha&lt;/span&gt;&lt;span class="nb"&gt;, &lt;/span&gt;&lt;span class="nv"&gt;\beta&lt;/span&gt;&lt;span class="nb"&gt;, ..., &lt;/span&gt;&lt;span class="nv"&gt;\omega&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;\Gamma&lt;/span&gt;&lt;span class="nb"&gt;, &lt;/span&gt;&lt;span class="nv"&gt;\Delta&lt;/span&gt;&lt;span class="nb"&gt;, …, &lt;/span&gt;&lt;span class="nv"&gt;\Omega&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;小写希腊字母：&lt;span class="math"&gt;\(\alpha, \beta, ..., \omega\)&lt;/span&gt;
大写希腊字母：&lt;span class="math"&gt;\(\Gamma, \Delta, …, \Omega\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;上标和下标&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="s"&gt;$&lt;/span&gt;&lt;span class="nb"&gt;x_i^&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="s"&gt;$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上标和下标分别为^ 和 _. 例如：&lt;span class="math"&gt;\(x_i^2\)&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;求和与积分&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\sum&lt;/span&gt;&lt;span class="nb"&gt;_{k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}^{n}&lt;/span&gt;&lt;span class="nv"&gt;\frac&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}{k}&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt; 
&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\sum&lt;/span&gt;&lt;span class="nb"&gt;_{k&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}^n&lt;/span&gt;&lt;span class="nv"&gt;\frac&lt;/span&gt;&lt;span class="nb"&gt;{&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="nb"&gt;}{k}&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt; 
&lt;span class="sb"&gt;$$&lt;/span&gt;&lt;span class="nv"&gt;\int&lt;/span&gt;&lt;span class="nb"&gt;_a^b f&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;x&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;dx&lt;/span&gt;&lt;span class="s"&gt;$$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="math"&gt;$$\sum_{k=1}^{n}\frac{1}{k}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\sum_{k=1}^n\frac{1}{k}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\int_a^b f(x)dx$$&lt;/div&gt;
&lt;p&gt;如果你使用过LaTex那么用起来就非常熟悉了，语法基本和LaTex一样。可以访问 &lt;a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference"&gt;MathJax&lt;/a&gt; 参考更多使用方法。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 10 Apr 2015 19:35:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-10:shi-pelicanzhi-chi-latexshu-xue-gong-shi.html</guid><category>教程</category></item><item><title>求字符的所有组合和所有排列</title><link>http://www.wengweitao.com/qiu-zi-fu-de-suo-you-zu-he-he-suo-you-pai-lie.html</link><description>&lt;blockquote&gt;
&lt;p&gt;昨天看到一道关于求解字符串的排列的问题。如何求出几个字符的所有排列，发现对这种类似的题型还不是很熟练，因此本文对字符的全排列和全组合的问题作下总结，加深自己的理解和记忆，同时也希望能够帮助大家更好的学习和理解该类问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;字符串的排列&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：
输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;：
考虑把这个复杂的问题分解成为小的问题。整个字符串的排列，可以看成两个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，求所有可能出现在第一个位置的字符&lt;/li&gt;
&lt;li&gt;然后，固定第一个字符，求后面所有字符的排列。这个时候仍然把后面的所有字符分成两个部分：后面的第一个字符，以及这个字符之后的所有字符。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析到这里，可以看出这是非常典型的递归。接下来，就可以写出代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;PermutationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;pCh&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;字符串的组合&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;：
不是求字符的所有排列，而是求字符的所有组合呢？还是输入三个字符a、b、c，组合有：a, b, c , ab, ac, bc, abc。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;题目分析&lt;/strong&gt;：
字符串的组合与排列不同，当交换字符串中的两个字符时，虽然能得到两个不同的排列，但却是一个组合。比如ab和ba是两个排列，但是一个组合。
假设输入n个字符，则这n个字符能构成长度为1的组合、长度为2的组合、......、长度为n的组合。在求n个字符组成长度为m的组合的时候，与字符串全排列的求解思想类似，我们可以把这n个字符分为两个部分：第一个字符和剩余的其他所有的n-1个字符。这个时候可以分为两种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果组合里包含第一个字符，则从所有剩余n-1个字符里选取&lt;strong&gt;m-1&lt;/strong&gt;个字符；&lt;/li&gt;
&lt;li&gt;如果组合里不包含第一个字符，则下一步在剩余的n-1个字符选取&lt;strong&gt;m&lt;/strong&gt;个字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，我们可以把求n个字符组成长度为m的组合问题分解成两个子问题，分别求n-1个字符串长度为m-1的组合，以及求n-1个字符的长度为m的组合。这两个子问题都可以用递归方式解决。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Combination&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;iterator&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;iter&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// n-1个字符串中，选取number-1个字符&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// n-1个字符串中，选取number个字符&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop_back&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CombinationCore&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Cobination函数中，分别求解字符个数为1到n的所有组合；使用一个vector容器来保存放进组合中的字符。&lt;/p&gt;
&lt;p&gt;另外，还有另一种思路可以求解——基于位图。
假设一共有n个字符，则可能的组合结果共有&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;种。
以输入3个字符a、b、c为例：
3个字符，可以用3个位来表示，从右到左的每一位分别用来代表a、b、c，该位为1表示取该元素，该位为0表示不取该元素。例如如组合a表示为001，组合b表示为010，组合ac表示为101，组合abc表示为111，而000是没有意义的，所以总共的结果就是&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;种。&lt;/p&gt;
&lt;p&gt;因此，我们可以从值1开始循环到&lt;span class="math"&gt;\(2^n - 1\)&lt;/span&gt;，输出每个值所代表的组合即可。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Combination2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// 依次输出值1到2^n-1所代表值的组合&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// 判断第j位是否为1&lt;/span&gt;
            &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;相关题目&lt;/h2&gt;
&lt;h3&gt;求正方体对面顶点和相等数组&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：
输入一个含有8个数字的数组，判断有没有可能把这8个数字分别放到正方体的8个顶点上，使得正方体上三组相对的面上的4个顶点的和都相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析&lt;/strong&gt;：
我们可以求出这8个数字的全排列，然后从中找出是否符合题目条件的排列。即先得到a1、a2、a3、a4、a5、a6、a7和a8这8个数字的所有排列，然后判断有没有某个排列符合条件：&lt;/p&gt;
&lt;div class="math"&gt;$$a1 + a2 + a3 + a4 = a5 + a6 + a7 + a8$$&lt;/div&gt;
&lt;div class="math"&gt;$$a1 + a3 + a5 + a7 = a2 + a4 + a6 +a8$$&lt;/div&gt;
&lt;div class="math"&gt;$$a1 + a2 + a5 + a6 = a3 + a4 + a7 + a8$$&lt;/div&gt;
&lt;p&gt;&lt;img alt="cubic" src="./imgs/cube.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum4&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum5&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;nums&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sum1&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum2&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sum3&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum4&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sum5&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;sum6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;CubicEqualExist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IsEqual&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
            &lt;span class="n"&gt;CubicEqualExist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;numbers&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;八皇后问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;：
在8 X 8的国际象棋上摆放八个皇后，使其不能相互攻击，即任意两个皇后不得处于同一行，同一列或者同一对角线上，求出所有符合条件的摆法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题分析&lt;/strong&gt;：
任意两个皇后不得处于同一行，由此可得每个皇后都单独占据一行。我们可以定义一个数组ColumnIndex[8]，其中ColumnIndex[i]表示处在第i行位置的那个皇后对应在ColumnIndex[i]列，例如ColumnIndex&lt;a href="http://book.douban.com/subject/6966465/"&gt;1&lt;/a&gt; = 3 表示处在第1行的皇后在第3列上。
接下来，分别用0~7这8个数字对ColumnIndex进行初始化。注意，此时所有的皇后不同行也不同列。
因此，我们只需要对ColumnIndex数组进行全排列，判断每一个排列所对应的8个皇后的位置是否在对角线上即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;IsRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                                                                                    
                &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IsRight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EightQueens&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="n"&gt;Permutation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ColumnIndex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;References:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://book.douban.com/subject/6966465/"&gt;剑指offer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 10 Apr 2015 14:41:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-10:qiu-zi-fu-de-suo-you-zu-he-he-suo-you-pai-lie.html</guid><category>面试题</category></item><item><title>编写高质量Python代码（3）——库</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-3-ku.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Python具有非常丰富的库，这篇文章介绍了常用库的使用和技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议36：掌握字符串的基本用法&lt;/h3&gt;
&lt;p&gt;有个小技巧：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;SELECT *&amp;#39;&lt;/span&gt;
         &lt;span class="s"&gt;&amp;#39;FROM atable &amp;#39;&lt;/span&gt;
         &lt;span class="s"&gt;&amp;#39;WHERE afield=&amp;quot;value&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="n"&gt;s&lt;/span&gt;
 &lt;span class="s"&gt;&amp;#39;SELECT *FROM atable WHERE afield=&amp;quot;value&amp;quot;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上利用了Python遇到未闭合的小括号时会自动将多行代码拼接为一行和把相邻的两个字符串字面量拼接在一起的特性做到的。（而如果使用三个引号会把换行符和空格都当做字符串的一部分）&lt;/p&gt;
&lt;p&gt;Python字符串分为str和unicode两种。当需要判断变量是否为字符串时，应该使用&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;basestring&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python提供了很多判定字符串的函数如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;isalnum()&lt;/li&gt;
&lt;li&gt;isalpha() &lt;/li&gt;
&lt;li&gt;isdigit() &lt;/li&gt;
&lt;li&gt;islower()&lt;/li&gt;
&lt;li&gt;isupper()&lt;/li&gt;
&lt;li&gt;isspace()&lt;/li&gt;
&lt;li&gt;istitle() 首字母大写&lt;/li&gt;
&lt;li&gt;startswith(prefix, start, end)&lt;/li&gt;
&lt;li&gt;endswith&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查找和替换：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count(sub, start, end )&lt;/li&gt;
&lt;li&gt;find  找不到返回-1&lt;/li&gt;
&lt;li&gt;index   找不到返回ValueError&lt;/li&gt;
&lt;li&gt;rfind&lt;/li&gt;
&lt;li&gt;rindex&lt;/li&gt;
&lt;li&gt;replace(old, new, count)  最多替换count次。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分切与连接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;partition(seq), rpartition, : 返回一个3个元素的元组对象。sep左端，sep，sep右端&lt;/li&gt;
&lt;li&gt;splitlines&lt;/li&gt;
&lt;li&gt;split(sep, maxsplit), rsplit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意split()与split(' ')不同&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39; hello   world!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39; hello   world!&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;split&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world!&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;变形：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower() &lt;/li&gt;
&lt;li&gt;upper() &lt;/li&gt;
&lt;li&gt;capitalize() &lt;/li&gt;
&lt;li&gt;swapcase() &lt;/li&gt;
&lt;li&gt;title()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;填充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;center  居中&lt;/li&gt;
&lt;li&gt;ljust   左对齐&lt;/li&gt;
&lt;li&gt;rjust   右对齐)&lt;/li&gt;
&lt;li&gt;zfill   字符0填充&lt;/li&gt;
&lt;li&gt;expandtabs 制表符替换为适当数量的空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议37：按需选择sort()或者sorted()&lt;/h3&gt;
&lt;h4&gt;1.相比sort, sorted()的使用更为广泛。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;iterable&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;cmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;reverse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;cmp：用户定义的任何比较函数，函数的参数为两个可比较的元素（来自iterable或者list），返回-1, 0, 1，当第一个参数小于第二个参数则返回负数。
key：带一个参数的函数，用来为每个元素提取比较值，默认为None
reverse：排序结果是否反转&lt;/p&gt;
&lt;p&gt;sorted可以作用于任意迭代对象，而sort()一般作用于列表。如sort((1,3,2))就抛出异常。&lt;/p&gt;
&lt;h4&gt;2.当排序对象为列表时，二者适合的场景不同。&lt;/h4&gt;
&lt;p&gt;sorted 返回一个排序后的列表，原有列表保持不变；而sort直接修改原有的列表，函数返回为None。
sort函数不需要复制原有列表，消耗内存较少，效率也比较高。&lt;/p&gt;
&lt;h4&gt;3.传入参数key比参数cmp效率高。&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;timeit&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sorted(xs, key=lambda x:x[1])&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xs=range(100);xs=zip&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;).timeit(10000)    # 比较x[1]位置的值&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.18814091348924744&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stmt&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sorted(xs, cmp=lambda a,b: cmp(a[1],b[1]))&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;setup&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;xs=rang&lt;/span&gt;
&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;).timeit(10000)  # 比较x[1]位置的值   cmp(x,y)当x &amp;lt; y - &amp;gt; -1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.2789308104491681&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;4.sorted功能非常强大，可以方便对不同数据结构进行排序。&lt;/h4&gt;
&lt;p&gt;①对字典进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;phonebook&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Linda&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;7750&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;9345&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Carol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;5834&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;operator&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;sorted_pb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phonebook&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;sorted_pb&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Carol&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;5834&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Linda&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;7750&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;9345&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;itemgetter获得指定位置的值。&lt;/p&gt;
&lt;p&gt;②多维list排序。对多个字段进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;gameresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;95.00&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Alan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mf"&gt;86.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mandy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;82.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;A&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;], [&amp;#39;&lt;/span&gt;&lt;span class="n"&gt;Rob&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;, 86, &amp;#39;&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;]]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gameresult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Mandy&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;82.5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;95.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;A&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Alan&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;86.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;C&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Rob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;86&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先按等级，等级相同则按照分数高低排序。&lt;/p&gt;
&lt;p&gt;③字典中混合list排序。
字典中的key或者值为列表，需要对列表中的某个位置的元素进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;mydict&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s"&gt;&amp;#39;Zhang&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="s"&gt;&amp;#39;Weng&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mydict&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;lambda&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Weng&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;W&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Zhang&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;E&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Li&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;M&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;])]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;iteritems()返回的是（k，v），传入到函数中;  itemgetter(1)(v)取得v的第一个元素。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;B&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;F&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;slice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;))(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;ABCDEFG&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s"&gt;&amp;#39;CDEFG&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;④List中混合字典排序
列表中每一个元素都为字典，需要针对字典的多个key值进行排序。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;gameresult&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Bob&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wins&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;losses&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;75.00&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;        &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wwt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wins&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;losses&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gameresult&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;itemgetter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rating&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
&lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;losses&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Bob&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rating&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;75.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;losses&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wwt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;rating&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;wins&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;99&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;按key为rating、name排序&lt;/p&gt;
&lt;h3&gt;建议38：使用copy模块深拷贝对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;copy&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="c"&gt;#浅拷贝&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;41&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;44&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;deepcopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;#深拷贝&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;49&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;51&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;51&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;浅拷贝仅仅拷贝了对象的地址而不对对应地址所指向的具体内容进行拷贝。&lt;/p&gt;
&lt;h3&gt;建议39：使用Counter进行计数统计&lt;/h3&gt;
&lt;p&gt;计数统计有多重方法如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用dict&lt;/li&gt;
&lt;li&gt;使用defaultdict&lt;/li&gt;
&lt;li&gt;使用set和list&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;some_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;count_set&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;count_list&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;count_set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;countlist&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有更优雅地就是使用collections.Counter：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;52&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;some_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;54&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用elements可以获取key值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;elements&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;43&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;656&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用most_common找出前N个频率最高的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;most_common&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;57&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当访问不存在的元素时，返回的是0，而不是KeyError:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;some_data&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;update和subtract:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;58&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;success&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;60&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sucessfully&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# 累加而不是替换&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;61&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;63&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subtract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;successfully&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;64&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;s&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;u&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;l&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;y&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;关于Counter的更深入应用，可以阅读我的另一篇&lt;a href="http://www.wengweitao.com/pythonrong-qi-counterde-shi-yong.html"&gt;文章&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;建议40：深入掌握ConfigParser&lt;/h3&gt;
&lt;p&gt;配置文件的意义在于用户不需要修改代码，就可以改变应用程序的行为。
ConfigParser有几个地方需要提一下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;getboolean函数，根据一定的规则将配置项的值转换为布尔值。
[section1]
option1=0
当调用getboolean('section1','option1')时，返回的值是False。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置项的查找规则。
有一个[DEFAULT]节，当读取的配置项不在指定的节里时，会在[DEFAULT]节中查找。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持字符串格式化的类似语法&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;DEFAULT&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;conn_str&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dnb&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pw&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="o"&gt;/%&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;db&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="n"&gt;dbn&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;
&lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;
&lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3306&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;db1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;pw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ppp&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;exmaple&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;db2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;span class="n"&gt;pw&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ccc&lt;/span&gt;
&lt;span class="n"&gt;db&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;ConfigParser&lt;/span&gt;
&lt;span class="n"&gt;conf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ConfigParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;foramt.conf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;db1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;conn_str&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上配置可以根据不同配置获取不同数据库配置相应的连接字符串。&lt;/p&gt;
&lt;h3&gt;建议41：使用argparse处理命令行参数&lt;/h3&gt;
&lt;p&gt;Pythonista有好几种方案，标准库中留下来的getopt, optparse和argparse。
其中argparse是最强大的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;argparse&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;66&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;argparse&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ArgumentParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;--output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;67&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;_StoreAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-o&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;--output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;output&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;No&lt;/span&gt;
&lt;span class="n"&gt;ne&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;68&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;verbose&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;store_true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;68&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;_StoreTrueAction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;option_strings&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-v&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;verbose&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nargs&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;const&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;choices&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metavar&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;69&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Namespace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;verbose&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在又出现了docopt，比argparse更先进更易用的命令行参数处理器。（但是，还不是标准库的一部分）&lt;/p&gt;
&lt;h3&gt;建议42：使用pandas处理大型CSV文件&lt;/h3&gt;
&lt;p&gt;CSV(Comma Seperated Values)作为一种逗号分隔型值的纯文本格式文件，实际中经常用到。Python提供了处理csv的API：&lt;/p&gt;
&lt;p&gt;1.reader( csvfile, dialect='excel', fmtparam  ) 用于csv文件的读取，返回reader对象。当dialect设置为excel时，默认Dialect值如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;excel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Dialect&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;delimiter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 单个字符，用于分隔字段，常见的有, | ;&lt;/span&gt;
    &lt;span class="n"&gt;quotechar&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;quot;&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;# 用于对特殊符号加引号&lt;/span&gt;
    &lt;span class="n"&gt;doublequote&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# quotechar出现时候表现形式&lt;/span&gt;
    &lt;span class="n"&gt;skipinitialspace&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# true是delimiter后面的空格会忽略&lt;/span&gt;
    &lt;span class="n"&gt;lineterminator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\r\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;  &lt;span class="c"&gt;#行结束符&lt;/span&gt;
    &lt;span class="n"&gt;quoting&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QUOTE_MINIMAL&lt;/span&gt; &lt;span class="c"&gt;# 是否在字段前加引号&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;2.csv.writer(csvfile, dialect=‘excel’, **fmtparams)用于写入CSV文件，参数同上。&lt;/p&gt;
&lt;p&gt;3.csv.DictReader(csvfile, fieldnames=None, restkey=None, restval=None, dialect="excel", &lt;em&gt;args, &lt;/em&gt;*kwds)
同reader方法类似，不同的是把信息映射到一个字典中去。&lt;/p&gt;
&lt;p&gt;4.csv.DictWriter(csvfile, fieldnames, restval='', extrasaction='raise', dialect='excel', &lt;em&gt;args, &lt;/em&gt;*kwds)用于支持字典写入。&lt;/p&gt;
&lt;p&gt;CSV模块使用非常方便(import csv)，但如果要处理的CSV文件大小上百MB或者几个GB，那么csv模块就应付不来了。
下面做一个实验，临时创建一个1GB的CSV文件并将其加载到内存中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;large.csv&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;wb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;14&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;seek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1073741824&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c"&gt;# 创建大文件的技巧&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;15&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\0&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;large.csv&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;st_size&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="il"&gt;1073741824L&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;19&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;large.csv&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;csvfile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="n"&gt;mycsv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;csv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;reader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;csvfile&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;delimiter&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;     &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;mycsv&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;         &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;row&lt;/span&gt;
   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行后会出现MemoryError。&lt;/p&gt;
&lt;p&gt;所以应该使用pandas。其支持两种数据结构——Series和DataFrame是数据处理的基础。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Series:是一种类似数组的带索引的一维数据结构。通过obj.values()和obj.index()可以分别获取值和索引。&lt;/li&gt;
&lt;li&gt;DataFrame：类似一个二维数据结构，支持行和列的索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;pandas中处理csv文件的函数主要为read_csv()和to_csv()，前者读取csv文件内容并返回DataFrame,后者则相反。
①可以指定读取部分列和文件的行数
②设置CSV文件与excel兼容
③对文件进行分块处理并返回一个可迭代的对象
④当文件格式相似的时候，支持多个文件合并处理。&lt;/p&gt;
&lt;p&gt;pandas处理非常灵活，而且底层使用Cython实现速度较快，在专业的数据处理与分析领域，如金融等行业已经得到广泛应用。&lt;/p&gt;
&lt;h3&gt;建议43：一般情况下使用ElementTree解析XML&lt;/h3&gt;
&lt;p&gt;xml.dom.minidom和xml.sax是Python解析XML文件最为人们熟知的两个模块了。从Python2.5开始ElementTree成为标准模块，cElementTree是Cython实现，速度更快，消耗内存更少，实际使用应尽量使用cElementTree. 具有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用简单。每一个元素的属性以字典形式表示&lt;/li&gt;
&lt;li&gt;内存消耗明显低于DOM解析。避免将整个XML文件加载到内存中&lt;/li&gt;
&lt;li&gt;支持XPath查询&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果XML文件在GB级别，那么第三方的lxml是更好的选择。&lt;/p&gt;
&lt;p&gt;ElementTree主要方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;getroot()&lt;/li&gt;
&lt;li&gt;find(match)&lt;/li&gt;
&lt;li&gt;findall(match)&lt;/li&gt;
&lt;li&gt;findtext(match, default=None)&lt;/li&gt;
&lt;li&gt;iter(tag)&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;xml.etree.ElementTree&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;ET&lt;/span&gt;
&lt;span class="n"&gt;tree&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ET&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ElementTree&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test.xml&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;root&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getroot&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tag&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;findall&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;system/purpose&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议44：理解模块pickle优劣&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;序列化的场景很常见&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在磁盘上保存当前程序的状态数据以便重启的时候能够重新加载&lt;/li&gt;
&lt;li&gt;多用户或者分布式操作系统中数据结构的网络传输时，可以将数据序列化后发送给一个可信网络对端，接收后反序列化后恢复相同的对象。&lt;/li&gt;
&lt;li&gt;session和cache的存储等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;序列化&lt;/strong&gt;：简单地说就是把内存中数据结构在不丢失其身份和类型信息的情况下转成对象的文本或者二进制表示的过程。对象序列化后的形式经过反序列化过程应该能够恢复为原有的对象。
Python有很多支持序列化的模块，如pickle，json，marshal和shelve等。&lt;/p&gt;
&lt;p&gt;pickle是最通用的序列化模块。它的C语言实现为cPickle，其速度为pickle的1000倍。
pickle最主要的两个函数时dump()和load()，分别进行序列化和反序列化。&lt;/p&gt;
&lt;p&gt;pickle.dump(obj, file, protocol )序列化数据到一个文件描述符，obj表示需要序列化的对象
load(file): 反序列化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;cPickle&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;pickle&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;21&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;my_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Python&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;type&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Language&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;version&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;2.7.5&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;22&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;picklefile.dat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 打开要写入的文件&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my_data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;24&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;picklefile.dat&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;rb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;26&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;load&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;27&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;version&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;2.7.5&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Language&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;28&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;fp&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;pickle具有的特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接口简单，容易使用。dump和load&lt;/li&gt;
&lt;li&gt;存储格式具有通用性。能够被不同平台的Python解析器共享。&lt;/li&gt;
&lt;li&gt;支持数据类型广泛&lt;/li&gt;
&lt;li&gt;pickle模块式可以扩展的。对于不可序列化的对象，如sockets、文件句柄、数据库连接等，可以通过特殊方法__getstate__()和__setstate__()来返回实例在被pickle时的状态。&lt;/li&gt;
&lt;li&gt;能够自动维护对象间的引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pickle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loads&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;36&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;38&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;a1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c"&gt;# 反序列化后对a1对象的修改仍然会影响到b1&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;b1&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;39&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;pickle也有一些限制&lt;/strong&gt;：
- 不能保证操作的原子性。也就是说pickle调用中如果发生异常， 可能部分数据已经保存。
- pickle存在安全性问题。pickle.loads('cmd')
- pickle协议是Python特定的，不同语言兼容性难以保证。&lt;/p&gt;
&lt;h3&gt;建议45：序列化的另一个不错的选择——JSON&lt;/h3&gt;
&lt;p&gt;Python有一系列模块提供对JSON格式的支持，如simplejson, cjson, yajl, ujson, 2.6后又引入了标准库JSON。cjson是用C语言实现，yajl是Cython版本的JSON实现。
simplejson与标准库JSON的区别不大，但更新可能更快，在实际使用中将这两者结合采用如下的import方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;simplejson&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ImportError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; 
    &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;json&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;JSON的常用方法与pickle类似，dump/dumps序列化，load/loads反序列化。 &lt;/p&gt;
&lt;p&gt;相比pickle，json具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用简单，支持多种数据类型。&lt;/li&gt;
&lt;li&gt;名称/ 值对的集合&lt;/li&gt;
&lt;li&gt;值的有序列表&lt;/li&gt;
&lt;li&gt;存储格式可读性更为友好，容易修改。dumps函数提供了一个参数indent使生成的json文件可读性更好，0意味着每个值单独一行；大于0的数字表示使用这个数字的空格来缩进嵌套结构。但这个是以文件大小变大为代价的。&lt;/li&gt;
&lt;li&gt;json支持跨平台跨语言操作，能够轻易被其他语言解析。&lt;/li&gt;
&lt;li&gt;具有较强的扩展性。提供了编码(JSONEncoder)和解码类（JSONDecoder）以便用户对其默认不支持的序列化类型进行扩展。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是Python中标准模块json的性能比pickle稍逊。性能要求高的话，还是选择cPickle。&lt;/p&gt;
&lt;h3&gt;建议46：使用traceback获取栈信息&lt;/h3&gt;
&lt;p&gt;traceback会输出完整的栈信息，有利于开发人员快速找到异常发生时的现场信息。
tracback.print_exc()打印出：错误类型，错误对应的值已经具体的trace信息，包括文件名、具体行号、函数名已经对应的代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;traceback&lt;/span&gt;
&lt;span class="n"&gt;gList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;i&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sorry, out of range&amp;#39;&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;
        &lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;print_exc&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;sorry&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;out&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;
&lt;span class="nb"&gt;list&lt;/span&gt; &lt;span class="nb"&gt;index&lt;/span&gt; &lt;span class="nb"&gt;out&lt;/span&gt; &lt;span class="nx"&gt;of&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;
&lt;span class="nx"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;most&lt;/span&gt; &lt;span class="nx"&gt;recent&lt;/span&gt; &lt;span class="nb"&gt;call&lt;/span&gt; &lt;span class="nb"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nb"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;f&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;g&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;h&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
  &lt;span class="nb"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;trace_back.py&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
    &lt;span class="nx"&gt;print&lt;/span&gt; &lt;span class="nx"&gt;gList&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
IndexError: list index out of range
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议47：使用logging记录日志信息&lt;/h3&gt;
&lt;p&gt;仅仅将栈信息输出到控制台远远不够，更为常见的做法是使用日志保存程序运行过程中的相关信息，如运行时间、描述信息以及错误或者异常发生时候的特定上下文信息。Python自带了logging模块提供了日志功能。&lt;/p&gt;
&lt;p&gt;logger分为5个级别，包含4个主要对象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;logger：程序信息输出的接口，分散在不同代码中，使得程序可以再运行的时候记录相应的信息，并根据设置的日志级别或者filter来决定哪些信息需要输出，并将这些信息方法到其关联的handler。&lt;/li&gt;
&lt;li&gt;handler。处理信息的输出，可以输出到控制台、文件或者网络。&lt;/li&gt;
&lt;li&gt;Formatter。决定log信息的格式&lt;/li&gt;
&lt;li&gt;Filter。决定哪些信息需要输出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是一个使用logging的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;traceback&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;logging&lt;/span&gt;
&lt;span class="n"&gt;gList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;d&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;f&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;g&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;e&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basicConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;  &lt;span class="c"&gt;# configure log output formatter&lt;/span&gt;
        &lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;DEBUG&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;filemode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;w&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%(asctime)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(filename)s&lt;/span&gt;&lt;span class="s"&gt;[line:&lt;/span&gt;&lt;span class="si"&gt;%(lineno)d&lt;/span&gt;&lt;span class="s"&gt;] &lt;/span&gt;&lt;span class="si"&gt;%(levelname)s&lt;/span&gt;&lt;span class="s"&gt; &lt;/span&gt;&lt;span class="si"&gt;%(message)s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;[INFO]:calling method g() in f()&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c"&gt;# normal message&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;h&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;i&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;i&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;gList&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Information during calling f():&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;IndexError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sorry, out of range&amp;#39;&lt;/span&gt;
        &lt;span class="c"&gt;#traceback.print_exc()&lt;/span&gt;
        &lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exc_info&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;[ERROR]:Sorry,Exception occured.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;object info:&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Error Type:{0}, Error information:{1}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tv&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;logging&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;traceback&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format_tb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出log到log.txt，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;55&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;684&lt;/span&gt; &lt;span class="nx"&gt;trace_back.py&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;25&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; DEBUG Information during calling f():
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; INFO &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;INFO&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;:calling method g() in f()
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; ERROR &lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;ERROR&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;:Sorry,Exception occured.
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL object info:list index out of range
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL Error Type:&lt;span class="nt"&gt;&amp;lt;type&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="na"&gt;exceptions&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IndexError&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;, Error information:list index out of range
2014-12-11 20:50:55,684 trace_back.py&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;line&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; CRITICAL   File &amp;quot;trace_back.py&amp;quot;, line 27, in &lt;span class="nt"&gt;&amp;lt;module&amp;gt;&lt;/span&gt;
    f()
  File &amp;quot;trace_back.py&amp;quot;, line 14, in f
    return g()
  File &amp;quot;trace_back.py&amp;quot;, line 16, in g
    return h()
  File &amp;quot;trace_back.py&amp;quot;, line 19, in h
    return i()
  File &amp;quot;trace_back.py&amp;quot;, line 22, in i
    print gList&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议48：使用threading模块编写多线程程序&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GIL&lt;/strong&gt;(Global Interpreter Lock)全局解释器锁，是解释器用于同步线程的工具，使得任何时候只有一个线程在运行。GIL的存在使得Python多线程编程暂时无法利用多处理器的优势。但这不意味着我们要放弃多线程。
对于纯Python的代码也许使用多线程不能提高运行效率，但是以下几种情况，多线程仍然是比较好的解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等待外部资源返回&lt;/li&gt;
&lt;li&gt;建立反应灵活的用户界面&lt;/li&gt;
&lt;li&gt;多用户应用程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python为多线程编程提供了两个模块：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;thread&lt;/li&gt;
&lt;li&gt;threading&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;thread模块提供了多线程的底层支持模块，以低级方式来处理和控制线程，使用起来较为复杂；
threading模块基于thread进行封装，将线程操作对象化，在语言层面提供了丰富的特性。
因此，实际使用中推荐优先使用threading模块，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;threading对同步原语的支持更为完善和丰富。如有Lock指令锁，还支持条件变量condition、信号量Semaphore等。&lt;/li&gt;
&lt;li&gt;threading模块在主线程与子线程的交互上更为友好。threading中的join()方法能够阻塞当前上下文环境的线程，直到调用此方法的线程终止或者到达指定的timeout。利用该方法可以方便地控制主线程与子线程以及子线程之间的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; delay for &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;This is thread &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; on line &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;End of thread &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Thread 1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Thread 2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Wait t1 to end&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;End of main&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：
&lt;img alt="threading_join" src="./imgs/threading_join.png" /&gt;&lt;/p&gt;
&lt;p&gt;主线程main上使用t1的join()方法，主线程会等待t1结束后才继续运行后面的语句。线程t2的启动在join语句之后，t2一直等到t1退出后才会开始运行。&lt;/p&gt;
&lt;p&gt;thread模块不支持守护进程。thread模块在主线程退出后，所有的主线程无论是否还在工作，都会被强制结束。threading模块，支持守护进程，可以通过setDaemon()来设定线程的daemon属性，当daemon属性为True时，表面主线程的退出可以不用等待子线程的完成（默认为False，即所有子线程结束后主线程才会结束）&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;time&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;I will calculate square of &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt; after delay for &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;calculate begins...&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;target&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;myfunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDaemon&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;isDaemon&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="threading" src="./imgs/threading.png" /&gt;&lt;/p&gt;
&lt;h3&gt;建议49：使用Queue使多线程编程更安全&lt;/h3&gt;
&lt;p&gt;线程间的同步互斥，线程间数据的共享等这些都是涉及线程安全要考虑的问题。&lt;/p&gt;
&lt;p&gt;Python中的Queue提供了三种队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queue.Queue(maxsize)。FIFO&lt;/li&gt;
&lt;li&gt;Queue.LifoQueue(maxsize)&lt;/li&gt;
&lt;li&gt;Queue.PriorityQueue(maxsize)。优先级队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三种队列支持以下几种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queue.qsize()&lt;/li&gt;
&lt;li&gt;empty()&lt;/li&gt;
&lt;li&gt;full()&lt;/li&gt;
&lt;li&gt;put(item, block, timeout  ):往队列中添加item元素，block为False的时候，若队列满则抛出Full异常，若block为True，则队列满一直等待有空位置，知道timeout时间后抛出异常。&lt;/li&gt;
&lt;li&gt;put_nowait(item): 相当于block为False的put方法&lt;/li&gt;
&lt;li&gt;get(block, timeout ): 与put类似的用法&lt;/li&gt;
&lt;li&gt;get_nowait()&lt;/li&gt;
&lt;li&gt;task_done()：发送信号表面入列任务已经完成，经常在消费者线程中使用&lt;/li&gt;
&lt;li&gt;join()：阻塞直到队列中所有元素处理完毕&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Queue实现了多个生产者和多个消费者的队列，当多线程之间需要信息安全交换的时候特别有用。
需要注意的是Queue与collections.deque中的队列是不同的，前者主要用于不同线程之间的通信，它内部实现了线程的锁机制；而后者是数据结构上的概念。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Queue&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;threading&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;urllib2&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DownloadThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;threading&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;begin download&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;...&amp;quot;&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;download_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;task_done&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; download completed!&amp;quot;&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;download_file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;urlhandler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urllib2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;urlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;fname&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;basename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;.html&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;chunk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;urlhandler&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;chunk&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;
                &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;chunk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;urls&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.baidu.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;http://www.google.com&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="s"&gt;&amp;quot;http://www.wengweitao.com&amp;quot;&lt;/span&gt;
            &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Queue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DownloadThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;urls&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c"&gt;# wait for the queue to finish&lt;/span&gt;
    &lt;span class="n"&gt;queue&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果：&lt;/p&gt;
&lt;h2&gt;&lt;img alt="threading_queue" src="./imgs/threading_queue.png" /&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 08 Apr 2015 22:58:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-08:bian-xie-gao-zhi-liang-pythondai-ma-3-ku.html</guid><category>Python</category></item><item><title>Python容器——Counter的使用</title><link>http://www.wengweitao.com/pythonrong-qi-counterde-shi-yong.html</link><description>&lt;blockquote&gt;
&lt;p&gt;Counter是Python标准库提供的一个非常有用的容器，可以用来对序列中出现的各个元素，进行计数。这篇文章中，利用Counter来实现多元集合(MultiSets)、概率质量函数(PMFs)以及贝叶斯假设。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Python代码中使用Counter，只需从collections包引入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;collections&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;1.判断两个字符串是否由相同的字母集合调换顺序而成的（anagram）&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_anagram&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Checks whether the words are anagrams.&lt;/span&gt;

&lt;span class="sd"&gt;    word1: string&lt;/span&gt;
&lt;span class="sd"&gt;    word2: string&lt;/span&gt;

&lt;span class="sd"&gt;    returns: boolean&lt;/span&gt;
&lt;span class="sd"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Counter如果传入的参数是字符串，就会统计字符串中每个字符出现的次数，如果两个字符串由相同的字母集合颠倒顺序而成，则它们Counter的结果应该是一样的。&lt;/p&gt;
&lt;h3&gt;2.多元集合(MultiSets)&lt;/h3&gt;
&lt;p&gt;multiset是相同元素可以出现多次的集合，Counter可以非常自然地用来表示multiset。并且可以将Counter扩展，使之拥有set的一些操作如is_subset。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Multiset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A multiset is a set where elements can appear more than once.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;is_subset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Checks whether self is a subset of other.&lt;/span&gt;

&lt;span class="sd"&gt;        other: Multiset&lt;/span&gt;

&lt;span class="sd"&gt;        returns: boolean&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;

    &lt;span class="c"&gt;# map the &amp;lt;= operator to is_subset&lt;/span&gt;
    &lt;span class="n"&gt;__le__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;is_subset&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;3.概率质量函数&lt;/h3&gt;
&lt;p&gt;概率质量函数（probability mass function，简写为pmf）是离散随机变量在各特定取值上的概率。可以利用Counter表示概率质量函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Counter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;A Counter with probabilities.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Normalizes the PMF so the probabilities add to 1.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;total&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;values&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;total&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__add__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Adds two distributions.&lt;/span&gt;

&lt;span class="sd"&gt;        The result is the distribution of sums of values from the&lt;/span&gt;
&lt;span class="sd"&gt;        two distributions.&lt;/span&gt;

&lt;span class="sd"&gt;        other: Pmf&lt;/span&gt;

&lt;span class="sd"&gt;        returns: new Pmf&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;pmf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob1&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob2&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="n"&gt;pmf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;key2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;prob1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;prob2&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;pmf&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__hash__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Returns an integer hash value.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__eq__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;render&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Returns values and their probabilities, suitable for plotting.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;zip&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;normalize: 归一化随机变量出现的概率，使它们之和为1&lt;/p&gt;
&lt;p&gt;add: 返回的是两个随机变量分布两两组合之和的新的概率质量函数&lt;/p&gt;
&lt;p&gt;render: 返回按值排序的(value, probability)的组合对，方便画图的时候使用&lt;/p&gt;
&lt;p&gt;下面以骰子（ps: 这个竟然念tou子。。。）作为例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;one die&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pmf({1: 0.16666666666666666, 2: 0.16666666666666666, 3: 0.16666666666666666, 4: 0.16666666666666666, 5: 0.16666666666666666, 6: 0.16666666666666666})&lt;/p&gt;
&lt;p&gt;使用add，我们可以计算出两个骰子和的分布：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;d6_twice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;d6&lt;/span&gt;
&lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;two dices&amp;#39;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;借助numpy.sum，我们可以直接计算三个骰子和的分布：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;numpy&lt;/span&gt; &lt;span class="kn"&gt;as&lt;/span&gt; &lt;span class="nn"&gt;np&lt;/span&gt;
&lt;span class="n"&gt;d6_thrice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;np&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;d6_thrice&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;three dices&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后可以使用render返回结果，利用matplotlib把结果画图表示出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d6_twice&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d6_thrice&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;
    &lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;render&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;plot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;xs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ys&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linewidth&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alpha&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;0.5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xlabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Total&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ylabel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Probability&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;legend&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;pyplot&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果如下：
&lt;img alt="pmf_results" src="./imgs/pmf.png" /&gt;&lt;/p&gt;
&lt;h3&gt;4.贝叶斯统计&lt;/h3&gt;
&lt;p&gt;我们继续用掷骰子的例子来说明用Counter如何实现贝叶斯统计。现在假设，一个盒子中有5种不同的骰子，分别是：4面、6面、8面、12面和20面的。假设我们随机从盒子中取出一个骰子，投出的骰子的点数为6。那么，取得那5个不同骰子的概率分别是多少？&lt;/p&gt;
&lt;p&gt;（1）首先，我们需要生成每个骰子的概率质量函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;make_die&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num_sides&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num_sides&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;d&lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;num_sides&lt;/span&gt;
    &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;


&lt;span class="n"&gt;dice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;make_die&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（2）接下来，定义一个抽象类Suite。Suite是一个概率质量函数表示了一组假设(hypotheses)及其概率分布。Suite类包含一个bayesian_update函数，用来基于新的数据来更新假设(hypotheses)的概率。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Suite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Pmf&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Map from hypothesis to probability.&amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Performs a Bayesian update.&lt;/span&gt;

&lt;span class="sd"&gt;        Note: called bayesian_update to avoid overriding dict.update&lt;/span&gt;

&lt;span class="sd"&gt;        data: result of a die roll&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;like&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;likelihood&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;like&lt;/span&gt;

        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中的likelihood函数由各个类继承后，自己实现不同的计算方法。&lt;/p&gt;
&lt;p&gt;（3）定义DiceSuite类，它继承了类Suite。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;DiceSuite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Suite&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;likelihood&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot;Computes the likelihood of the data under the hypothesis.&lt;/span&gt;

&lt;span class="sd"&gt;        data: result of a die roll&lt;/span&gt;
&lt;span class="sd"&gt;        hypo: Die object&lt;/span&gt;
&lt;span class="sd"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hypo&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;并且实现了likelihood函数，其中传入的两个参数为：
data: 观察到的骰子掷出的点数，如本例中的6
hypo: 可能掷出的那个骰子&lt;/p&gt;
&lt;p&gt;（4）将第一步创建的dice传给DiceSuite，然后根据给定的值，就可以得出相应的结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DiceSuite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;

&lt;span class="n"&gt;d4&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="mf"&gt;0.392156862745&lt;/span&gt;
&lt;span class="n"&gt;d8&lt;/span&gt; &lt;span class="mf"&gt;0.294117647059&lt;/span&gt;
&lt;span class="n"&gt;d12&lt;/span&gt; &lt;span class="mf"&gt;0.196078431373&lt;/span&gt;
&lt;span class="n"&gt;d20&lt;/span&gt; &lt;span class="mf"&gt;0.117647058824&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正如，我们所期望的4个面的骰子的概率为0（因为4个面的点数只可能为0~4），而6个面的和8个面的概率最大。
现在，假设我们又掷了一次骰子，这次出现的点数是8，重新计算概率：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bayesian_update&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;sorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dice_suite&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;items&lt;/span&gt;&lt;span class="p"&gt;()):&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;die&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;prob&lt;/span&gt;


&lt;span class="n"&gt;d4&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d6&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;
&lt;span class="n"&gt;d8&lt;/span&gt; &lt;span class="mf"&gt;0.623268698061&lt;/span&gt;
&lt;span class="n"&gt;d12&lt;/span&gt; &lt;span class="mf"&gt;0.277008310249&lt;/span&gt;
&lt;span class="n"&gt;d20&lt;/span&gt; &lt;span class="mf"&gt;0.0997229916898&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在可以看到6个面的骰子也被排除了。8个面的骰子是最有可能的。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;以上的几个例子，展示了Counter的用处。实际中，Counter的使用还比较少，如果能够恰当的使用起来将会带来非常多的方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;：
Using Counters : http://nbviewer.ipython.org/github/AllenDowney/PythonCounterPmf/blob/master/PythonCounterPmf.ipynb&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 08 Apr 2015 14:52:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-08:pythonrong-qi-counterde-shi-yong.html</guid><category>Python</category></item><item><title>编写高质量Python代码（2）</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-2.html</link><description>&lt;blockquote&gt;
&lt;p&gt;这篇文章基础语法出发讲述Python的使用技巧和注意事项&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议8： 利用assert语句来发现问题&lt;/h3&gt;
&lt;p&gt;assert语句主要为调试程序服务，能够快速方便地检查程序的异常或者发现不恰当的输入等，防止意想不到的情况出现。
基本语法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;expression1&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;,&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;expression2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; 
&lt;span class="c"&gt;#assert x == y, &amp;quot;not equals&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中计算expressi1的值若为False则会引发一个AssertionError，expression是可选的，用来传递具体的异常信息。&lt;/p&gt;
&lt;p&gt;另外，需要注意的是断言是对程序的性能有一定的影响，禁用断言的方法是运行时加上 -O标志。&lt;/p&gt;
&lt;h3&gt;建议9： 交换值时不推荐使用中间变量&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;timeit&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;temp = x; x = y; y = temp&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;x = 2; y = 3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.054762504979284254&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;x, y = y, x&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;x = 2; y = 3&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timeit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;Out&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="mf"&gt;0.02862422937357678&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到第二种方法所耗费的时间更少。这是为什么呢？
一般情况下Python计算表达式的计算顺序是从左到右的，但是遇到&lt;strong&gt;表达式赋值是先计算右边的操作数&lt;/strong&gt;。如表达式exp3, exp4 = exp1, exp2的计算顺序是：exp1, exp2, exp3, exp4。
更深入一点，我们可以通过Python生成的&lt;strong&gt;字节码&lt;/strong&gt;来分析。Python字节码是一种类似汇编指令的中间语言，但是一个字节码并不是对应一个机器指令。我们通过以下dis模块来进行分析：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;dis&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;swap1&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;swap2&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;
    &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
    &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
    &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;swap1对应的字节码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;swap1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="n"&gt;ROT_TWO&lt;/span&gt;
     &lt;span class="mi"&gt;19&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;22&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;28&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;swap2对应的字节码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;swap2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;15&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;21&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;24&lt;/span&gt; &lt;span class="n"&gt;LOAD_FAST&lt;/span&gt;                &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;27&lt;/span&gt; &lt;span class="n"&gt;STORE_FAST&lt;/span&gt;               &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;30&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ROT_TWO是交换两个栈的最顶层元素。
swap2中有更多的load和store操作，耗时更多。&lt;/p&gt;
&lt;h3&gt;建议10： 充分利用Lazy evaluation的特性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;lazy evaluation&lt;/strong&gt;指的是在真正需要执行的时候才计算表达式的值。该特性带来的好处有：&lt;/p&gt;
&lt;h4&gt;1. 避免不必要的计算，带来性能提升&lt;/h4&gt;
&lt;p&gt;if x and y, x为false的情况下y表达式不计算； if x or y, x为true的情况下y不计算。
所以，对于or把最可能为真的放在最前面，二and则应该推后。&lt;/p&gt;
&lt;h4&gt;2. 节省空间，使得无限循环的数据结构成为可能&lt;/h4&gt;
&lt;p&gt;最典型的就是&lt;strong&gt;生成器&lt;/strong&gt;表达式了，通过yield产生所需要的元素。如斐波那契数列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;itertools提供了很多操作的生成器实现的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;itertools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;islice&lt;/span&gt;
 &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;islice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
 &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议11： 理解枚举类型实现的缺陷&lt;/h3&gt;
&lt;p&gt;Python3.4之前并不提供枚举类型，因此需要自己实现枚举类型。实现过程中要注意可能的缺陷，如可能枚举值的重复、无意义的操作等。&lt;/p&gt;
&lt;h3&gt;建议12： 不推荐使用type来进行类型检查&lt;/h3&gt;
&lt;p&gt;基于内建类型扩展的用户自定义类型，type函数并不能准确返回结果。
如： class UserInt(int) 中 type(n) is types.IntType 为 False
在古典类中，任意类的实例的type()返回结果都是type 'instance'。这种情况就会与实际结果大相径庭。&lt;/p&gt;
&lt;p&gt;如果类型有对应的工厂函数，可以使用工厂函数对类型做相应转换，如list(listing)，str(name)等，否则可以使用isinstance()函数来检测。
如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
&lt;span class="nb"&gt;isinstance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,(&lt;/span&gt;&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此可以将以上例子中的print type(n) is types.IntType改为print isinstance(n, int)以获取正确的结果。&lt;/p&gt;
&lt;h3&gt;建议13： 尽量转换为浮点类型后再做除法&lt;/h3&gt;
&lt;p&gt;浮点数也可能是不准确的，因为浮点数的存储规则决定了不是所有的浮点数都能准确表示，有些是不准确，有些是无限接近的。如0.1转换为二进制则为0.000110011001......后面1001无限循环。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mf"&gt;1.5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mf"&gt;0.1&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于i != 1.5这种要尽量避免（可以使用 i &amp;lt;= 1.5）&lt;/p&gt;
&lt;h3&gt;建议14： 警惕eval()的安全漏洞&lt;/h3&gt;
&lt;p&gt;eval()函数将字符串str当成有效的表达式来求值并返回计算结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;sys&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;math&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;ExpCalcBot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your answer is&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;eval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;NameError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Invalid&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Input your expression or enter e to end&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Please enter number or operation. Enter c to complete. :&amp;#39;&lt;/span&gt;
    &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;repr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;ExpCalcBot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputstr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;inputstr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码的功能是根据用户的输入，计算Python表达式的值。假设用户输入:
&lt;strong&gt;import&lt;/strong&gt;("os").system("dir")就会列出当前目录的所有文件，也可以把所有文件都删除：
&lt;strong&gt;import&lt;/strong&gt;("os").system("del * /Q")
虽然可以在globals参数中禁止全局命名空间的访问，但是有经验的入侵者会使用一系列强大的手段，使eval执行某些命令。&lt;/p&gt;
&lt;h3&gt;建议15： 使用enumerate()获取序列迭代的索引和值&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;li&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;li&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;index:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;element:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
&lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sequence&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中sequence可以为序列，如list，set等，也可以是iterator等可以迭代的对象。其实实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
     &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
     &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seq&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
         &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;elem&lt;/span&gt;
         &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;enumerate&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
 &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于字典使用iteritems():&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;personinfo&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;iteritems&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;:&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议16：分清 == 与 is的适用场景&lt;/h3&gt;
&lt;p&gt;is:  object identity（拥有相同的内存地址）
==: equal
另外，在判断内存地址是否相同时，可以使用id(x)查看内存地址&lt;/p&gt;
&lt;h3&gt;建议17：考虑兼容性，尽可能使用Unicode&lt;/h3&gt;
&lt;p&gt;Python内建字符串有两种类型：str和Unicode，它们拥有相同的祖先basestring。
&lt;strong&gt;Unicode&lt;/strong&gt;的实现方式称为Unicode转换格式，简称为&lt;strong&gt;UTF&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;实例1：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;filehandle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;test.txt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中test.txt中的内容为：Python中文测试，文件以UTF-8的形式保存，运行结果会乱码。
在windows系统中本地默认的编码是CP936，它被映射为GBK编码，所以在控制台上直接显示UTF-8字符的时候，两种编码会冲突。UTF-8的编码，被解释成为其他的符号，由此产生了乱码。
解决的方法是使用Unicode作为中介来完成转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;filehandle&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;utf-8&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;gbk&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;decode() : 解码。将其他编码对应的字符串解码成Unicode；
encode(): 编码。将Unicode编码转换为另一种编码。&lt;/p&gt;
&lt;p&gt;另外，有些软件在保存UTF-8的时候，会在文件的最开始的地方插入不可见的字符BOM(0xEF 0xBB 0xBF, 即BOM)，这些不可见字符无法被解析。（BOM是byte order mark说明文件的字节序的）。&lt;/p&gt;
&lt;h4&gt;实例2：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;pytho 中文测试&amp;quot;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;源文件中包含中文字符会抛出异常。
因为&lt;strong&gt;Python中默认的编码是ASCII编码&lt;/strong&gt;，中文字符不是ASCII字符，就出错。
可以使用以下方法对文件的编码进行声明。只需要把下面任何一行加入Python源文件的第一行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# coding=utf-8&lt;/span&gt;
&lt;span class="c"&gt;#!/usr/bin/python&lt;/span&gt;
&lt;span class="c"&gt;# -*- coding: utf-8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Python2.6 之后可以通过import unicode_literals自动将定义的字符识别为Unicode字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;unicode_literals&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;你好时间&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;s&lt;/span&gt;
&lt;span class="s"&gt;u&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\u4f60\u597d\u65f6\u95f4&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议18： 构建合理的包层次来管理module&lt;/h3&gt;
&lt;p&gt;什么是包？简单的说包就是目录，但是除了包含常规的Python文件之外，还包含一个__init__.py文件。同时它允许嵌套。包结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;Package&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Module1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Module2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
    &lt;span class="n"&gt;Subpackage&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;__init__&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
        &lt;span class="n"&gt;Module1&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
        &lt;span class="n"&gt;Module2&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果要调用Subpackage中的Module1：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;Package.Subpackage.Module1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;__init__.py的作用： 使包和普通目录区分；其次可以在该文件中申明模块级别的import语句从而使其变成包级别可见。&lt;/p&gt;
&lt;p&gt;当__init__.py为空时需要使用完整的路径来声明import语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Package.Module1&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是在该文件中添加from Module1 import Test后，可以直接使用:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;Package&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Test&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以在文件中定义__all__变量，控制需要导入的子包或者模块：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;__all__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Module1&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Module2&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Subpackage&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;包的使用能够带来以下便利：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;合理组织代码，便于维护和使用&lt;/li&gt;
&lt;li&gt;能够有效避免名称空间冲突&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 07 Apr 2015 22:39:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-07:bian-xie-gao-zhi-liang-pythondai-ma-2.html</guid><category>Python</category></item><item><title>Python代码格式化工具——YAPF</title><link>http://www.wengweitao.com/pythondai-ma-ge-shi-hua-gong-ju-yapf.html</link><description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/google/yapf"&gt;YAPF&lt;/a&gt;是Google开源的一个工具，可以用来格式化Python代码，使Python代码拥有一致的编程风格，减轻了团队或者个人进行代码风格维护的单调的工作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;介绍&lt;/h3&gt;
&lt;p&gt;之前已经有一些类似的Python代码风格格式化工具如：&lt;a href="https://github.com/hhatto/autopep8"&gt;autopep8&lt;/a&gt;和&lt;a href="https://github.com/spulec/pep8ify"&gt;pep8ify&lt;/a&gt;等。这些工具基于&lt;a href="http://clang.llvm.org/docs/ClangFormat.html"&gt;clang-format&lt;/a&gt;,能够很好的解决大多数pep8报告的格式问题。然而，有些代码虽然遵从了PEP8的编程风格指南，但这并不意味着这些代码看起来就足够好，对于这种问题之前的那些Python代码格式化工具就无能为力了。
YAPF与其他的格式化工具不同，其算法能够把代码重新格式化为符合编程风格的最佳格式，无论原始的代码是否违法了某种指定的编程风格指南。YAPF的最终目标就是通过YAPF格式化后的代码能够与程序员完全遵从编程风格写的代码一样的好。&lt;/p&gt;
&lt;h3&gt;YAPF的使用&lt;/h3&gt;
&lt;h4&gt;1.安装&lt;/h4&gt;
&lt;p&gt;可以直接通过pip进行安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;yapf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;2.使用。&lt;/h4&gt;
&lt;p&gt;安装完成之后，就可以直接在命令行中使用了。
以下是yapf的命令行参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;usage&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;yapf&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[--&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;STYLE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;

&lt;span class="n"&gt;Formatter&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;positional&lt;/span&gt; &lt;span class="k"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="n"&gt;files&lt;/span&gt;

&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="k"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;help&lt;/span&gt;            &lt;span class="err"&gt;显示帮助信息&lt;/span&gt;
  &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt; &lt;span class="n"&gt;STYLE&lt;/span&gt;         &lt;span class="err"&gt;指定需要格式化的编程风格，如&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt;&lt;span class="err"&gt;或者&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="err"&gt;等&lt;/span&gt;
                        &lt;span class="err"&gt;也可以是自定义的设置文件。默认是&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;            &lt;span class="err"&gt;比较格式化后的文件和原文件的区别&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;place&lt;/span&gt;        &lt;span class="err"&gt;直接把格式化的文件更改在源文件上&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;lines&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;END&lt;/span&gt;
                        &lt;span class="err"&gt;指定格式化的行的范围&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;recursive&lt;/span&gt;       &lt;span class="err"&gt;在目录中递归运行&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;3.例子&lt;/h4&gt;
&lt;p&gt;以下是一段非常ugly的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

&lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;927&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello {}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;     &lt;span class="nb"&gt;object&lt;/span&gt;  &lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;   &lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;       &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="o"&gt;*-+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;   &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt;      &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="o"&gt;+-+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用yapf将它格式化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;b&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;c&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;927&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello &amp;#39;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;hello {}&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="o"&gt;-+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;g&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;37&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;-+&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;42&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;好看很多！&lt;/p&gt;
&lt;p&gt;另外，YAPF在格式化的时候仍然有一些问题。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当有一大段内容的时候，我们都习惯分行排列，因为这显然更方便我们阅读。但是，使用YAPF格式化后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;遇到这种情况，YAPF也提供了解决的方法，就是在代码段的后面加上：
 # yapf: disable&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;BAZ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c"&gt;# yapf: disable&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;所以，YAPF是一个非常有用的工具，它可以帮助你将代码变得更加一致、更加容易阅读并且Pythonic。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 07 Apr 2015 15:10:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-07:pythondai-ma-ge-shi-hua-gong-ju-yapf.html</guid><category>Python</category><category>工具</category></item><item><title>编写高质量Python代码（1）</title><link>http://www.wengweitao.com/bian-xie-gao-zhi-liang-pythondai-ma-1.html</link><description>&lt;blockquote&gt;
&lt;p&gt;去年参加了珠海的PyCon大会，幸运地抽中了三本书，其中一本是《编写高质量代码：改善Python程序的91个建议》。本书从多个方面给出了编写高质量Python代码的91个建议，我把每一章的建议都先总结下来，分享给大家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;建议1： 理解Pythonic概念&lt;/h3&gt;
&lt;h4&gt;（1）Pythonic的定义&lt;/h4&gt;
&lt;p&gt;遵循Pythonic的代码看起来像伪代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;less&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="n"&gt;greater&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;
    &lt;span class="n"&gt;pivot&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;less&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;pivot&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greater&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可读性比伪代码还要好！&lt;/p&gt;
&lt;h4&gt;（2）代码风格&lt;/h4&gt;
&lt;p&gt;Pythonic的代码要充分体现Python自身特色。
例如交换两个数(packaging/unpackaging)：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有需要安全关闭文件描述符，可以使用with语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="nb"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;r&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;do_st&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们应当追求充分利用Python的语法，但不应过分追求奇技淫巧，比如利用Slice语法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;abcdef&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;[::&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这是一个实现列表倒序输出的功能，但是如果不熟悉该语法的可能就看不懂，实际上，这个时候更能体现Pythonic的代码是充分利用Python的库里的reversed函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;reversed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;（3）标准库&lt;/h4&gt;
&lt;p&gt;写Pythonic的程序必须对Python的标准库有充分了解，特别是内置函数与内置数据类型。
例如格式化输出字符串,通常的做法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Pythonic的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello %{name}s&amp;#39;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Tom&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尤其是参数多的时候可读性更好。
str.format()是Python最为推荐的字符串格式化方法，当然也是最Pythonic的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;{greet} from {language}.&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;greet&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Hello world&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;language&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Python&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;（4）Python的库或框架&lt;/h4&gt;
&lt;p&gt;公认Flask这个框架式比较Pythonic的。可以仔细阅读这些优秀Python开源项目的源码。&lt;/p&gt;
&lt;h3&gt;建议2： 编写Pythonic代码&lt;/h3&gt;
&lt;h4&gt;（1）避免劣化代码&lt;/h4&gt;
&lt;p&gt;通常有几个需要注意：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;避免只用大小写来区分不同的对象。如a和A&lt;/li&gt;
&lt;li&gt;避免使用容易引起混淆的名称&lt;/li&gt;
&lt;li&gt;不要害怕过长的变量名，如person_info比pi可读性强得多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;（2）深入认识Python有助于编写Pythonic代码&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;看官方Reference&lt;/li&gt;
&lt;li&gt;学习新版本特性&lt;/li&gt;
&lt;li&gt;深入学习公认的Pythonic的代码，比如Flask、gevent和requests等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;（3）使用工具检查程序PEP8&lt;/h4&gt;
&lt;p&gt;安装PEP8的检测程序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;U&lt;/span&gt; &lt;span class="n"&gt;pep8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面使用工具检查：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;quicksort&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到检查的结果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;first&lt;/span&gt; &lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;E231&lt;/span&gt; &lt;span class="n"&gt;missing&lt;/span&gt; &lt;span class="n"&gt;whitespace&lt;/span&gt; &lt;span class="n"&gt;after&lt;/span&gt; &lt;span class="sc"&gt;&amp;#39;,&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;W391&lt;/span&gt; &lt;span class="n"&gt;blank&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就是，后面要空格，文件最后不应该有空行。
还可以展示出非常详细的错误和警告：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pep8&lt;/span&gt; &lt;span class="n"&gt;quick_sort&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;py&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;PEP8也并非是唯一的规范，还有Google Python Style Guide等等。&lt;/p&gt;
&lt;h3&gt;建议3： 理解Python与C语言的不同之处&lt;/h3&gt;
&lt;p&gt;Python底层是使用C来写的，但不要把C语言的思维方式带入Python。
可以利用Python实现C中Python并不自带的功能：&lt;/p&gt;
&lt;p&gt;三元运算符：  C ? X : Y  =&amp;gt;  X if C else Y&lt;/p&gt;
&lt;p&gt;类似switch的跳转功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You typed zero.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;You are in top.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Only single-digit numbers are allowed&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;建议4： 在代码中适当注释&lt;/h3&gt;
&lt;p&gt;Python中有3种形式的注释：块注释、行注释和文档注释（docstring）。
注释和代码隔开一定的距离；
给外部访问的函数和方法添加文档注释，包括方法功能，参数，返回值以及可能的异常进行说明。&lt;/p&gt;
&lt;h3&gt;建议5： 通过适当添加空行使代码布局更为优雅、合理&lt;/h3&gt;
&lt;p&gt;如以下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;random&lt;/span&gt;
&lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Hello! What is your name?&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;number&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;random&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;randint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Well, {0}, I am thinking of a number between 1 and 20.&amp;#39;&lt;/span&gt;\
        &lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;raw_input&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;Take a guess: &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="n"&gt;guess_made&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your guess is too low.&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Your guess is too high.&amp;#39;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;guess&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;number&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Good job&amp;#39;&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;Nope&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;一组代码表达完一个完整的思路后，应该用空白行隔开&lt;/li&gt;
&lt;li&gt;尽量保持上下文语义的易理解性。如当一个函数调用另一个函数时，尽量将它们放在一起，最好调用者在上，被调用者在下。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;A&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;B&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;避免过长的代码行。超过部分使用括号进行连接&lt;/li&gt;
&lt;li&gt;逗号和分号之前不要空格；二元运算符左右应该有空格；&lt;/li&gt;
&lt;li&gt;函数名和左括号不需要空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议6： 编写函数的4个原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;函数设计尽量短小，嵌套层次不宜过深。尽量不要太长，需要来回滚动。&lt;/li&gt;
&lt;li&gt;函数声明做到合理、简单、易于使用&lt;/li&gt;
&lt;li&gt;函数设计考虑向下兼容，如加入默认参数避免退化，做到向下兼容。&lt;/li&gt;
&lt;li&gt;一个函数只做一件事！&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;建议7：将常量集中到一个文件中&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过命名风格提醒使用者该变量代表为常量，如使用大写字母加下划线。&lt;/li&gt;
&lt;li&gt;通过自定义的类实现常量功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;Read from《&lt;a href="http://book.douban.com/subject/25910544/"&gt;编写高质量代码：改善Python程序的91个建议&lt;/a&gt;》&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 06 Apr 2015 18:42:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-06:bian-xie-gao-zhi-liang-pythondai-ma-1.html</guid><category>Python</category></item><item><title>斐波那契数列及其相关问题</title><link>http://www.wengweitao.com/fei-bo-na-qi-shu-lie-ji-qi-xiang-guan-wen-ti.html</link><description>&lt;p&gt;很多书在提到递归的时候，总是会拿斐波那契数列作为例子，它的定义如下：
&lt;img alt="Fibonacci" src="http://ac.jobdu.com/upload/201201/image/fbncslie.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;现在要求输出斐波那契数列的第n项。&lt;/p&gt;
&lt;p&gt;首先，最容易想到的方法就是直接利用递归求解：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;递归求解的形式非常简单易懂，但是递归的解法存在很严重的效率问题，因为计算过程中很多结点都是重复计算的，而且重复的结点数随着n的增大而急剧增加。例如，假设n=100，那么程序的速度将慢到无法忍受！&lt;/p&gt;
&lt;p&gt;上面递归的方法之所以慢，是因为大量的重复计算，我们只需要把已经得到的数列的中间项保存起来，下次需要的时候直接查找，就不用重复计算了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;fib&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;fibs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;                                                                                                                                                                             
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fib1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fib2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;fib2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;p&gt;另外，斐波那契数列数列还有不少的应用，下面列出几个例子。&lt;/p&gt;
&lt;h3&gt;1. 跳台阶的问题&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;p&gt;当只有1级台阶，有1种跳法；当只有2级台阶，有2种跳法。
当台阶数大于2，第一次跳有两种选择：第一次只跳1级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目；第一次跳2级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目。所以n级台阶不同跳法总数为f(n) = f(n-1) + f(n-2)。实际上就是斐波那契数列了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="nf"&gt;numJump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;jump1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;jump2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;jump2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;   
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                                                                        
    &lt;span class="p"&gt;}&lt;/span&gt;   
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;2. 变态跳台阶&lt;/h3&gt;
&lt;p&gt;一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法？&lt;/p&gt;
&lt;p&gt;与上面的跳台阶问题类似。当n&amp;gt;2时，第一次跳有n种选择：第一次只跳1级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目；第一次跳2级，那么此时跳法的数目等于后面剩下的n-1级台阶的跳法数目，依次类推，第一次直接跳n级。所以，所以n级台阶不同跳法总数为f(n) = f(n-1) + f(n-2) + ... + f(1) + 1。利用归纳法可以证明f(n) = 2^(n-1).&lt;/p&gt;
&lt;h3&gt;3. 矩形覆盖&lt;/h3&gt;
&lt;p&gt;我们可以用2&lt;em&gt;1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2&lt;/em&gt;1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？&lt;/p&gt;
&lt;p&gt;假设2 * n的大矩形总共有f(n)中覆盖方法。首先，用2*1的小矩形去覆盖大矩形最左边时有两个选择，若横着覆盖，则这个小矩形下面的那个小矩形也必须要横着覆盖，此时剩余2 * (n - 2)的区域，这种情形下的覆盖方法记为f(n - 2)；若竖着覆盖，则剩余2 * (n - 1)的区域，这种情形下覆盖的方法记为f(n - 1)。所以总的覆盖方法有：f(n - 1) + f(n - 2)。仍然是一个斐波那契数列。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 05 Apr 2015 00:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2015-04-05:fei-bo-na-qi-shu-lie-ji-qi-xiang-guan-wen-ti.html</guid><category>面试题</category></item><item><title>信息技术协会第一期电脑技术培训顺利举办</title><link>http://www.wengweitao.com/xin-xi-ji-zhu-xie-hui-di-yi-qi-dian-nao-ji-zhu-pei-xun-shun-li-ju-ban.html</link><description>&lt;blockquote&gt;
&lt;p&gt;新的学年开始了，一直想着信协能够举办几个新的有意思的活动，想了好久觉得既有意义，又能吸引其他专业的同学参加的，那么技术培训是个不错的选择。于是，就和协会的小伙伴们商量，准备定期举办同学们最感兴趣的系列技术专题培训。第一期便是Photoshop培训。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2014年10月17日晚七点，南燕信息技术协会举办了第一期电脑培训活动--Photoshop基础入门与应用的培训讲座。活动受到了同学们的广泛欢迎和好评。 &lt;/p&gt;
&lt;p&gt;本次培训讲座邀请2013级计算机应用技术的高龙飞同学担任主讲人。他深入浅出地介绍了Photoshop中常用的工具并通过实例操作向同学们清晰地展示各种操作方法。在讲解各种基础知识和工具之后，又通过PS常用的三个实例讲述了PS的使用技巧。同学们跟随主讲人的演示学习操作。两个小时的讲座很快就进入了尾声，同学们依然兴致盎然。&lt;/p&gt;
&lt;p&gt;&lt;img alt="培训现场" src="http://www.pkusz.edu.cn/uploadfile/2014/1020/20141020050506774.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;培训结束后，信息协会会长翁蔚涛对本次讲座作了简单的总结，并强调希望同学们在讲座后能多多练习，“纸上得来终觉浅，绝知此事要躬行”，并向同学们有奖征集协会的新海报设计，鼓励大家学以致用。简单总结过后，进入到抽奖环节，来自汇丰的陈敬钰同学获得了由协会送出的精美礼品。&lt;/p&gt;
&lt;p&gt;最后，协会成员和部分到场同学合影留念，第一期电脑培训活动圆满结束。接下来信息技术协会还会举办一系列培训，包括Matlab编程、网页制作等，希望同学们能够继续踊跃参加。&lt;/p&gt;
&lt;p&gt;&lt;img alt="合影" src="http://www.pkusz.edu.cn/uploadfile/2014/1020/20141020050520418.jpg" /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;信息技术协会致力于为北大深研院的同学们营造一个学习和交流信息学科得环境和氛围，为大家提供有关信息领域的设计、应用、资讯等方面的信息。信息技术协会积极打造与深港信息类企业合作和联动的平台，帮助学生走出校园，观察产业发展动态；积极开展电脑维护活动，帮助同学们解决生活中遇到的技术困难。在以后，信息技术协会仍然会坚持协会宗旨，继续为大家服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;转自：http://news.pkusz.edu.cn/article-143-4357.html&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 18 Oct 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-10-18:xin-xi-ji-zhu-xie-hui-di-yi-qi-dian-nao-ji-zhu-pei-xun-shun-li-ju-ban.html</guid><category>校园</category></item><item><title>EM算法</title><link>http://www.wengweitao.com/emsuan-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;EM算法是一种迭代算法，用于含有隐变量（hidden variable）的概率模型参数的极大似然估计，或极大后验概率估计。EM算法的每次迭代分为两步：E步，求期望（Expectation）；M步，求极大（Maximization）。所以这一算法称为期望极大算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;EM算法的引入&lt;/h2&gt;
&lt;p&gt;如果概率模型中仅含有观测变量（observable variable），那么给定数据，可以直接使用极大似然估计法或贝叶斯估计法估计模型参数。但是，如果概率模型中不仅含有观测变量还含有隐变量，那么就不能简单的使用那些估计方法。EM算法就是含有隐变量的概率模型参数的极大似然估计法，或极大后验概率估计法。&lt;/p&gt;
&lt;h3&gt;EM算法&lt;/h3&gt;
&lt;p&gt;输入：观测变量数据Y，隐变量数据Z，联合分布&lt;span class="math"&gt;\(P(Y,Z|\theta)\)&lt;/span&gt;，条件分布&lt;span class="math"&gt;\(P(Z|Y,\theta)\)&lt;/span&gt;;&lt;/p&gt;
&lt;p&gt;输出：模型参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）选择参数的初值&lt;span class="math"&gt;\(\theta^{(0)}\)&lt;/span&gt;，开始迭代；&lt;/p&gt;
&lt;p&gt;（2）E步：记&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;为第i次迭代参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的估计值，在第i+1次迭代的E步，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta, \theta^{(i)})=E_Z[logP(Y,Z|\theta)|Y,\theta^{(i)}]=\sum_ZlogP(Y,Z|\theta)P(Z|Y,\theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（3）M步：求使&lt;span class="math"&gt;\(Q(\theta, \theta^{(i)})\)&lt;/span&gt;极大化的&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，确定第i+1次迭代的参数估计值&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta^{(i+1)}=argmax_\theta Q(\theta, \theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（4）重复第（2）步与第（3）步，直到收敛&lt;/p&gt;
&lt;p&gt;其中&lt;span class="math"&gt;\(Q(\theta, \theta^{(i)})\)&lt;/span&gt;是算法的核心，称为&lt;strong&gt;Q函数&lt;/strong&gt;。其中第一个&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;表示要极大化的参数，第二个变元表示参数的当前估计值，每次迭代实际在求Q函数及其极大（M步中求极大，并完成一次迭代更新，可以证明每次迭代使似然函数增大或者达到局部极值）。&lt;/p&gt;
&lt;p&gt;完全数据的对数似然函数&lt;span class="math"&gt;\(logP(Y,Z|\theta)\)&lt;/span&gt;关于在给定观测数据Y和当前参数&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;下对未观测数据Z的条件概率分布&lt;span class="math"&gt;\(P(Y,Z|\theta^{(i)})\)&lt;/span&gt;的期望称为Q函数
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta, \theta^{(i)})=E_Z[logP(Y,Z|\theta)|Y,\theta^{(i)}]$$&lt;/div&gt;
&lt;p&gt;步骤（1）中，初值可以任意选择，但是EM算法对初值是敏感的；&lt;/p&gt;
&lt;p&gt;步骤（4）中，迭代的终止条件，一般是对较小的正数&lt;span class="math"&gt;\(\varepsilon_1, \varepsilon_2\)&lt;/span&gt;，若满足
&lt;/p&gt;
&lt;div class="math"&gt;$$||\theta^{(i+1)}-\theta^{(i)}||&amp;lt;\varepsilon_1$$&lt;/div&gt;
&lt;p&gt;
或
&lt;/p&gt;
&lt;div class="math"&gt;$$||Q(\theta^{(i+1)}, \theta^{(i)})-Q(\theta^{(i)}, \theta^{(i)})||&amp;lt;\varepsilon_2$$&lt;/div&gt;
&lt;p&gt;
则停止迭代。&lt;/p&gt;
&lt;p&gt;举一个三硬币模型。假设有3枚硬币，分别记为A,B,C。每次都先抛A硬币，若为正面，则抛B硬币，反面则抛C硬币，此时的结果不能观测到，记此结果为Z；然后抛B或C硬币，若出现正面记为1，反面记为0，此时的结果作为观测变量记为Y。求此模型的参数，即三枚硬币正面分别出现的概率a,b和c。&lt;/p&gt;
&lt;p&gt;Y表示观测随机变量的数据，Z表示隐随机变量的数据。Y和Z连在一起称为完全数据（complete data），观测数据Y又称为不完全数据。假设给定观测数据Y，其概率分布是&lt;span class="math"&gt;\(P(Y|\theta)\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;就是要求的模型参数。不完全数据Y的似然函数是&lt;span class="math"&gt;\(P(Y|\theta)\)&lt;/span&gt;，对数似然函数是&lt;span class="math"&gt;\(L(\theta)=logP(Y|\theta)\)&lt;/span&gt;；Y和Z的联合概率分布是&lt;span class="math"&gt;\(P(Y,Z|\theta)\)&lt;/span&gt;，那么完全数据的对数似然函数是&lt;span class="math"&gt;\(logP(Y，Z|\theta)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;EM算法通过迭代求&lt;span class="math"&gt;\(L(\theta)=logP(Y|\theta)\)&lt;/span&gt;的极大似然估计（**观测数据数据每次迭代包含两步：E步，求期望；M步，求极大化。&lt;/p&gt;
&lt;h3&gt;EM算法的导出&lt;/h3&gt;
&lt;p&gt;EM算法为什么能近似实现对观测数据的极大似然估计呢？下面通过近似求解观测数据的对数似然函数的极大化问题来导出EM算法。&lt;/p&gt;
&lt;p&gt;面对一个含有隐变量的概率模型，目标是极大化观测数据（不完全数据）Y关于参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的对数似然函数，即极大化
&lt;/p&gt;
&lt;div class="math"&gt;$$L(\theta)=logP(Y|\theta)=log\sum_ZP(Y,Z)|\theta)=log(\sum_ZP(Y|Z,\theta)P(Z|\theta))$$&lt;/div&gt;
&lt;p&gt;
上面的式子含有未观测 并且含有和的对数，所以很难直接极大化。&lt;/p&gt;
&lt;p&gt;假设第i次迭代后&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的估计值为&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;，我们希望新的估计值&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;能使&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;的值更大，并逐步达到极大值。考虑两者的差：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(\theta)-L(\theta^{(i)})=log(\sum_ZP(Y|Z,\theta)P(Z|\theta))-logP(Y|\theta^{(i)})$$&lt;/div&gt;
&lt;p&gt; 
利用Jensen不等式&lt;sup id="fnref:Jesen"&gt;&lt;a class="footnote-ref" href="#fn:Jesen" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;,可以得到其下界：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(\theta)-L(\theta^{(i)}) \geq \sum_ZP(Z|Y,\theta^{(i)})log\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Y|Z,\theta^{(i)})P(Y|\theta^{(i)})}$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$B(\theta,\theta^{(1)})=L(\theta^{(i)})+\sum_ZP(Z|Y,\theta^{(i)})log\frac{P(Y|Z,\theta)P(Z|\theta)}{P(Y|Z,\theta^{(i)})P(Y|\theta^{(i)})}$$&lt;/div&gt;
&lt;p&gt;
则&lt;span class="math"&gt;\(B(\theta,\theta^{(1)})\)&lt;/span&gt;是&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;的一个下界，而且&lt;span class="math"&gt;\(L(\theta^{(i)})=B(\theta^{(i)},\theta^{(i)})\)&lt;/span&gt;。所以，任意可以使&lt;span class="math"&gt;\(B(\theta,\theta^{(1)})\)&lt;/span&gt;增大的&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，也可以使&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;增大。选择&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;使得
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta^{(i+1)}=argmax_\theta B(\theta, \theta^{(i+1)})$$&lt;/div&gt;
&lt;p&gt;
然后可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta^{(i+1)}=argmax_\theta Q(\theta, \theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;
等价于EM算法的一次迭代，即求Q函数及其极大化。EM算法是通过不断求解其下界的极大化逼近求解对数似然函数极大化的算法。&lt;/p&gt;
&lt;p&gt;但是，EM算法不能保证找到全局最优值。&lt;/p&gt;
&lt;h3&gt;EM算法在非监督学习中的应用&lt;/h3&gt;
&lt;p&gt;有时训练数据只有输入而没有输出，从这样的数据学习模型称为非监督学习问题。EM算法可以用于非监督学习，生成模型由联合概率分布P(X,Y)（相当于P(Y)）表示，可以认为非监督学习训练数据是联合概率分布产生的数据。X为观测数据，Y为非观测数据。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;EM算法的收敛性&lt;/h2&gt;
&lt;p&gt;EM算法提供一种近似计算含有隐含变量概率模型的极大似然估计的方法。EM算法的最大优点是简单性和普适性。EM算法得到的估计序列是否收敛？&lt;/p&gt;
&lt;p&gt;设&lt;span class="math"&gt;\(P(Y|\theta)\)&lt;/span&gt;为观测数据的似然函数，&lt;span class="math"&gt;\(\theta^{(i)}(i=1,2,...)\)&lt;/span&gt;为EM算法得到的参数估计序列，&lt;span class="math"&gt;\(P(Y|\theta^{(i)})(i=1,2,...)\)&lt;/span&gt;为对应的似然函数序列，则&lt;span class="math"&gt;\(P(Y|\theta^{i})\)&lt;/span&gt;是单调递增的，即
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|\theta^{(i+1)}) \geq P(Y|\theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;设&lt;span class="math"&gt;\(L(\theta)=logP(Y|\theta)\)&lt;/span&gt;为观测数据的对数似然函数，&lt;span class="math"&gt;\(\theta^{(i)}(i=1,2,...)\)&lt;/span&gt;为EM算法得到的参数估计序列，&lt;span class="math"&gt;\(L(\theta^{(i)})(i=1,2,...)\)&lt;/span&gt;为为对应的对数似然函数序列。&lt;/p&gt;
&lt;p&gt;（1）如果&lt;span class="math"&gt;\(P(Y|\theta)\)&lt;/span&gt;有上界，则&lt;span class="math"&gt;\(L(\theta^{(i)})=logP(Y|\theta^{(i)})\)&lt;/span&gt;收敛到某一直&lt;span class="math"&gt;\(L^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）&lt;span class="math"&gt;\(Q(\theta, \theta')与L(\theta)\)&lt;/span&gt;满足一定条件下，由EM算法得到的参数估计序列&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;的收敛值&lt;span class="math"&gt;\(\theta^{*}\)&lt;/span&gt;是&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;的稳定点。&lt;/p&gt;
&lt;p&gt;稳定点，不能保证收敛到极大值点。所以初值的选择变得非常重要，常用的办法是选取几个不同的初值进行迭代，然后对得到的各个初值加以比较，从中选择最好的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;EM算法在高斯混合模型学习中的应用&lt;/h2&gt;
&lt;p&gt;EM算法的一个重要应用是高斯混合模型的参数估计。&lt;/p&gt;
&lt;h3&gt;高斯混合模型&lt;/h3&gt;
&lt;p&gt;高斯混合模型是指具有如下形式的概率分布模型：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(y|\theta)=\sum_{k=1}^{K}\alpha_k\phi(y|\theta_k)$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(\alpha_k \geq 0\)&lt;/span&gt;是系数（&lt;span class="math"&gt;\(\sum_{k=1}^{K}\alpha_k = 1\)&lt;/span&gt;）；&lt;span class="math"&gt;\(\phi(y|\theta_k)\)&lt;/span&gt;是高斯分布密度，&lt;span class="math"&gt;\(\phi(y|\theta_k)=(\mu_k, \sigma_k^2)\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\phi(y|\theta_k)=\frac{1}{\sqrt{2\pi}\sigma_k}exp(-\frac{(y-\mu_k)^2}{2\sigma_k^2})$$&lt;/div&gt;
&lt;p&gt;
称为第k个模型。&lt;/p&gt;
&lt;h3&gt;高斯混合模型参数估计的EM算法&lt;/h3&gt;
&lt;p&gt;我们用EM算法估计高斯混合模型的参数&lt;span class="math"&gt;\(\theta=(\alpha_1,\alpha_2,...,\alpha_k;\theta_1,\theta_2,...,\theta_k)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）明确隐变量，写出完全数据的对数似然函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第k个模型&lt;span class="math"&gt;\(\phi(y|\theta_k)\)&lt;/span&gt;生成的观测数据&lt;span class="math"&gt;\(y_j\)&lt;/span&gt;是已知的；但是观测数据来自于哪个模型是未知的，定义隐变量&lt;span class="math"&gt;\(\gamma_{jk}\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_{jk}=\left\{\begin{matrix}
1, &amp;amp; 第j个观测来自第k个分模型\\ 
0, &amp;amp; 否则
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
这样完全数据就是：
&lt;/p&gt;
&lt;div class="math"&gt;$$(y_j,\gamma_{j1},\gamma_{j2},...,\gamma_{jK}), j=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
于是，可以写出完全数据的似然函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(y,\gamma|\theta)=\prod_{j=1}^{N}P(y_j,\gamma_{j1},\gamma_{j2},...,\gamma_{jK}|\theta)=...=\prod_{k=1}^{K}\alpha_k^{n_k}\prod_{j=1}^{N}[\frac{1}{\sqrt{2\pi}\sigma_k}exp(-\frac{(y_j-\mu_k)^2}{2\sigma_k^2})]^{\gamma_{jk}}$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(n_k=\sum_{j=1}^{N}\gamma_{jk}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么，完全数据的对数似然函数就为：
&lt;/p&gt;
&lt;div class="math"&gt;$$logP(y,\gamma|\theta)=\sum_{k=1}^{K}n_klog\alpha_k+\sum_{j=1}^{N}\gamma_{jk}[log\frac{1}{\sqrt{2\pi}\sigma_k}-\frac{(y_j-\mu_k)^2}{2\sigma_k^2})]$$&lt;/div&gt;
&lt;p&gt;（2）EM算法的E步：确定Q函数
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta, \theta^{(i)})=E[logP(y,\gamma|\theta)|y,\theta^{(i)}]$$&lt;/div&gt;
&lt;p&gt;（3）确定EM算法的M步&lt;/p&gt;
&lt;p&gt;求使&lt;span class="math"&gt;\(Q(\theta, \theta^{(i)})\)&lt;/span&gt;极大化的&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，确定第i+1次迭代的参数估计值&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）重复直到收敛&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;EM算法的推广&lt;/h2&gt;
&lt;p&gt;EM算法还可以解释&lt;strong&gt;为F函数的极大-极大算法&lt;/strong&gt;，基于这个解释有若干变形与推广，如&lt;strong&gt;广义期望极大（GEM）算法&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;F函数的极大-极大算法&lt;/h3&gt;
&lt;p&gt;假设隐变量数据Z的概率分布为&lt;span class="math"&gt;\(\widetilde{P}(Z)\)&lt;/span&gt;，定义分布&lt;span class="math"&gt;\(\widetilde{P}\)&lt;/span&gt;与参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的函数&lt;span class="math"&gt;\(F(\widetilde{P}, \theta)\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$F(\widetilde{P}, \theta)=E_{\widetilde{P}}[logP(Y,Z|\theta)]+H(\widetilde{P})$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;FF函数&lt;/strong&gt;。式中&lt;span class="math"&gt;\(H(\widetilde{P})\)&lt;/span&gt;是分布&lt;span class="math"&gt;\(\widetilde{P}(Z)\)&lt;/span&gt;的熵。&lt;span class="math"&gt;\(F(\widetilde{P}, \theta)\)&lt;/span&gt;具有如下的性质：&lt;/p&gt;
&lt;p&gt;（1）对于固定的&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，存在唯一的分布布&lt;span class="math"&gt;\(\widetilde{P}(\theta)\)&lt;/span&gt;极大化&lt;span class="math"&gt;\(F(\widetilde{P}, \theta)\)&lt;/span&gt;，这时&lt;span class="math"&gt;\(\widetilde{P}(\theta)\)&lt;/span&gt;由下式给出：
&lt;/p&gt;
&lt;div class="math"&gt;$$\widetilde{P}_\theta(Z)=P(Z|Y,\theta)$$&lt;/div&gt;
&lt;p&gt;
并且&lt;span class="math"&gt;\(\widetilde{P}(\theta)\)&lt;/span&gt;随&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;连续变化。&lt;/p&gt;
&lt;p&gt;（2）若&lt;span class="math"&gt;\(\widetilde{P}_\theta(Z) = P(Z|Y,\theta)\)&lt;/span&gt;，则
&lt;/p&gt;
&lt;div class="math"&gt;$$F(\widetilde{P}, \theta)=logP(Y|\theta)$$&lt;/div&gt;
&lt;p&gt;
于是，可以得到EM算法用F函数的极大-极大的解释。&lt;/p&gt;
&lt;p&gt;（3）如果&lt;span class="math"&gt;\(F(\widetilde{P}, \theta)\)&lt;/span&gt;在&lt;span class="math"&gt;\(\widetilde{P}^*\)&lt;/span&gt;和&lt;span class="math"&gt;\(\theta^*\)&lt;/span&gt;有局部极大值，那么&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;也在&lt;span class="math"&gt;\(\theta^*\)&lt;/span&gt;有局部极大值。 类似的，如果&lt;span class="math"&gt;\(F(\widetilde{P}, \theta)\)&lt;/span&gt;在&lt;span class="math"&gt;\(\widetilde{P}^*\)&lt;/span&gt;和&lt;span class="math"&gt;\(\theta^*\)&lt;/span&gt;有全局极大值，那么&lt;span class="math"&gt;\(L(\theta)\)&lt;/span&gt;也在&lt;span class="math"&gt;\(\theta^*\)&lt;/span&gt;有全局极大值。&lt;/p&gt;
&lt;p&gt;（4）&lt;strong&gt;EM算法的一次迭代可由F函数的极大-极大算法实现。&lt;/strong&gt;
&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;为第i次迭代参数的估计，&lt;span class="math"&gt;\(\widetilde{P}^{(i)}\)&lt;/span&gt;为第i次迭代函数&lt;span class="math"&gt;\(\widetilde{P}\)&lt;/span&gt;的估计。在第i+1次迭代的两步为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对固定的&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;，求&lt;span class="math"&gt;\(\widetilde{P}^{(i+1)}\)&lt;/span&gt;使&lt;span class="math"&gt;\(F(\widetilde{P}, \theta^{(i)})\)&lt;/span&gt;极大化；&lt;/li&gt;
&lt;li&gt;对固定的&lt;span class="math"&gt;\(\widetilde{P}^{(i+1)}\)&lt;/span&gt;，求&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;使&lt;span class="math"&gt;\(F(\widetilde{P}^{(i+1), \theta})\)&lt;/span&gt;极大化；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过以上两步完成了EM算法的一次迭代。因此，EM算法与F函数的极大-极大算法得到的参数估计序列是一致的。&lt;/p&gt;
&lt;p&gt;于是就有了EM算法的推广。&lt;/p&gt;
&lt;h3&gt;GEM算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;GEM算法1：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：观测数据，F函数&lt;/p&gt;
&lt;p&gt;输出：模型参数&lt;/p&gt;
&lt;p&gt;（1） 初始化参数&lt;span class="math"&gt;\(\theta^{(0)}\)&lt;/span&gt;，开始迭代&lt;/p&gt;
&lt;p&gt;（2）第i+1次迭代，第1步：记&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;为参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的估计值，&lt;span class="math"&gt;\(\widetilde{P}^{(i)}\)&lt;/span&gt;为&lt;span class="math"&gt;\(\widetilde{P}\)&lt;/span&gt;的估计。求&lt;span class="math"&gt;\(\widetilde{P}^{(i+1)}\)&lt;/span&gt;使&lt;span class="math"&gt;\(F(\widetilde{P}, \theta^{(i)})\)&lt;/span&gt;极大化&lt;/p&gt;
&lt;p&gt;（3）第2步：求&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;使&lt;span class="math"&gt;\(F(\widetilde{P}^{(i+1), \theta})\)&lt;/span&gt;极大化&lt;/p&gt;
&lt;p&gt;（4）重复（2）和（3），直到收敛。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GEM算法2：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：观测数据，Q函数&lt;/p&gt;
&lt;p&gt;输出：模型参数&lt;/p&gt;
&lt;p&gt;（1）初始化参数&lt;span class="math"&gt;\(\theta^{(0)}\)&lt;/span&gt;，开始迭代&lt;/p&gt;
&lt;p&gt;（2）第i+1次迭代，第1步：记&lt;span class="math"&gt;\(\theta^{(i)}\)&lt;/span&gt;为参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的估计值，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta, \theta^{(i)})=E_Z[logP(Y,Z|\theta)|Y,\theta^{(i)}]=\sum_ZlogP(Y,Z|\theta)P(Z|y,\theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（3）第2步：求&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;使
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta^{(i+1)},\theta^{(i)}) \geq Q(\theta^{(i)}, \theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（4）重复（2）和（3），直到收敛。&lt;/p&gt;
&lt;p&gt;当参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的维数为d时，可以采用一种特殊的GEM法， 它将EM算法的M步分解为d次条件极大化， 每次只改变参数向量的一个分量，其余分量不改变。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GEM算法3：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：观测数据，Q函数&lt;/p&gt;
&lt;p&gt;输出：模型参数&lt;/p&gt;
&lt;p&gt;（1）初始化参数&lt;span class="math"&gt;\(\theta^{(0)}\)&lt;/span&gt;，开始迭代&lt;/p&gt;
&lt;p&gt;（2）第i+1次迭代，第1步：记&lt;span class="math"&gt;\(\theta^{(i)}=(\theta_1^{(i)},\theta_2^{(i)},...,\theta_d^{(i)})\)&lt;/span&gt;为参数&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的估计值，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta, \theta^{(i)})=E_Z[logP(Y,Z|\theta)|Y,\theta^{(i)}]=\sum_ZlogP(Y,Z|\theta)P(Z|y,\theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（3）第2步：进行d次条件极大化：&lt;/p&gt;
&lt;p&gt;首先，在&lt;span class="math"&gt;\(\theta_2^{(i)},...,\theta_k^{(i)}\)&lt;/span&gt;保持不变的条件下求使&lt;span class="math"&gt;\(Q(\theta, \theta^{(i)})\)&lt;/span&gt;达到极大的&lt;span class="math"&gt;\(\theta_1^{(i+1)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;然后，在&lt;span class="math"&gt;\(\theta_1^{(i)},\theta_3^{(i)},...,\theta_k^{(i)}\)&lt;/span&gt;保持不变的条件下求使&lt;span class="math"&gt;\(Q(\theta, \theta^{(i)})\)&lt;/span&gt;达到极大的&lt;span class="math"&gt;\(\theta_2^{(i+1)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如此继续，经过d次条件极大化，得到求&lt;span class="math"&gt;\(\theta^{(i+1)}\)&lt;/span&gt;使
&lt;/p&gt;
&lt;div class="math"&gt;$$Q(\theta^{(i+1)},\theta^{(i)}) \geq Q(\theta^{(i)}, \theta^{(i)})$$&lt;/div&gt;
&lt;p&gt;（4）重复（2）和（3），直到收敛。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第九章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:Jesen"&gt;
&lt;p&gt;&lt;span class="math"&gt;\(log\sum_j\lambda_jy_j \geq \sum_j\lambda_jlogy_j\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(\lambda_j \geq 0, \sum_j\lambda_j=1\)&lt;/span&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:Jesen" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 10 Aug 2014 19:09:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-10:emsuan-fa.html</guid><category>读书笔记</category></item><item><title>提升树</title><link>http://www.wengweitao.com/ti-sheng-shu.html</link><description>&lt;blockquote&gt;
&lt;p&gt;提升树是以分类树或回归树为基本分类器的提升方法。提升树被认为是统计学习中性能最好的方法之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;提升树模型&lt;/h2&gt;
&lt;p&gt;以决策树为基函数的提升方法称为提升树（boosting tree）。一个基本分类器x &amp;lt; v或者x &amp;gt; v，可以看作是由一个根结点直接连接两个叶节点的简单决策树，即所谓的决策树桩（decision stump）。提升树模型可以表示为决策树的加法模型：
&lt;/p&gt;
&lt;div class="math"&gt;$$f_M(x)=\sum_{m=1}^{M}T(x;\varTheta_m)$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(T(x;\varTheta_m)\)&lt;/span&gt;表示决策树；&lt;span class="math"&gt;\(\varTheta_m\)&lt;/span&gt;为决策树的参数；M为树的个数。&lt;/p&gt;
&lt;h2&gt;提升树算法&lt;/h2&gt;
&lt;p&gt;提升树算法采用前向分步算法。首先，确定原始提升树&lt;span class="math"&gt;\(f_0(x)=0\)&lt;/span&gt;，第m步的模型是
&lt;/p&gt;
&lt;div class="math"&gt;$$f_m(x)=f_{m-1}(x)+T(x;\varTheta_m)$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(f_{m-1}(x)\)&lt;/span&gt;为当前模型，通过经验风险最小化确定下一棵决策树的参数&lt;span class="math"&gt;\(\varTheta_m\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\widehat{\varTheta_m}=argmin_{\varTheta_m}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+T(x_i;\varTheta_m))$$&lt;/div&gt;
&lt;p&gt;针对不同问题的提升树算法，其主要区别是使用的损失函数不同。包括用平方误差损失函数的回归问题，用指数损失函数的分类问题你，以及用一般损失函数的一般决策问题。&lt;/p&gt;
&lt;p&gt;对于&lt;strong&gt;回归问题的提升树&lt;/strong&gt;。已知一个训练数据集T，如果将输入空间&lt;span class="math"&gt;\(\chi\)&lt;/span&gt;划分为J个互不相交的区域&lt;span class="math"&gt;\(R_1, R_2,...,R_j\)&lt;/span&gt;，并且在每个区域上确定输出的常量&lt;span class="math"&gt;\(c_j\)&lt;/span&gt;，那么树可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$T(x;\varTheta)=\sum_{j=1}^{J}c_jI(x \in R_j)$$&lt;/div&gt;
&lt;p&gt;
J是回归树的复杂度即叶节点的个数。&lt;/p&gt;
&lt;p&gt;回归问题提升树使用以下前向分步算法：
&lt;/p&gt;
&lt;div class="math"&gt;$$f_0(x)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$f_m(x)=f_{m-1}(x)+T(x;\varTheta_m)$$&lt;/div&gt;
&lt;div class="math"&gt;$$f_M(x)=\sum_{m=1}^{M}T(x;\varTheta_m)$$&lt;/div&gt;
&lt;p&gt;在前向分步算法的第m步，给定当前模型&lt;span class="math"&gt;\(f_{m-1}(x)\)&lt;/span&gt;，需求解
&lt;/p&gt;
&lt;div class="math"&gt;$$\widehat{\varTheta_m}=argmin_{\varTheta_m}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+T(x_i;\varTheta_m))$$&lt;/div&gt;
&lt;p&gt;
得到&lt;span class="math"&gt;\(\widehat{\varTheta_m}\)&lt;/span&gt;，即第m棵树的参数。&lt;/p&gt;
&lt;p&gt;当采用平方损失误差函数时：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(y,f(x)) = (f(x) - y)^2$$&lt;/div&gt;
&lt;p&gt;
其损失变为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(y,f_{m-1}(x)+T(x;\varTheta_m)) = [y - f_{m-1}(x)-T(x;\varTheta_m)]^2 = [r - T(x;\varTheta_m)]^2$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(r=y - f_{m-1}(x)\)&lt;/span&gt;，是当前模型拟合数据的&lt;strong&gt;残差（residual）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以对于回归问题的提升树算法，只需简单地拟合当前模型的残差。这样的算法是相当简单的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;回归问题的提升树算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：训练数据集T&lt;/p&gt;
&lt;p&gt;输出：提升树&lt;span class="math"&gt;\(f_M(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）初始化&lt;span class="math"&gt;\(f_0(x)=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）对m=1,2,...,M&lt;/p&gt;
&lt;p&gt;（a）计算残差
&lt;/p&gt;
&lt;div class="math"&gt;$$r_{mi}=y_i - f_{m-1}(x_i),　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;（b）拟合残差&lt;span class="math"&gt;\(r_{mi}\)&lt;/span&gt;学习一棵回归树，得到&lt;span class="math"&gt;\(T(x;\varTheta_m)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（c）更新&lt;span class="math"&gt;\(f_m(x)=f_{m-1}(x)+T(x;\varTheta_m)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）得到回归问题提升树
&lt;/p&gt;
&lt;div class="math"&gt;$$f_M(x)=\sum_{m=1}^{M}T(x;\varTheta_m)$$&lt;/div&gt;
&lt;h2&gt;梯度提升&lt;/h2&gt;
&lt;p&gt;当损失函数是平方损失和指数损失函数时，每一步的优化使很简单的。但对一般的损失函数而言，往往每一步的优化就没有那么容易了。针对这一问题，提出了&lt;strong&gt;梯度提升（gradient boosting）&lt;/strong&gt;算法。这是利用最速下降法的近似算法，其关键是利用损失函数的负梯度在当前模型下的值：
&lt;/p&gt;
&lt;div class="math"&gt;$$-[\frac{\partial L(y,f(x_i)}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}$$&lt;/div&gt;
&lt;p&gt;
作为回归问题提升树算法中的残差近似值，拟合一棵回归树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;梯度提升算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：训练数据集T；损失函数L(y,f(x))&lt;/p&gt;
&lt;p&gt;输出：提升树&lt;span class="math"&gt;\(\widehat{f}(x)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）初始化
&lt;/p&gt;
&lt;div class="math"&gt;$$f_0(x)=argmin_c\sum_{i=1}^NL(y_i,c)$$&lt;/div&gt;
&lt;p&gt;
估计使损失函数极小化的常数值，它是只有一个根结点的树。&lt;/p&gt;
&lt;p&gt;（2）对m=1,2,...,M&lt;/p&gt;
&lt;p&gt;（a）对i=1,2,...,N，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$r_{mi}=-[\frac{\partial L(y_i,f(x_i)}{\partial f(x_i)}]_{f(x)=f_{m-1}(x)}$$&lt;/div&gt;
&lt;p&gt;（b）对&lt;span class="math"&gt;\(r_{mi}\)&lt;/span&gt;拟合一棵回归树，得到第m棵树的叶节点区域&lt;span class="math"&gt;\(R_{mj}\)&lt;/span&gt;, j=1,2,...,J，即估计回归树叶节点区域&lt;/p&gt;
&lt;p&gt;（c）对j=1,2,...,J，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$c_{mj}=argmin_c\sum_{x_i \in R_{mj}}L(y_i, f_{m-1}(x_i)+c)$$&lt;/div&gt;
&lt;p&gt;
估计叶节点区域的值，并且使损失函数最小化&lt;/p&gt;
&lt;p&gt;（d）更新回归树&lt;span class="math"&gt;\(f_m(x)=f_{m-1}(x)+\sum_{j=1}^Jc_{mj}I(x \in R_{mj}）\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）得到回归树最终的模型
&lt;/p&gt;
&lt;div class="math"&gt;$$\widehat{f}(x)=f_M(x)=\sum_{m=1}^M\sum_{j=1}^Jc_{mj}I(x \in R_{mj}）$$&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第八章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Thu, 07 Aug 2014 22:27:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-07:ti-sheng-shu.html</guid><category>读书笔记</category></item><item><title>AdaBoost算法</title><link>http://www.wengweitao.com/adaboostsuan-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;提升（boosting）方法是一种常用的统计学习方法。在分类问题中，它通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，提高分类的性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;提升方法AdaBoost算法&lt;/h2&gt;
&lt;h3&gt;提升方法的基本思路&lt;/h3&gt;
&lt;p&gt;提升方法基于这一思想：对于一个复杂的任务来说，将多个专家的判断进行适当的综合所得出的判断，要比其中任何一个专家的单独判断好。&lt;/p&gt;
&lt;p&gt;在概率近似正确（probably approximately correct， PAC）学习框架中，一个概念（或者类），如果存在一个多项式学习算法能够学习它，并且正确率很高，那么就称这个概念是&lt;strong&gt;强可学习的&lt;/strong&gt;；如果存在一个多项式学习算法能够学习它，并且正确率仅比随机猜测略好，那么就称这个概念是&lt;strong&gt;弱可学习的&lt;/strong&gt;。可以证明强可学习与弱可学习是等价的。&lt;/p&gt;
&lt;p&gt;这样一来，我们在学习中，如果发现了“弱学习算法”，那么能否将它提升（boost）为“强学习算法”。弱学习算法通常要比强学习算法容易得多，那么如何具体实施提升？关于提升的方法最具代表性的是AdaBoost算法。&lt;/p&gt;
&lt;p&gt;对于分类问题而言，一个粗糙的分类规则要比精确的分类规则容易的多。&lt;strong&gt;提升方法就是从弱学习算法出发，反复学习，得到一系列弱分类器，然后组合这些弱分类器构成一个强分类器。&lt;/strong&gt;大多数提升方法都是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列弱分类器。&lt;/p&gt;
&lt;p&gt;这样，对提升方法来说，&lt;strong&gt;有两个问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每一轮如何改变训练数据的权值或概率分布&lt;/li&gt;
&lt;li&gt;如何将弱分类器组合成一个强分类器。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第一个问题，AdaBoost通过提高前一轮弱分类器错误分类样本的权值，而降低被正确分类样本的权值，这样那些没有被正确分类的数据，在后一轮就会受到弱分类器更大的关注。对于第二个问题，AdaBoost采取加权多数表决的方法，加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用，减小分类误差率大的弱分类器的权值，使其在表决中起较小的作用。&lt;/p&gt;
&lt;h3&gt;AdaBoost算法&lt;/h3&gt;
&lt;p&gt;输入：训练数据集T；弱学习算法&lt;/p&gt;
&lt;p&gt;输出：最终分类器G(x)&lt;/p&gt;
&lt;p&gt;（1）初始化训练数据的权值分布
&lt;/p&gt;
&lt;div class="math"&gt;$$D_1=(w_{11},...,w_{1i},...,w_{1N}), 　w_{1i}=\frac{1}{N}, 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
其中N为样本数据的总数，D的下标为m代表的是第几轮，假设训练数据集具有均匀的权值分布。&lt;/p&gt;
&lt;p&gt;（2）在每一轮对m=1,2,...,M依次执行下列操作：&lt;/p&gt;
&lt;p&gt;（a）使用具有权值分布&lt;span class="math"&gt;\(D_m\)&lt;/span&gt;的训练数据集进行学习，得到基本分类器
&lt;/p&gt;
&lt;div class="math"&gt;$$G_m(x):\chi \rightarrow \{-1, +1\}$$&lt;/div&gt;
&lt;p&gt;（b）计算&lt;span class="math"&gt;\(G_m(x)\)&lt;/span&gt;在训练数据集上的分类误差率
&lt;/p&gt;
&lt;div class="math"&gt;$$e_m=P(G_m(x_i) \neq y_i)=\sum_{i=1}^{N}w_{mi}I(G_m(x_i) \neq y_i)$$&lt;/div&gt;
&lt;p&gt;（c）计算&lt;span class="math"&gt;\(G_m(x)\)&lt;/span&gt;的系数
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_m=\frac{1}{2}log\frac{1-e_m}{e_m}$$&lt;/div&gt;
&lt;p&gt;
这里的对数为自然对数。&lt;span class="math"&gt;\(\alpha_m\)&lt;/span&gt;随着&lt;span class="math"&gt;\(e_m\)&lt;/span&gt;的减小而增大。&lt;/p&gt;
&lt;p&gt;（d）更新训练数据集的权值分布
&lt;/p&gt;
&lt;div class="math"&gt;$$D_{m+1}=(w_{m+1,1},...,w_{m+1,i},...,w_{m+1,N}) $$&lt;/div&gt;
&lt;div class="math"&gt;$$w_{m+1,i}=\frac{w_{mi}}{Z_m}exp(-\alpha_my_iG_m(x_i)), 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
即：
&lt;/p&gt;
&lt;div class="math"&gt;$$w_{mm+1,i}=\left\{\begin{matrix}
\frac{w_{mi}}{Z_m}e^{-\alpha_m}, &amp;amp; G_m(x_i)=y_i\\ 
\frac{w_{mi}}{Z_m}e^{\alpha_m} &amp;amp; G_m(x_i) \neq y_i
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
可见被基本分类器误分类样本的权值得以扩大，被正确分类的权值缩小。&lt;/p&gt;
&lt;p&gt;这里&lt;span class="math"&gt;\(Z_m\)&lt;/span&gt;是规范化因子，使概率总和为1
&lt;/p&gt;
&lt;div class="math"&gt;$$Z_m=\sum_{i=1}^Nw_{mi}exp(-\alpha_my_iG_m(x_i))$$&lt;/div&gt;
&lt;p&gt;（3）构建基本分类器的线性组合
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=\sum_{m=1}^M\alpha_mG_m(x)$$&lt;/div&gt;
&lt;p&gt;
得到最终分类器
&lt;/p&gt;
&lt;div class="math"&gt;$$G(x)=sign(f(x))=sign(\sum_{m=1}^M\alpha_mG_m(x))$$&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;AdaBoost算法的训练误差分析&lt;/h2&gt;
&lt;p&gt;AdaBoost算法最基本的性质是它能在学习过程中不断减小训练误差，即在训练数据集上的分类误差率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AdaBoost的训练误差界：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AdaBoost算法最终分类器的训练误差界为
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{N}\sum_{i=1}^{N}I(G(x_i) \neq y_i) \leq \frac{1}{N}\sum_iexp(-y_if(x_i))= \prod_mZ_m$$&lt;/div&gt;
&lt;p&gt;说明，可以再每轮选取适当的&lt;span class="math"&gt;\(G_m\)&lt;/span&gt;使得&lt;span class="math"&gt;\(Z_m\)&lt;/span&gt;最小，从而使得训练误差下降最快。对于二类分类问题，有如下结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二类分类问题AdaBoost的训练误差界：&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\prod_{m=1}^{M}Z_m=\prod_{m=1}^{M}[2\sqrt{e_m(1-e_m)}]=\prod_{m=1}^{M}\sqrt{(1-4\gamma_m^2)} \leq exp(-2\sum_{m=1}^{M}\gamma_m^2)　其中\gamma_m=\frac{1}{2}-e_m$$&lt;/div&gt;
&lt;p&gt;如果存在&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;，对所有m有&lt;span class="math"&gt;\(r_m \geq \gamma\)&lt;/span&gt;，则
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{N}\sum_{i=1}^{N}I(G(x_i) \neq y_i) \leq exp(-2M\gamma^2)$$&lt;/div&gt;
&lt;p&gt;这表明在此条件下&lt;strong&gt;AdaBoost的训练误差是以指数速率下降的&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;AdaBoost算法的解释&lt;/h2&gt;
&lt;p&gt;AdaBoost算法另外一种解释是，AdaBoost算法是模型为加法模型、损失函数为指数函数、学习算法为前向分步算法时的二类分类学习方法。&lt;/p&gt;
&lt;h3&gt;前向分步算法&lt;/h3&gt;
&lt;p&gt;考虑加法模型（additive model）
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=\sum_{m=1}^{M}\beta_mb(x;\gamma_m)$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(b(x;\gamma_m)\)&lt;/span&gt;是基函数，&lt;span class="math"&gt;\(\gamma_m\)&lt;/span&gt;是基函数的参数，&lt;span class="math"&gt;\(\beta_m\)&lt;/span&gt;是基函数的系数。&lt;/p&gt;
&lt;p&gt;在给定训练数据及损失函数L(y,f(x))的条件下，学习加法模型f(x)成为经典风险极小化即损失函数极小化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\beta_m, \gamma_m}\sum_{i=1}^{N}L(y_i,\sum_{m=1}^{M}\beta_mb(x_i;\gamma_m))$$&lt;/div&gt;
&lt;p&gt;
前向分步算法（forward stagewise algorithm）求解这一优化问题的想法是：因为学习的是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数式，那么就可以简化优化的复杂度。具体的，每步只需优化如下损失函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\beta, \gamma}\sum_{i=1}^{N}L(y_i,\beta b(x_i;\gamma))$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;前向分步算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：训练数据集T；损失函数L(y,f(x))；基函数集&lt;span class="math"&gt;\({b(x;\gamma)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：加法模型f(x)&lt;/p&gt;
&lt;p&gt;（1）初始化&lt;span class="math"&gt;\(f_0(x)=0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）对m=1,2,...,M&lt;/p&gt;
&lt;p&gt;（a）极小化损失函数
&lt;/p&gt;
&lt;div class="math"&gt;$$(\beta_m, \gamma_m)=argmin_{\beta, \gamma}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i)+\beta b(x_i;\gamma))$$&lt;/div&gt;
&lt;p&gt;
 得到参数&lt;span class="math"&gt;\(\beta_m, \gamma_m\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（b）更新
&lt;/p&gt;
&lt;div class="math"&gt;$$f_m(x)=f_{m-1}(x)+\beta b(x;\gamma_m)$$&lt;/div&gt;
&lt;p&gt;（3）得到加法模型
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=f_M(x)=\sum_{m=1}^M\beta_mb(x;\gamma_m)$$&lt;/div&gt;
&lt;p&gt;这样优化问题就化为逐次求解各个&lt;span class="math"&gt;\(\beta_m, \gamma_m\)&lt;/span&gt;的优化问题。&lt;/p&gt;
&lt;h3&gt;前向分步算法与AdaBoost&lt;/h3&gt;
&lt;p&gt;AdaBoost算法是前向分步加法算法的特例。这时，模型是由基本分类器组成的加法模型，损失函数是指数函数。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第八章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 06 Aug 2014 19:56:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-06:adaboostsuan-fa.html</guid><category>读书笔记</category></item><item><title>支持向量机——SMO（序列最小最优化算法）</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-smoxu-lie-zui-xiao-zui-you-hua-suan-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;SVM的学习算法可以归结为凸二次规划问题。这样的凸二次规划问题你具有全局最优解，并且许多最优化算法可以用来求解，但是当训练样本容量很大，这些算法往往变得非常低效，以致无法使用。所以本文介绍了如何高效地实现支持向量机学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们将用序列最小最优化（sequential minimal optimization, SMO）算法，求解
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
在这个问题中，变量是拉格朗日乘子，一个变量&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;对应一个样本点&lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;；变量的总数等于样本容量N。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SMO算法是一种启发式算法，其基本思路是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果所有变量的解都满足此最优化问题的KKT条件，那么这个最优化问题的解就得到了（因为KKT条件是该最优化问题的充分必要条件）。否则选择两个变量，固定其他的变量，针对这两个问题构建一个二次规划问题。这个二次规划问题的解应该更接近二次规划问题的解（因为这会使得原始二次规划问题的目标函数值更小）。而且，这时子问题可以通过解析方法求解，这样就大大提高了整个算法的计算速度。&lt;/p&gt;
&lt;p&gt;每一次，子问题都有两个变量，一个是违反KKT条件最严重的那一个，另一个由约束条件自动确定。如此，SMO算法将原问题不断分解为子问题并对子问题求解，进而得到原问题的最终解。&lt;/p&gt;
&lt;p&gt;注意，每个子问题有两个变量，而不能是1个变量，因为当选择一个变量时，由于约束条件，其他变量的值就固定了该变量的值也就固定了。所以子问题中同时更新两个变量。&lt;/p&gt;
&lt;p&gt;SMO算法包括两个部分：&lt;/p&gt;
&lt;p&gt;（1）求解两个变量二次规划问题的解析方法&lt;/p&gt;
&lt;p&gt;（2）选择变量的启发式方法&lt;/p&gt;
&lt;h2&gt;两个变量二次规划问题的求解方法&lt;/h2&gt;
&lt;p&gt;不失一般性，假设选择的两个变量是&lt;span class="math"&gt;\(\alpha_1, \alpha_2\)&lt;/span&gt;，其他变量&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;固定。那么SMO的最优化问题的子问题可以写成
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha1, \alpha_2}W(\alpha_1, \alpha_2)=\frac{1}{2}K_{11}\alpha_1^2+\frac{1}{2}K_{22}\alpha_2^2-(\alpha_1+\alpha_2)+y_1y_2K_{12}\alpha_1\alpha_2+ y_1\alpha_1\sum_{i=3}^{N}\alpha_iy_iK_{i1}+y_2\alpha_2\sum_{i=3}^{N}\alpha_iy_iK_{i2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\alpha_1y_1 + \alpha_2y_2= -\sum_{i=3}^{N}\alpha_iy_i = \zeta $$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2$$&lt;/div&gt;
&lt;p&gt;
以上的目标函数式省略了不含&lt;span class="math"&gt;\(\alpha_1,\alpha_2\)&lt;/span&gt;的常数项。&lt;/p&gt;
&lt;p&gt;首先，我们分析下约束条件，然后求此约束条件下的极小。&lt;/p&gt;
&lt;p&gt;约束条件使得目标函数在一条平行于长度为C的正方形的对角线的线段上的最优值。这使得两个变量的最优化问题实质上是单变量的最优化问题，不妨考虑&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;的最优化问题。&lt;/p&gt;
&lt;p&gt;假设初始可行解为&lt;span class="math"&gt;\(\alpha_1^{old},\alpha_2^{old}\)&lt;/span&gt;，最优解为&lt;span class="math"&gt;\(\alpha_1^{new},\alpha_2^{new}\)&lt;/span&gt;。并假设在沿着约束方向未经剪辑&lt;sup id="fnref:unclipped"&gt;&lt;a class="footnote-ref" href="#fn:unclipped" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;时&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;的最优解为&lt;span class="math"&gt;\(\alpha_2^{new, unc}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;由于&lt;span class="math"&gt;\(\alpha_2^{new}\)&lt;/span&gt;需要满足不等式约束，所以最优值&lt;span class="math"&gt;\(\alpha_2^{new}\)&lt;/span&gt;的取值范围必须满足条件：
&lt;/p&gt;
&lt;div class="math"&gt;$$L \leq \alpha_2^{new} \leq H$$&lt;/div&gt;
&lt;p&gt;
其中L与H分别是&lt;span class="math"&gt;\(\alpha_2^{new}\)&lt;/span&gt;所在的对角线段端点的界，如下图所示。最优解必须在正方形内且在与对角线平行的线上。&lt;/p&gt;
&lt;p&gt;&lt;img alt="smo_alpha" src="./imgs/smo_alpha.png" /&gt;&lt;/p&gt;
&lt;p&gt;当&lt;span class="math"&gt;\(y_1=y_2\)&lt;/span&gt;时，它们可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_1 + \alpha_2= k$$&lt;/div&gt;
&lt;p&gt;
此时有：
&lt;/p&gt;
&lt;div class="math"&gt;$$L=max(0, \alpha_1^{old}+\alpha_2^{old}-C), H=min(C, \alpha_1^{old}+\alpha_2^{old})$$&lt;/div&gt;
&lt;p&gt;
计算过程：&lt;/p&gt;
&lt;p&gt;如图所示，先考虑L的取值。当直线为①情况时，L为0；当直线为②情况时，此时&lt;span class="math"&gt;\(\alpha_1'=C\)&lt;/span&gt;，代入&lt;span class="math"&gt;\(\alpha_1' + \alpha_2' = k\)&lt;/span&gt; 得到&lt;span class="math"&gt;\(\alpha_2'= L = k - \alpha_1' = k - C = \alpha_1 + \alpha_2 - C\)&lt;/span&gt;。所以&lt;span class="math"&gt;\(L=max(0, \alpha_1^{old}+\alpha_2^{old}-C)\)&lt;/span&gt;。然后考虑H的取值。当直线为①情况时，此时&lt;span class="math"&gt;\(\alpha_1'=0\)&lt;/span&gt;，代入&lt;span class="math"&gt;\(\alpha_1' + \alpha_2' = k\)&lt;/span&gt; 得到&lt;span class="math"&gt;\(\alpha_2'= H = k - \alpha_1' = k  = \alpha_1 + \alpha_2\)&lt;/span&gt;；当直线为②情况时，H为C。所以&lt;span class="math"&gt;\(H=min(C, \alpha_1^{old}+\alpha_2^{old})\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当&lt;span class="math"&gt;\(y_1 \neq y_2\)&lt;/span&gt;时，它们可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_1 - \alpha_2= k$$&lt;/div&gt;
&lt;p&gt;
此时有：
&lt;/p&gt;
&lt;div class="math"&gt;$$L=max(0, \alpha_2^{old}-\alpha_1^{old}-C), H=min(C, C+\alpha_2^{old}-\alpha_1^{old})$$&lt;/div&gt;
&lt;p&gt;为了方便，记
&lt;/p&gt;
&lt;div class="math"&gt;$$g(x)=\sum_{i=1}^{N}\alpha_iy_iKK(x_i,x)+b$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$E_i=g(x_i)-y_i=(\sum_{i=1}^{N}\alpha_iy_iKK(x_i,x)+b)-y_i,　i=1,2$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(E_i\)&lt;/span&gt;是函数g(x)对输入&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;的预测值与真实输出&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;之差。&lt;/p&gt;
&lt;p&gt;下面，先求沿着约束方向  未经剪辑时&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;的最优解&lt;span class="math"&gt;\(\alpha_2^{new, unc}\)&lt;/span&gt;；然后再求剪辑后&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;的解&lt;span class="math"&gt;\(\alpha_2^{new}\)&lt;/span&gt;。可以证明&lt;sup id="fnref:calculate"&gt;&lt;a class="footnote-ref" href="#fn:calculate" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_2^{new, unc}=\alpha_2^{old}+\frac{y_2(E_1 - E_2)}{\eta}$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha_2^{new}=\left\{\begin{matrix}
H,　\alpha_2^{new, unc}&amp;gt;H\\ 
\alpha_2^{new, unc},　0 \leq \alpha_2^{new, unc}\leq H\\ 
L,　\alpha_2^{new, unc}　&amp;lt; L
\end{matrix}\right.$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha_1^{new}=\alpha_1^{old}+y_1y_2(\alpha_2^{old}-\alpha_2^{new})$$&lt;/div&gt;
&lt;p&gt;
其中，
&lt;/p&gt;
&lt;div class="math"&gt;$$\eta=K_{11}+K_{22}-2K_{12}=||\phi(x_1)-\phi(x_2)||$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(\phi(x)\)&lt;/span&gt;是输入空间到特征空间的映射。&lt;/p&gt;
&lt;p&gt;这样就得到了最优化问题的解&lt;span class="math"&gt;\((\alpha_1^{new},\alpha_2^{new})\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;变量的选择方法&lt;/h2&gt;
&lt;p&gt;SMO算法在每个子问题中选择两个变量变化，其中至少一个变量是违反KKT条件的。&lt;/p&gt;
&lt;p&gt;（1）第一个变量的选择&lt;/p&gt;
&lt;p&gt;SMO称选择第1个变量的过程为外层循环。外层循环是在训练样本中选取违反KKT条件最严重的样本点，并将其对应的变量作为第1个变量。因此，需要检验训练样本点&lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;是否满足KKT条件。具体的，在&lt;a href="http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html"&gt;线性支持向量机学习算法&lt;/a&gt;中根据KKT条件有：&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown_w L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=w^*-\sum_{i=1}^{N}\alpha_i^*y_ix_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_b L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=-\sum_{i=1}^{N}\alpha_i^*y_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\xi L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=C-\alpha_i^*-\mu^*=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^*(y_i(w_i^*.x_i + b^*)-1+\xi_i^*) = 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$u_i^*\xi_i^* = 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$y_i(w_i^*.x_i + b^*)-1+\xi_i^* \geq 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\xi_i^* \geq 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha_i^* \geq 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$\mu_i^* \geq 0 $$&lt;/div&gt;
&lt;p&gt;
当&lt;span class="math"&gt;\(\alpha_i=0\)&lt;/span&gt;时，&lt;span class="math"&gt;\(\mu_i=C\)&lt;/span&gt;，那么松弛变量&lt;span class="math"&gt;\(\xi_i=0\)&lt;/span&gt;，得到&lt;span class="math"&gt;\(y_ig(x_i) \geq 1\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;当&lt;span class="math"&gt;\(0 &amp;lt; \alpha_i &amp;lt; C\)&lt;/span&gt;时，&lt;span class="math"&gt;\(\mu_i &amp;gt; 0\)&lt;/span&gt;，那么松弛变量&lt;span class="math"&gt;\(\xi_i=0\)&lt;/span&gt;，得到&lt;span class="math"&gt;\(y_ig(x_i) = 1\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;当&lt;span class="math"&gt;\(\alpha_i=C\)&lt;/span&gt;时，&lt;span class="math"&gt;\(\mu_i=0\)&lt;/span&gt;，那么松弛变量&lt;span class="math"&gt;\(\xi_i &amp;gt; 0\)&lt;/span&gt;，得到&lt;span class="math"&gt;\(y_ig(x_i) = 1 - \xi_i\)&lt;/span&gt;即&lt;span class="math"&gt;\(y_ig(x_i) \leq 1\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在检验过程中，外层循环首先遍历所有满足条件&lt;span class="math"&gt;\(0&amp;lt;\alpha_i &amp;lt; C\)&lt;/span&gt;的样本点，即在间隔边界上的支持向量点，检验它们是否满足KKT条件。如果都满足KKT条件，那么 再遍历整个数据集，检验它们是否满足KKT条件。&lt;/p&gt;
&lt;p&gt;（2）第2个变量的选择&lt;/p&gt;
&lt;p&gt;SMO称选择第2个变量的过程为内层循环。假设在外层循环中已经找到第1个变量&lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;，现在找第2个变量。第2个变量的选择标准是希望能使&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;有足够大的变化。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\alpha_2^{news}\)&lt;/span&gt;是依赖于&lt;span class="math"&gt;\(|E_1-E_2|\)&lt;/span&gt;的。一种简单的做法是选择&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;，使其对应的&lt;span class="math"&gt;\(|E_1-E_2|\)&lt;/span&gt;最大，因为&lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;已经确定，&lt;span class="math"&gt;\(E_1\)&lt;/span&gt;也确定了。为了节省时间，把所有的&lt;span class="math"&gt;\(E_i\)&lt;/span&gt;保存在一个列表中。&lt;/p&gt;
&lt;p&gt;如果上面的方法还是不能是目标函数由足够的下降，那么采用启发式规则继续选&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（3）计算阈值b和差值&lt;span class="math"&gt;\(E_i\)&lt;/span&gt;
每次完成两个变量的优化后，都要重新计算E，于是就还得重新计算阈值b。&lt;/p&gt;
&lt;p&gt;当&lt;span class="math"&gt;\(0&amp;lt;\alpha_1^{new}&amp;lt; C\)&lt;/span&gt;时，由KKT条件&lt;span class="math"&gt;\(y_ig(x_i) = 1\)&lt;/span&gt;及&lt;span class="math"&gt;\(y_i^2=1\)&lt;/span&gt;，有
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{i=1}^{N}\alpha_iy_iK_{i1}+b=y_1$$&lt;/div&gt;
&lt;p&gt;
于是
&lt;/p&gt;
&lt;div class="math"&gt;$$b_1^{new}=y_1-\sum_{i=3}^N\alpha_iy_iK_{i1}-\alpha_1^{new}y_1K_{11}-\alpha_2^{new}y_2K_{21}$$&lt;/div&gt;
&lt;div class="math"&gt;$$E_1=g(x_1)-y_1=\sum_{i=3}^N\alpha_iy_iK_{i1}+\alpha_1^{old}y_1K_{11}+\alpha_2^{old}y_2K_{21} + b^{old}-y_1$$&lt;/div&gt;
&lt;p&gt;
于是可得
&lt;/p&gt;
&lt;div class="math"&gt;$$b_1^{new}=-E_1-(\alpha_1^{new}-\alpha_1^{old})y_1K_{11}-(\alpha_2^{new}-\alpha_2^{old})y_2K_{21} + b^{old}$$&lt;/div&gt;
&lt;p&gt;同样如果&lt;span class="math"&gt;\(0&amp;lt;\alpha_2^{new}&amp;lt; C\)&lt;/span&gt;时，可得
&lt;/p&gt;
&lt;div class="math"&gt;$$b_2^{new}=-E_2-(\alpha_1^{new}-\alpha_1^{old})y_1K_{12}-(\alpha_2^{new}-\alpha_2^{old})y_2K_{22} + b^{old}$$&lt;/div&gt;
&lt;p&gt;如果&lt;span class="math"&gt;\(0&amp;lt;\alpha_1^{new}&amp;lt; C\)&lt;/span&gt;且&lt;span class="math"&gt;\(0&amp;lt;\alpha_2^{new}&amp;lt; C\)&lt;/span&gt;时，&lt;span class="math"&gt;\(b_1^{new}=b_2^{new}\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;如果&lt;span class="math"&gt;\(\alpha_1^{new},\alpha_2^{new}\)&lt;/span&gt;是0或者C，那么&lt;span class="math"&gt;\(b_1^{new}, b_2^{new}\)&lt;/span&gt;以及它们之间的数都是符合KKT条件的阈值，这时选择它们的中点作为&lt;span class="math"&gt;\(b^{new}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;每次完成两个变量的优化之后，更新对应的&lt;span class="math"&gt;\(E_i\)&lt;/span&gt;值，并将它们保存在列表中，&lt;span class="math"&gt;\(E_i\)&lt;/span&gt;值的更新要用到&lt;span class="math"&gt;\(b^{new}\)&lt;/span&gt;值，以及所有支持向量对应的&lt;span class="math"&gt;\(\alpha_j\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$E_i^{new}=(\sum_{S}\alpha_jy_jKK(x_i,x_j)+b^{new})-y_i$$&lt;/div&gt;
&lt;p&gt;
 其中，S是所有支持向量&lt;span class="math"&gt;\(x_j\)&lt;/span&gt;的集合。&lt;/p&gt;
&lt;h2&gt;SMO算法&lt;/h2&gt;
&lt;p&gt;输入：训练数据集T，精度&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：近似解&lt;span class="math"&gt;\(\widehat{\alpha}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）取初值&lt;span class="math"&gt;\(\alpha^{(0)}=0\)&lt;/span&gt;，令k=0&lt;/p&gt;
&lt;p&gt;（2）选取优化变量&lt;span class="math"&gt;\(\alpha_1^{(k)},\alpha_2^{(k)}\)&lt;/span&gt;，解析求解两个变量的最优化问题，求得最优解&lt;span class="math"&gt;\(\alpha_1^{(k+1)},\alpha_2^{(k+1)}\)&lt;/span&gt;，更新&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;为&lt;span class="math"&gt;\(\alpha^{(k+1)}\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;（3）若在精度&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt;范围内满足停机条件
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{i=1}^N\alpha_iy_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;div class="math"&gt;$$y_i.g(x_i)=\left\{\begin{matrix}
\geq 1, &amp;amp; {x_i|\alpha_1=0}\\ 
=1, &amp;amp; {x_i|0&amp;lt;\alpha_i&amp;lt;C}\\ 
\leq 1, &amp;amp; {x_i|\alpha_i=C}
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;则转（4）；否则令k=k+1，转（2）&lt;/p&gt;
&lt;p&gt;（4）取&lt;span class="math"&gt;\(\widehat{\alpha}=\alpha^{(k+1)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:unclipped"&gt;
&lt;p&gt;未经剪辑是指未考虑&lt;span class="math"&gt;\(0 \leq \alpha_i \leq C\)&lt;/span&gt;的约束条件时的值&amp;#160;&lt;a class="footnote-backref" href="#fnref:unclipped" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:calculate"&gt;
&lt;p&gt;求解过程如下：
记
&lt;div class="math"&gt;$$v_i = \sum_{j=3}^{N}\alpha_jy_jK(x_i,x_j)= g(x_i)- \sum_{j=1}^{2}\alpha_jy_jK(x_i,x_j)-b,　　i=1,2$$&lt;/div&gt;
目标函数变为：
&lt;div class="math"&gt;$$W(\alpha_1, \alpha_2)=\frac{1}{2}K_{11}\alpha_1^2+\frac{1}{2}K_{22}\alpha_2^2-(\alpha_1+\alpha_2)+y_1y_2K_{12}\alpha_1\alpha_2+y_1\alpha_1v_1+y_2\alpha_2v_2$$&lt;/div&gt;
可以将&lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;表示为:
&lt;div class="math"&gt;$$\alpha_1=(\zeta - y_2\alpha_2)y_1$$&lt;/div&gt;
代入目标函数，得到只含有&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;的式子，对&lt;span class="math"&gt;\(\alpha_2\)&lt;/span&gt;求导数，令其为0，并将&lt;span class="math"&gt;\(\alpha_1^{old} y_1 + \alpha_2^{old}y_2=  \zeta\)&lt;/span&gt;就可得到。 &amp;#160;&lt;a class="footnote-backref" href="#fnref:calculate" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 05 Aug 2014 10:02:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-05:zhi-chi-xiang-liang-ji-smoxu-lie-zui-xiao-zui-you-hua-suan-fa.html</guid><category>读书笔记</category></item><item><title>支持向量机——非线性支持向量机</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-fei-xian-xing-zhi-chi-xiang-liang-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;如果分类问题是非线性的，那么就要用到非线性支持向量机。非线性支持向量机主要特点就是利用核技巧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;核技巧&lt;/h2&gt;
&lt;h3&gt;非线性分类问题&lt;/h3&gt;
&lt;p&gt;利用非线性模型才能很好地进行分类的问题，就是非线性分类问题。如果能用&lt;span class="math"&gt;\(R^n\)&lt;/span&gt;中的一个超平面将正负例正确分开，则称这个问题为非线性可分问题。如下的例子，无法用直线（线性模型）将正负实例正确分开，但可以用一条椭圆（非线性模型）将它们正确分开。&lt;/p&gt;
&lt;p&gt;&lt;img alt="非线性可分例子" src="./imgs/nolinear.png" /&gt;&lt;/p&gt;
&lt;p&gt;通常进行一个非线性变换，将非线性问题变换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。例如，上图中将椭圆变换为右图中的直线，将非线性分类问题变换为线性分类问题。&lt;/p&gt;
&lt;p&gt;核技巧应用到支持向量机，其基本思想就是通过一个非线性变换将输入空间（欧氏空间&lt;span class="math"&gt;\(R^n\)&lt;/span&gt;或离散集合）对应于一个特征空间（希尔伯特空间&lt;sup id="fnref:Hilbert"&gt;&lt;a class="footnote-ref" href="#fn:Hilbert" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;H），使得在输入空间中的超平面模型对应于特征空间中的超平面模型（支持向量机）。这样，分类问题的学习任务通过在特征空间中求解线性支持向量机就可以完成。&lt;/p&gt;
&lt;h3&gt;核函数的定义&lt;/h3&gt;
&lt;p&gt;设&lt;span class="math"&gt;\(\chi\)&lt;/span&gt;是输入空间（欧氏空间&lt;span class="math"&gt;\(R^n\)&lt;/span&gt;的子集或离散集合），&lt;span class="math"&gt;\(H\)&lt;/span&gt;为特征空间（希尔伯特空间），如果存在一个从&lt;span class="math"&gt;\(\chi\)&lt;/span&gt;到&lt;span class="math"&gt;\(H\)&lt;/span&gt;的映射：
&lt;/p&gt;
&lt;div class="math"&gt;$$\phi(x): \chi \rightarrow H$$&lt;/div&gt;
&lt;p&gt;
使得所有&lt;span class="math"&gt;\(x,z \in \chi\)&lt;/span&gt;，函数K(x,z)满足条件：
&lt;/p&gt;
&lt;div class="math"&gt;$$K(x,z)=\phi(x).\phi(z)$$&lt;/div&gt;
&lt;p&gt;
则称&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;为&lt;strong&gt;核函数&lt;/strong&gt;，&lt;span class="math"&gt;\(\phi(x)\)&lt;/span&gt;为映射函数。&lt;/p&gt;
&lt;p&gt;核技巧的想法是，在学习与预测中只定义核函数&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;，而不是显式地定义映射函数&lt;span class="math"&gt;\(\phi\)&lt;/span&gt;。通常，直接计算&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;比较容易，而通过&lt;span class="math"&gt;\(\phi(x)\)&lt;/span&gt;和&lt;span class="math"&gt;\(\phi(z)\)&lt;/span&gt;计算&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;不容易。对于给定的核&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;，特征空间和映射函数的取法并不唯一。&lt;/p&gt;
&lt;h3&gt;核技巧在SVM中的应用&lt;/h3&gt;
&lt;p&gt;我们注意到在&lt;a href="http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html"&gt;线性支持向量机&lt;/a&gt;的对偶问题中，无论是目标函数还是决策函数（分离超平面）都只涉及输入实例与实例之间的内积。
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;
因此，上式的目标函数中的内积&lt;span class="math"&gt;\(x_ix_j\)&lt;/span&gt;可以用核函数&lt;span class="math"&gt;\(K(x_i,x_j)=\phi(x).\phi(j)\)&lt;/span&gt;来代替，这时对偶问题的目标函数就变为：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;
 同样，分类决策函数中的内积也可以用核函数代替：
 &lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(\sum_{i=1}^{N}\alpha_i^*y_iK(x_ix_j)+b^*)$$&lt;/div&gt;
&lt;p&gt;也就是说，在核函数&lt;span class="math"&gt;\(K(x_i,x_j)\)&lt;/span&gt;给定的条件下，可以利用解线性分类问题的方法求解非线性分类问题的支持向量机。学习是隐式地在特征空间进行得，不需要显示地定义特征空间和映射函数。这样的技巧就称为&lt;strong&gt;核技巧&lt;/strong&gt;。它是巧妙的利用线性分类学习方法与核函数解决非线性问题的技术。&lt;/p&gt;
&lt;p&gt;在实际应用中，选择核函数往往依赖于领域知识直接选择核函数，核函数选择的有效性需要通过实验验证。&lt;/p&gt;
&lt;h2&gt;正定核&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;满足什么条件才能称为核函数呢？&lt;/p&gt;
&lt;p&gt;通常，所说的核函数就是&lt;strong&gt;正定核函数（positive definite kernel function）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;依据函数&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;，构成一个希尔伯特空间，其步骤是：&lt;/p&gt;
&lt;h3&gt;（1）定义映射&lt;span class="math"&gt;\(\phi\)&lt;/span&gt;，构成向量空间S&lt;/h3&gt;
&lt;p&gt;先定义映射
&lt;/p&gt;
&lt;div class="math"&gt;$$\phi :x \rightarrow K(.,x)$$&lt;/div&gt;
&lt;p&gt;
根据这一映射，定义线性组合
&lt;/p&gt;
&lt;div class="math"&gt;$$f(.)=\sum_{i=1}^{m}\alpha_iK(.,x_i)$$&lt;/div&gt;
&lt;p&gt;
考虑由线性组合为元素的集合S。&lt;/p&gt;
&lt;h3&gt;（2）在S上定义内积，使其成为内积空间&lt;/h3&gt;
&lt;p&gt;在S上定义一个运算&lt;span class="math"&gt;\(*\)&lt;/span&gt;，证明运算&lt;span class="math"&gt;\(*\)&lt;/span&gt;是S的内积，赋予内积的向量空间为内积空间。因此，S是一个内积空间&lt;sup id="fnref:内积空间"&gt;&lt;a class="footnote-ref" href="#fn:内积空间" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h3&gt;（3）将内积空间S完备化为希尔伯特空间&lt;/h3&gt;
&lt;p&gt;这一希尔伯特空间称为再生核希尔伯特空间，这是由于核K具有再生性，即满足
&lt;/p&gt;
&lt;div class="math"&gt;$$K(.,x).f=f(x)$$&lt;/div&gt;
&lt;p&gt;
及
&lt;/p&gt;
&lt;div class="math"&gt;$$K(.,x).K(.,z)=K(x,z)$$&lt;/div&gt;
&lt;p&gt;
称为再生核。&lt;/p&gt;
&lt;h3&gt;（4）正定核的充要条件&lt;/h3&gt;
&lt;p&gt;设&lt;span class="math"&gt;\(K: \chi \times \chi \rightarrow R\)&lt;/span&gt;是对称函数，则&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;为正定核的充要条件是对任意&lt;span class="math"&gt;\(x_i \in \chi, i=1,2,...,m\)&lt;/span&gt;，对&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;对应的Gram矩阵&lt;sup id="fnref:gram"&gt;&lt;a class="footnote-ref" href="#fn:gram" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$K=[K(x_i,x_j)]_{m \times m}$$&lt;/div&gt;
&lt;p&gt;
是半正定矩阵&lt;sup id="fnref:正定矩阵"&gt;&lt;a class="footnote-ref" href="#fn:正定矩阵" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;所以如果一个函数K是核函数，那么其对应的核矩阵是&lt;strong&gt;对称&lt;/strong&gt;的&lt;strong&gt;半正定矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;证明：&lt;/strong&gt;
必要性：
由于&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;为&lt;span class="math"&gt;\(\chi \times \chi\)&lt;/span&gt;上的正定核，所以存在从&lt;span class="math"&gt;\(\chi\)&lt;/span&gt;到希尔伯特空间的映射&lt;span class="math"&gt;\(\phi\)&lt;/span&gt;，使得
&lt;/p&gt;
&lt;div class="math"&gt;$$K(x,z)=\phi(x)\phi(z)$$&lt;/div&gt;
&lt;p&gt;
于是，对于任一&lt;span class="math"&gt;\(x_1,x_2,...,x_m\)&lt;/span&gt;，构造K(x,z)关于&lt;span class="math"&gt;\(x_1,x_2,...,x_m\)&lt;/span&gt;的Gram矩阵
&lt;/p&gt;
&lt;div class="math"&gt;$$[K_{ij}]_{m \times n}=[K(x_i,x_j)]_{m \times n}$$&lt;/div&gt;
&lt;p&gt;
对于任意的向量z，有
&lt;/p&gt;
&lt;div class="math"&gt;$$z^TKz=\sum_i \sum_j z_iK_{ij}z_j = \sum_i \sum_j z_i \phi(x_i)^T\phi(x_j)z_j = ... = \sum_k(\sum_iz_i\phi_i(x_i))^2 \geq 0$$&lt;/div&gt;
&lt;p&gt;
所以K(x,z)是半正定矩阵。&lt;/p&gt;
&lt;p&gt;充分性：
K(x,z)对任意&lt;span class="math"&gt;\(x_i \in \chi, i=1,2,...,m\)&lt;/span&gt;，关于&lt;span class="math"&gt;\(x_1,x_2,...,x_m\)&lt;/span&gt;的Gram矩阵是半正定的。对于给定的K(x,z)可以构造从&lt;span class="math"&gt;\(\chi\)&lt;/span&gt;到某个希尔伯特空间的映射
&lt;/p&gt;
&lt;div class="math"&gt;$$\phi :x \rightarrow K(.,x)$$&lt;/div&gt;
&lt;p&gt;
可得
&lt;/p&gt;
&lt;div class="math"&gt;$$K(.,x).f=f(x)$$&lt;/div&gt;
&lt;p&gt;
及
&lt;/p&gt;
&lt;div class="math"&gt;$$K(.,x).K(.,z)=K(x,z)$$&lt;/div&gt;
&lt;p&gt;
即得
&lt;/p&gt;
&lt;div class="math"&gt;$$K(x,z)=\phi(x)\phi(z)$$&lt;/div&gt;
&lt;p&gt;
表面K(x,z)是&lt;span class="math"&gt;\(\chi \times \chi\)&lt;/span&gt;上的核函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核函数的另一定义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;是定义在&lt;span class="math"&gt;\(\chi \times \chi\)&lt;/span&gt; 上的对称函数，对任意&lt;span class="math"&gt;\(x_i \in \chi, i=1,2,...,m\)&lt;/span&gt;，&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;对应的Gram矩阵：
&lt;/p&gt;
&lt;div class="math"&gt;$$K=[K(x_i,x_j)]_{m \times m}$$&lt;/div&gt;
&lt;p&gt;
是半正定矩阵，则称&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;是正定核。&lt;/p&gt;
&lt;p&gt;对于一个具体函数&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;检验它是否是正定核函数不容易，因为要求对任意的输入集&lt;span class="math"&gt;\(x_i \in \chi, i=1,2,...,m\)&lt;/span&gt;，验证&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;对应的Gram矩阵是否为半定的。在实际问题中往往使用已有的核函数。&lt;/p&gt;
&lt;h3&gt;常用核函数&lt;/h3&gt;
&lt;p&gt;（1）多项式核函数
&lt;/p&gt;
&lt;div class="math"&gt;$$K(x,z)=(x.z+1)^p$$&lt;/div&gt;
&lt;p&gt;
分类决策函数成为：
 &lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(\sum_{i=1}^{N}\alpha_i^*y_i(x_i.z+1)^p+b^*)$$&lt;/div&gt;
&lt;p&gt;（2）高斯核函数
&lt;/p&gt;
&lt;div class="math"&gt;$$K(x,z)=exp(-\frac{||x-z||^2}{2\delta^2 })$$&lt;/div&gt;
&lt;p&gt;
对应的支持向量机是高斯径向基函数（radial basis function）分类器。
分类决策函数成为：
 &lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(\sum_{i=1}^{N}\alpha_i^*y_iexp(-\frac{||x-z||^2}{2\delta^2 })+b^*)$$&lt;/div&gt;
&lt;h3&gt;非线性支持向量机分类机&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;非线性支持向量机的学习算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：训练数据集T&lt;/p&gt;
&lt;p&gt;输出：分类决策函数&lt;/p&gt;
&lt;p&gt;（1）选取适当的核函数&lt;span class="math"&gt;\(K(x,z)\)&lt;/span&gt;和适当的参数C，构造并求解约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_jK(x_i,x_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
求得最优解&lt;span class="math"&gt;\(\alpha^* = (\alpha_1^* ... \alpha_n^*)^T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）选择一个&lt;span class="math"&gt;\(0 &amp;lt; \alpha_j^* &amp;lt; C\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_iK(x_i,x_j)$$&lt;/div&gt;
&lt;p&gt;（3）构造分类决策函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(\sum_{i=1}^{N}\alpha_i^*y_iK(x.x_i)+b^*)$$&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:Hilbert"&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E4%BC%AF%E7%89%B9%E7%A9%BA%E9%97%B4"&gt;希尔伯特空间&lt;/a&gt;又叫完备的内积空间，是有限维欧几里得空间的一个推广，使之不局限于实的情形和有限的维数，但又不失完备性。在一个复数向量空间H上的给定的内积&amp;lt;.,.&amp;gt;可以按照如下的方式导出一个范数（norm）
&lt;img alt="hilbert" src="http://upload.wikimedia.org/math/b/8/8/b88c416b87ffb50ed8de63d046ffd015.png" /&gt;
此空间称为是一个希尔伯特空间&amp;#160;&lt;a class="footnote-backref" href="#fnref:Hilbert" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:内积空间"&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4"&gt;内积空间&lt;/a&gt;是增添了一个额外的结构的向量空间。这个额外的结构叫做内积或标量积。&amp;#160;&lt;a class="footnote-backref" href="#fnref:内积空间" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:gram"&gt;
&lt;p&gt;是指内积空间中的一组向量之间的内积构成的矩阵
&lt;img alt="gram" src="http://science.scileaf.com/library/math/8/6/86f4eefe06b11fd7d0a4aa7e77e686bb.png" /&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:gram" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:正定矩阵"&gt;
&lt;p&gt;一个n×n的实对称矩阵M是正定的，当且仅当对于所有的非零实系数向量z，都有&lt;span class="math"&gt;\(z^TMz &amp;gt; 0\)&lt;/span&gt;。
M是半正定矩阵当且仅当对所有不为零&lt;span class="math"&gt;\(的x \in \mathbb{R}^n\)&lt;/span&gt;（或
&lt;span class="math"&gt;\(x \in \mathbb{C}^n\)&lt;/span&gt;），都有：&lt;span class="math"&gt;\(x^{*} M x \geq 0\)&lt;/span&gt;
若 M 为半正定阵，可以写作&lt;span class="math"&gt;\(M \geq 0\)&lt;/span&gt; 。如果 M 是正定阵，可以写作 &lt;span class="math"&gt;\(M &amp;gt; 0\)&lt;/span&gt; 。&amp;#160;&lt;a class="footnote-backref" href="#fnref:正定矩阵" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 04 Aug 2014 19:39:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-04:zhi-chi-xiang-liang-ji-fei-xian-xing-zhi-chi-xiang-liang-ji.html</guid><category>读书笔记</category></item><item><title>支持向量机——线性支持向量机</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;对于理想情况下线性可分的问题，可以使用上文介绍的线性可分支持向量机（硬间隔最大化）完美解决。但是，实际情况中，训练数据往往是线性不可分的，即在样本中存在噪声或特异点。此时，可以使用本文中介绍的更一般的学习算法——线性支持向量机（软间隔最大化）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;线性支持向量机&lt;/h2&gt;
&lt;p&gt;怎样才能把&lt;a href="http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html"&gt;上文中介绍的线性可分支持向量机&lt;/a&gt;扩展到线性不可分的数据集中呢？这就需要改变硬间隔最大化，使其成为软间隔最大化。&lt;/p&gt;
&lt;p&gt;通常情况下，数据集中存在一些特异点（outlier），将这些特异点去除后，剩下大部分样本点组成的集合是线性可分的。那些线性不可分的样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;意味着不能满足函数间隔大于等于1的约束条件（即&lt;span class="math"&gt;\(y_i(w.x_i + b)-1 \geq 0\)&lt;/span&gt;）。为了解决这个问题，可以为每个样本点引入一个松弛变量&lt;span class="math"&gt;\(\xi_i \geq 0\)&lt;/span&gt;，使函数间隔加上松弛变量后大于等于1.同时对每个松弛变量&lt;span class="math"&gt;\(\xi_i\)&lt;/span&gt;，支付一个代价&lt;span class="math"&gt;\(\xi_i\)&lt;/span&gt;。这样线性不可分的线性支持向量机的学习问题变成如下的凸二次规划问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b,\xi} \frac{1}{2}{||w||^2}+C\sum_{i=1}^{N}\xi_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　(1)y_i(w.x_i+b) \geq 1 - \xi_i　　(2)\xi_i \geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;这里，&lt;span class="math"&gt;\(C&amp;gt;0\)&lt;/span&gt;称为惩罚参数，一般由应用问题决定，C值越大对误分类的惩罚越大。所以，这里的最小化目标包含两层含义：①间隔间隔尽量大 ②误分类个数尽量小。&lt;/p&gt;
&lt;p&gt;这样可以和训练数据集可分时一样来考虑训练数据集线性不可分时的线性可支持向量机学习问题。相应于硬间隔最大化，它称为&lt;strong&gt;软间隔最大化&lt;/strong&gt;，并称这样的模型为&lt;strong&gt;线性支持向量机&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;学习的对偶算法&lt;/h2&gt;
&lt;p&gt;（1）构建拉格朗日函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b,\xi,\alpha,\mu)=\frac{1}{2}{||w||^2} +C\sum_{i=1}^{N}\xi_i- \sum_{i=1}^{N}\alpha_i(y_i(w.x_i+b)-1+\xi_i) - \sum_{i=1}^{N}\mu_i\xi_i$$&lt;/div&gt;
&lt;p&gt;
对每一个约束引进拉格朗日乘子&lt;span class="math"&gt;\(\alpha_i \geq 0, \mu_i \geq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题:
&lt;/p&gt;
&lt;div class="math"&gt;$$原始问题：min_{w,b,\xi}max_{\alpha_i \geq 0, \mu_i \geq 0}L(w, b, \xi, \alpha, \mu)$$&lt;/div&gt;
&lt;div class="math"&gt;$$对偶问题：max_{\alpha_i \geq 0, \mu_i \geq 0}min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)$$&lt;/div&gt;
&lt;p&gt;（3）求解对偶问题的解，需要先求&lt;span class="math"&gt;\(L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;对&lt;span class="math"&gt;\(w,b,\xi\)&lt;/span&gt;的极小，再求对&lt;span class="math"&gt;\(\alpha, \mu\)&lt;/span&gt;的极大&lt;/p&gt;
&lt;p&gt;（4）先求&lt;span class="math"&gt;\(min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;
将拉格朗日函数分别对&lt;span class="math"&gt;\(w,b,\xi\)&lt;/span&gt;求偏导数并令偏导数等于0. 将求得的结果代入拉格朗日函数中可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;（5）求&lt;span class="math"&gt;\(min_{w,b,\xi}L(w, b,  \xi, \alpha, \mu)\)&lt;/span&gt;对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大，即是对偶问题
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{\alpha}L(w, b,  \xi, \alpha, \mu)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$　　C-\alpha_i-\mu_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha_i \geq 0 $$&lt;/div&gt;
&lt;div class="math"&gt;$$\mu_i \geq 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;转化下可以得到对偶问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;得到&lt;strong&gt;线性支持向量机的学习算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：训练数据集T&lt;/p&gt;
&lt;p&gt;输出：分离超平面和分类决策函数&lt;/p&gt;
&lt;p&gt;（1）构造并求解约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{\alpha}L(w, b,  \xi, \alpha, \mu)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. 　\sum_{i=1}^{N}\alpha_iy_i = 0$$&lt;/div&gt;
&lt;div class="math"&gt;$$0 \leq \alpha_i \leq C 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
求得最优解&lt;span class="math"&gt;\(\alpha^* = (\alpha_1^* ... \alpha_n^*)^T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）计算
&lt;/p&gt;
&lt;div class="math"&gt;$$w^* = \sum_{i=1}^{N}\alpha_i^*y_ix_i$$&lt;/div&gt;
&lt;p&gt;
并选择一个&lt;span class="math"&gt;\(0 &amp;lt; \alpha_j^* &amp;lt; C\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_ix_j)$$&lt;/div&gt;
&lt;p&gt;（3）求得分离超平面
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
分类决策函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;是由&lt;a href="http://book.douban.com/subject/10590856/"&gt;KKT条件&lt;/a&gt;得到的。即：&lt;/p&gt;
&lt;p&gt;原始问题是凸二次规划问题，解满足KKT条件，可得：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown_w L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=w^*-\sum_{i=1}^{N}\alpha_i^*y_ix_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_b L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=-\sum_{i=1}^{N}\alpha_i^*y_i=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\xi L(w^*, b^*, \xi^*, \alpha^*, \mu^*)=C-\alpha_i^*-\mu^*=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^*(y_i(w_i^*.x_i + b^*)-1+\xi_i^*) = 0 
$$&lt;/div&gt;
&lt;p&gt;u_i^&lt;em&gt;\xi_i^&lt;/em&gt; = 0 &lt;/p&gt;
&lt;div class="math"&gt;$$
$$&lt;/div&gt;
&lt;p&gt;y_i(w_i^&lt;em&gt;.x_i + b^&lt;/em&gt;)-1+\xi_i^&lt;em&gt; \geq 0&lt;div class="math"&gt;$$
$$&lt;/div&gt;\xi_i^&lt;/em&gt; \geq 0 &lt;/p&gt;
&lt;div class="math"&gt;$$
$$&lt;/div&gt;
&lt;p&gt;\alpha_i^&lt;em&gt; \geq 0 &lt;div class="math"&gt;$$
$$&lt;/div&gt;\mu_i^&lt;/em&gt; \geq 0 $$&lt;/p&gt;
&lt;p&gt;w的解是唯一的，但是b的解不唯一。对于任一适合条件&lt;span class="math"&gt;\(0 &amp;lt; \alpha_j^* &amp;lt; C\)&lt;/span&gt;，都可以求出&lt;span class="math"&gt;\(b^*\)&lt;/span&gt;，所以实际计算时可以取在所有符合条件的样本点上的平均值。&lt;/p&gt;
&lt;h2&gt;支持向量&lt;/h2&gt;
&lt;p&gt;我们可以将&lt;span class="math"&gt;\(\alpha_i^* &amp;gt; 0\)&lt;/span&gt;的样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;称为&lt;strong&gt;支持向量&lt;/strong&gt;（软间隔的支持向量）。但是，这时的支持向量要比上文中介绍的复杂。&lt;/p&gt;
&lt;p&gt;实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;到间隔边界的距离为&lt;span class="math"&gt;\(\frac{\xi_i}{||w||}\)&lt;/span&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;lt; C\)&lt;/span&gt;，则&lt;span class="math"&gt;\(\xi_i = 0\)&lt;/span&gt;&lt;sup id="fnref:关系"&gt;&lt;a class="footnote-ref" href="#fn:关系" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;恰好落在间隔边界上；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* = C\)&lt;/span&gt;，&lt;span class="math"&gt;\(0&amp;lt; \xi_i &amp;lt; 1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;落在间隔边界与超平面之间，分类正确；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;gt; C\)&lt;/span&gt;，&lt;span class="math"&gt;\(\xi_i =1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;恰好在超平面上；&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(\alpha_i^* &amp;gt; C\)&lt;/span&gt;，&lt;span class="math"&gt;\(\xi_i &amp;gt;1\)&lt;/span&gt;，支持向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;位于分离超平面误分一侧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;合页损失函数&lt;/h2&gt;
&lt;p&gt;线性支持向量机学习还有另外一种解释，就是最小化以下目标函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{i=1}^{N}[1-y_i(w.x_i+b)]_++\lambda ||w||^2$$&lt;/div&gt;
&lt;p&gt;
目标函数中的第一项是经验损失或经验风险，函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(y(w.x+b))=[1-y_i(w.x_i+b)]_+$$&lt;/div&gt;
&lt;p&gt;
称为合页损失函数（hinge loss function）。下标"+"表示以下取正值的函数
&lt;/p&gt;
&lt;div class="math"&gt;$$[z]_+=\left\{\begin{matrix}
z, z &amp;gt; 0\\ 
0, z \leq 0
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
表示样本点被正确分类（z &amp;gt; 0），损失是0；错误分类损失为&lt;span class="math"&gt;\(1−y_i(w.x_i+b)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;合页损失函数的图形，以函数间隔&lt;span class="math"&gt;\(y(w.x+b)\)&lt;/span&gt;为横轴，纵轴是损失。由于函数形状像一个合页，故名合页损失函数。与感知机的损失函数相比，相当于右移1长度，所以合页损失函数对学习要求更高，不仅要分类正确，而且确信度足够高时损失才是0（大于1的部分）。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:关系"&gt;
&lt;p&gt;&lt;span class="math"&gt;\(C-\alpha_i-\mu_i=0\)&lt;/span&gt;并且&lt;span class="math"&gt;\(\mu_i^* \xi_i^*=0（从KTT条件可得）\)&lt;/span&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:关系" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 03 Aug 2014 14:54:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-03:zhi-chi-xiang-liang-ji-xian-xing-zhi-chi-xiang-liang-ji.html</guid><category>读书笔记</category></item><item><title>支持向量机——线性可分支持向量机</title><link>http://www.wengweitao.com/zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;支持向量机（support vector machine， SVM）是一种二类分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使之有别与感知机。支持向量机还包括核技巧，这使它成为实质上的非线性分类器。SVM的学习策略是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。SVM的学习算法是求解凸二次规划的最优算法。SVM学习方法包含构建由简至烦的模型：
- 线性可分支持向量机：当训练数据线性可分时，通过硬间隔最大化（hard margin maximization），学习一个线性分类器
- 线性支持向量机：当训练数据近似线性可分时，通过软间隔最大化（soft margin maximization），学习一个线性分类器，也称为软间隔支持向量机
- 非线性支持向量机：当训练数据线性不可分时，通过使用核技巧（kernel trick）即软间隔最大化，学习非线性支持向量机。
核函数（kernel function）表示将输入从输入空间映射到特征空间得到的特征向量之间的内积。通过使用核函数可以学习非线性支持向量机，等价于隐式地在高维的特征空间中学习线性支持向量机。这样的方法称为核技巧。核方法是比支持向量机更为一般的机器学习方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;线性可分支持向量机与硬间隔最大化&lt;/h2&gt;
&lt;h3&gt;线性可分支持向量机&lt;/h3&gt;
&lt;p&gt;支持向量机中，输入都由输入空间转换到特征空间将输入映射为特征向量，支持向量机的学习是在特征空间中进行的。&lt;/p&gt;
&lt;p&gt;假设训练数据是线性可分的，学习的目标是在特征空间中找到一个分离超平面，能将实例分到不同的类。分离超平面对应于方程&lt;span class="math"&gt;\(w.x+b=0\)&lt;/span&gt;，它由法向量w和截距b决定，可用(w,b)来表示。分离超平面将特征空间划分为两部分，一部分为正类，一部分为负类。法向量执行的一侧为正类，另一侧为负类。&lt;/p&gt;
&lt;p&gt;一般地，当训练数据集线性可分时，存在无穷个超平面可将两类数据正确分开。感知机利用误分类最小的策略，求得分离超平面，不过这时的解有无穷多个。线性可分支持向量机利用间隔最大化求最优分离超平面，这时，解是唯一的。&lt;/p&gt;
&lt;p&gt;给定线性可分训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
以及相应的分类决策函数
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;线性可分支持向量机&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;线性可分支持向量机对应着将两类数据正确划分并且间隔最大的直线。&lt;/p&gt;
&lt;h3&gt;函数间隔和几何间隔&lt;/h3&gt;
&lt;p&gt;一个点距离超平面的远近可以表示分类预测的确信程度（越远就越可信）。在超平面程&lt;span class="math"&gt;\(w.x+b=0\)&lt;/span&gt;确定的情况下，程&lt;span class="math"&gt;\(|w.x+b|\)&lt;/span&gt;能够相对地表示点x距离超平面的远近。而&lt;span class="math"&gt;\(w.x+b\)&lt;/span&gt;的符号与类标记y的符号是否一致能够表示分类是否正确。所以可以用&lt;span class="math"&gt;\(y(w.x+b)\)&lt;/span&gt;来表示分类的正确性及确信度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函数间隔：&lt;/strong&gt; 定义超平面(w,b)关于样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的函数间隔为
&lt;/p&gt;
&lt;div class="math"&gt;$$\widehat{\gamma_i}=y_i(w.x_i+b)  $$&lt;/div&gt;
&lt;p&gt;
定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的函数间隔之最小值。&lt;/p&gt;
&lt;p&gt;但是，对于函数间隔只要成比例地改变w和b，例如变为2w和2b，超平面并没有改变，但是函数间隔却成为原来的2倍。可以对分离超平面的法向量w加某些约束，如规范化，||w||=1，使得间隔是确定的。这时函数间隔成为几何间隔（geometric margin）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;几何间隔：&lt;/strong&gt; 定义超平面(w,b)关于样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的几何间隔为
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_i=y_i(\frac{w}{||w||}.x_i+\frac{b}{||w||})  $$&lt;/div&gt;
&lt;p&gt;
定义超平面(w,b)关于训练数据集T的函数间隔为超平面(w,b)关于T中所有样本点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的几何间隔之最小值。&lt;/p&gt;
&lt;p&gt;如果||w||=1，函数间隔和几何间隔相等。如果超平面参数w和b成比例地改变，函数间隔也按比例改变，而几何间隔不变。&lt;/p&gt;
&lt;h3&gt;间隔最大化&lt;/h3&gt;
&lt;p&gt;支持向量机学习的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。这里的集合间隔最大的分离超平面是唯一的，这里的间隔最大化又称为&lt;strong&gt;硬间隔最大化&lt;/strong&gt;。间隔最大化最直观的解释就是，不仅将正负实例点分开，而且对最难分的实例点（离超平面最近的点）也有足够大的确信度将它们分开。&lt;/p&gt;
&lt;h4&gt;1.最大间隔分离超平面&lt;/h4&gt;
&lt;p&gt;最大间隔分离超平面这个问题可以表示为下面的约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{w,b} \gamma$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(\frac{w}{||w||}.x_i+\frac{b}{||w||}) \geq \gamma 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
约束条件表示为超平面(w,b)关于每个训练样本点的几何间隔至少是&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;。考虑几何间隔和函数间隔的关系式：
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_i = \frac{\widehat{\gamma_i}}{||w||}$$&lt;/div&gt;
&lt;p&gt;
可以将这个问题改写为：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{w,b} \frac{\widehat{\gamma_i}}{||w||}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) \geq \gamma 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
&lt;strong&gt;函数间隔&lt;/strong&gt;的取值&lt;span class="math"&gt;\(\widehat{\gamma_i}\)&lt;/span&gt;的取值并不影响最优化问题的解。可以将w和b成比例的改变，对上面最优化问题的不等式约束没有影响。也就是说，它产生一个等价的最优化问题。这样，就可以取&lt;span class="math"&gt;\(\widehat{\gamma_i}=1\)&lt;/span&gt;。将&lt;span class="math"&gt;\(\widehat{\gamma_i}=1\)&lt;/span&gt;代入上面的最优化问题，&lt;strong&gt;可以得到线性可分支持向量机学习的最优化问题&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b} \frac{1}{2}{||w||^2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) - 1\geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
这是一个凸二次规划&lt;sup id="fnref:convex"&gt;&lt;a class="footnote-ref" href="#fn:convex" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;（convex quadratic programming）问题。
如果解出了约束最优化问题的&lt;span class="math"&gt;\(w^*, b^*\)&lt;/span&gt;那么就可以得到最大间隔分离超平面&lt;span class="math"&gt;\(w^*.x + b^*=0\)&lt;/span&gt;及分类决策函数，也就是线性可分支持向量机模型。&lt;/p&gt;
&lt;h4&gt;最大间隔分类超平面的存在唯一性&lt;/h4&gt;
&lt;p&gt;线性可分训练数据集的最大间隔分离超平面是&lt;strong&gt;存在且唯一的&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;支持向量和间隔边界&lt;/h4&gt;
&lt;p&gt;训练数据集的样本点中与分离超平面距离最近的样本点的实例称为&lt;strong&gt;支持向量（support vector）&lt;/strong&gt;。支持向量是使约束条件等号成立的点，即
&lt;/p&gt;
&lt;div class="math"&gt;$$y_i(w.x_i+b) - 1= 0 $$&lt;/div&gt;
&lt;p&gt;
对&lt;span class="math"&gt;\(y_i=+1\)&lt;/span&gt;的正例点，支持向量在超平面：
&lt;/p&gt;
&lt;div class="math"&gt;$$H_1: w.x_i+b = 1 $$&lt;/div&gt;
&lt;p&gt;
上，对&lt;span class="math"&gt;\(y_i=-1\)&lt;/span&gt;的负例点，支持向量在超平面：
&lt;/p&gt;
&lt;div class="math"&gt;$$H_2: w.x_i+b = -1 $$&lt;/div&gt;
&lt;p&gt;
上。&lt;span class="math"&gt;\(H_1\)&lt;/span&gt;与&lt;span class="math"&gt;\(H_2\)&lt;/span&gt;上的点就是支持向量。&lt;span class="math"&gt;\(H_1\)&lt;/span&gt;与&lt;span class="math"&gt;\(H_2\)&lt;/span&gt;是平行的，它们之间的距离称为&lt;strong&gt;间隔（margin）&lt;/strong&gt;。间隔依赖于超平面的法向量w，等于&lt;span class="math"&gt;\(\frac{2}{||w||}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在决定分离超平面时只有支持向量其作用，而其他实例点并不起作用，所以将这种分类模型称为支持向量机。支持向量的个数一般很少，所以支持向量机由很少的“重要”训练样本确定。&lt;/p&gt;
&lt;h3&gt;学习的对偶算法&lt;/h3&gt;
&lt;p&gt;为了求解线性可分支持向量机的最优化问题，将它作为原始最优化问题，应用拉格朗日对偶性。通过求解对偶问题得到原始问题的最优解，这就是线性可分支持向量机的对偶算法。这样做的优点，一是对偶问题往往更容易求解；而是自然引入核函数，进而推广到非线性分类问题。&lt;/p&gt;
&lt;p&gt;线性可分支持向量机学习的最优化问题为：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b} \frac{1}{2}{||w||^2}$$&lt;/div&gt;
&lt;div class="math"&gt;$$ s.t. 　y_i(w.x_i+b) - 1\geq 0 　i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;（1）构建拉格朗日函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b,\alpha)=\frac{1}{2}{||w||^2} - \sum_{i=1}^{N}\alpha_iy_i(w.x_i+b)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;
对每一个约束引进拉格朗日乘子&lt;span class="math"&gt;\(\alpha_i \geq 0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题:
&lt;/p&gt;
&lt;div class="math"&gt;$$原始问题：min_{w,b}max_{\alpha_i \geq 0}L(w, b, \alpha)$$&lt;/div&gt;
&lt;div class="math"&gt;$$对偶问题：max_{\alpha_i \geq 0}min_{w,b}L(w, b, \alpha)$$&lt;/div&gt;
&lt;p&gt;（3）求解对偶问题的解，需要先求&lt;span class="math"&gt;\(L(w, b, \alpha)\)&lt;/span&gt;对w,b的极小，再求对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大&lt;/p&gt;
&lt;p&gt;（4）先求&lt;span class="math"&gt;\(min_{w,b}L(w, b, \alpha)\)&lt;/span&gt;
将拉格朗日函数分别对w,b求偏导数并令偏导数等于0. 将求得的结果代入拉格朗日函数中可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b}L(w,b,\alpha)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;p&gt;（5）求&lt;span class="math"&gt;\(min_{w,b}L(w, b, \alpha)\)&lt;/span&gt;对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的极大，即是对偶问题
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{\alpha}L(w,b,\alpha)=-\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)+ \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. \sum_{i=1}^{N}\alpha_iy_i = 0　\alpha_i \geq 0, i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;可以将上面的目标函数由极大转换为求极小，得到&lt;strong&gt;线性可分支持向量机的学习算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：线性可分训练数据集T&lt;/p&gt;
&lt;p&gt;输出：分离超平面和分类决策函数&lt;/p&gt;
&lt;p&gt;（1）构造并求解约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{w,b}L(w,b,\alpha)=\frac{1}{2} \sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i\alpha_jy_iy_j(x_ix_j)- \sum_{i=1}^{N}\alpha_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. \sum_{i=1}^{N}\alpha_iy_i = 0　\alpha_i \geq 0, i=1,2,...,N$$&lt;/div&gt;
&lt;p&gt;
求得最优解&lt;span class="math"&gt;\(\alpha^* = (\alpha_1^* ... \alpha_n^*)^T\)&lt;/span&gt;（必须满足&lt;span class="math"&gt;\(\alpha_i \geq 0\)&lt;/span&gt;，如果找不到则最小值在边界上）.&lt;/p&gt;
&lt;p&gt;（2）计算
&lt;/p&gt;
&lt;div class="math"&gt;$$w^* = \sum_{i=1}^{N}\alpha_i^*y_ix_i$$&lt;/div&gt;
&lt;p&gt;
并选择一个&lt;span class="math"&gt;\(\alpha_j^* &amp;gt; 0\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$b^* = y_j - \sum_{i=1}^{N}\alpha_i^*y_i(x_ix_j)$$&lt;/div&gt;
&lt;p&gt;（3）求得分离超平面
&lt;/p&gt;
&lt;div class="math"&gt;$$w^*.x+b^*=0$$&lt;/div&gt;
&lt;p&gt;
分类决策函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w^*.x+b^*)$$&lt;/div&gt;
&lt;p&gt;其中，&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;是由&lt;a href="http://www.wengweitao.com/la-ge-lang-ri-dui-ou-xing-lagrange-duality.html"&gt;KKT条件&lt;/a&gt;得到的。&lt;span class="math"&gt;\(w^*与b^*\)&lt;/span&gt;只依赖于训练数据中对应于&lt;span class="math"&gt;\(\alpha_i &amp;gt; 0\)&lt;/span&gt;的样本点，而其他样本点对它们没有影响，因此，我们也可以将&lt;span class="math"&gt;\(\alpha_i &amp;gt; 0\)&lt;/span&gt;的样本点称为&lt;strong&gt;支持向量&lt;/strong&gt;。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第七章&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:convex"&gt;
&lt;p&gt;凸优化问题是指约束最优化问题
&lt;div class="math"&gt;$$min_x f(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. g_i(x) \leq0　h_i(x) \leq 0　i=1,2,...,N$$&lt;/div&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:convex" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 02 Aug 2014 20:32:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-02:zhi-chi-xiang-liang-ji-xian-xing-ke-fen-zhi-chi-xiang-liang-ji.html</guid><category>读书笔记</category></item><item><title>逻辑斯谛回归与最大熵模型</title><link>http://www.wengweitao.com/luo-ji-si-di-hui-gui-yu-zui-da-shang-mo-xing.html</link><description>&lt;blockquote&gt;
&lt;p&gt;逻辑斯谛回归（logistic regression）是统计学习中的经典分类方法，可以用于二类分类也可以用于多类分类。最大熵模型由最大熵原理推导出来，最大熵原理是概率模型学习或估计的一个准则，最大熵原理认为在所有可能的概率模型的集合中，熵最大的模型是最好的模型，最大熵模型也可以用于二类分类和多类分类。逻辑斯谛回归模型与最大熵模型都属于对数线性模型&lt;sup id="fnref:log"&gt;&lt;a class="footnote-ref" href="#fn:log" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;逻辑斯谛回归模型&lt;/h2&gt;
&lt;h3&gt;逻辑斯谛分布&lt;/h3&gt;
&lt;p&gt;设X是连续随机变量，X服从逻辑斯谛分布是指X具有如下分布函数和密度函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$F(X)=P(X \leq x)=\frac{1}{1+e^{-(x-u)/\gamma}}$$&lt;/div&gt;
&lt;div class="math"&gt;$$f(x)=F'(x)=\frac{e^{-(x-u)/\gamma}}{\gamma(1+e^{-(x-u)/\gamma})^2}$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(\mu\)&lt;/span&gt;为位置参数，&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;为形状参数。
&lt;strong&gt;分布函数的图形是一条S形曲线&lt;/strong&gt;（sigmoid curve），是中心对称的，曲线在中心点附近增长的较快，在两端增长的较慢。&lt;span class="math"&gt;\(\gamma\)&lt;/span&gt;的值越小，曲线在中心附近增长的越快。&lt;/p&gt;
&lt;h3&gt;逻辑斯谛回归模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;二项逻辑斯谛回归模型&lt;/strong&gt;是如下的条件概率分布：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{exp(w.x+b)}{1+exp(w.x+b)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|x)=\frac{1}{1+exp(w.x+b)}$$&lt;/div&gt;
&lt;p&gt;
随机变量X取值为实数，输出Y是0或1，w称为权值向量，b称为偏置。二项逻辑斯谛回归模型是一种分类模型，由条件概率P(Y|X)表示，形式为参数化的逻辑斯谛分布。&lt;/p&gt;
&lt;p&gt;有时为了方便，将权值向量和输入向量加以扩展，将偏置放入权值向量中，输入向量也增加一个值为1的分量，这时逻辑斯谛回归模型可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{exp(w.x)}{1+exp(w.x)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|x)=\frac{1}{1+exp(w.x)}$$&lt;/div&gt;
&lt;p&gt;对逻辑斯谛回归而言，x输入分类为Y=1的对数几率&lt;sup id="fnref:odds"&gt;&lt;a class="footnote-ref" href="#fn:odds" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;或logit函数是：
&lt;/p&gt;
&lt;div class="math"&gt;$$log\frac{P(Y=1|X)}{P(Y=0|X)}=w.x$$&lt;/div&gt;
&lt;p&gt;
也就是说再逻辑斯谛回归模型中，输出Y=1的对数几率是输入x的线性函数。或者&lt;strong&gt;说Y=1的对数几率是由输入x的线性函数&lt;span class="math"&gt;\(w.x\)&lt;/span&gt;表示的模型，即逻辑斯谛回归模型&lt;/strong&gt;。
线性函数越接近正无穷，概率值就越接近1；越接近负无穷，概率值就越接近0.这样的模型就是逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;而在使用线性回归进行二类分类的时候：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)= w_0 + w_1x_1 + ... + w_nx_n$$&lt;/div&gt;
&lt;p&gt;
存在两个问题：&lt;/p&gt;
&lt;p&gt;（1）等式两边的取值范围不同。左边为概率是[0, 1]，右边是无穷&lt;/p&gt;
&lt;p&gt;（2）实际很多问题中，概率P和输入并非简单的线性关系，在x很小或很大的时候，可能对于P的影响很小，而x在某些值附近可能对P的影响很大。&lt;/p&gt;
&lt;p&gt;逻辑斯谛回归模型对线性回归模型进行了修正，解决了以上的2个问题。&lt;/p&gt;
&lt;h3&gt;模型参数估计&lt;/h3&gt;
&lt;p&gt;我们通过监督学习的方法来估计模型参数。对于给定的训练数据集，可以运用极大似然法估计模型参数，从而得到逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;假设
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|X)=\pi(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=0|X)=1 - \pi(x)$$&lt;/div&gt;
&lt;p&gt;
似然函数可以表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$\prod_{i=1}^{N}[\pi(x_i)]^{y_i}[1 - \pi(x_i)]^{1-y_i}$$&lt;/div&gt;
&lt;p&gt;
对数似然函数表示为&lt;span class="math"&gt;\(L(w)\)&lt;/span&gt;，&lt;strong&gt;对&lt;span class="math"&gt;\(L(w)\)&lt;/span&gt;求最大值，得到w的估计值&lt;/strong&gt;。得到了
w就可以学到逻辑斯谛回归模型。&lt;/p&gt;
&lt;p&gt;这样问题就变成了以对数似然函数为目标的最优化问题。逻辑斯谛回归学习中常用的方法是梯度下降&lt;sup id="fnref:gradient descent"&gt;&lt;a class="footnote-ref" href="#fn:gradient descent" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;及拟牛顿法&lt;sup id="fnref:newton method"&gt;&lt;a class="footnote-ref" href="#fn:newton method" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;h3&gt;多项逻辑斯谛回归&lt;/h3&gt;
&lt;p&gt;上面介绍的是二类分类，也可以将逻辑斯谛回归模型推广到多类分类。假设离散型随机变量Y的取值集合是{1,2,...,K}，那么多项逻辑斯谛回归模型是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=k|x)=\frac{exp(w_k.x)}{1+\sum_{k=1}^{K-1}exp(w_k.x)}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(Y=K|x)=\frac{1}{1+\sum_{k=1}^{K-1}exp(w_k.x)}$$&lt;/div&gt;
&lt;hr /&gt;
&lt;h2&gt;最大熵模型&lt;/h2&gt;
&lt;h3&gt;最大熵原理&lt;/h3&gt;
&lt;p&gt;最大熵原理认为，学习概率模型时，在所有可能的概率模型中，熵最大的模型是最好的模型。通常用约束条件来确定概率模型的集合。最大熵原理认为选择的概率模型首先必须满足已有的事实，即约束条件。所以最大熵原理可以表示为：&lt;strong&gt;在满足约束条件的模型集合中选取熵最大的模型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在没有更多信息的情况下，可以按照满足约束条件下求等概率的方法估计概率分布（因为均匀分布，熵最大）。&lt;/p&gt;
&lt;h3&gt;最大熵模型的定义&lt;/h3&gt;
&lt;p&gt;将最大熵原理应用到分类就得到最大熵模型。&lt;/p&gt;
&lt;p&gt;给定训练数据集可以确定联合分布P(X,Y)的经验分布和边缘分布P(X)的经验分布&lt;span class="math"&gt;\(\widetilde{P}(X,Y)和\widetilde{P}(X)\)&lt;/span&gt;。用特征函数f(x,y)描述输入x和输出y之间的某一个事实，定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x,y)=\left\{\begin{matrix}
1,x与y满足某一事实\\ 
0,不满足某一事实
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;特征函数f(x,y)&lt;strong&gt;关于经验分布&lt;span class="math"&gt;\(\widetilde{P}(X,Y)\)&lt;/span&gt;的期望值&lt;/strong&gt;，用&lt;span class="math"&gt;\(E_\widetilde{P}(f)\)&lt;/span&gt;表示：
&lt;/p&gt;
&lt;div class="math"&gt;$$E_\widetilde{P}(f)=\sum_{x,y}\widetilde{P}(x,y)f(x,y)$$&lt;/div&gt;
&lt;p&gt;特征函数f(x,y)&lt;strong&gt;关于模型P(Y|X)与经验分布&lt;span class="math"&gt;\(\widetilde{P}(X)\)&lt;/span&gt;的期望值&lt;/strong&gt;，用&lt;span class="math"&gt;\(E_{P}(f)\)&lt;/span&gt;表示：
 &lt;/p&gt;
&lt;div class="math"&gt;$$E_p(f)=\sum_{x,y}\widetilde{P}(X)P(y|x)f(x,y)$$&lt;/div&gt;
&lt;p&gt;如果模型可以获取训练数据中的信息，那么可以假设以上两个期望值相等：
 &lt;/p&gt;
&lt;div class="math"&gt;$$E_\widetilde{P}(f)=E_p(f)$$&lt;/div&gt;
&lt;p&gt;
 或
 &lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{x,y}\widetilde{P}(x,y)f(x,y)=\sum_{x,y}\widetilde{P}(X)P(y|x)f(x,y)$$&lt;/div&gt;
&lt;p&gt;
以上两式作为&lt;strong&gt;模型学习的约束条件&lt;/strong&gt;。假如有n个特征函数&lt;span class="math"&gt;\(f_i(x,y)， i=1,2,...,n\)&lt;/span&gt;那么就有&lt;em&gt;n个约束条件&lt;/em&gt;。&lt;/p&gt;
&lt;h3&gt;最大熵模型的学习&lt;/h3&gt;
&lt;p&gt;最大熵模型的学习可以形式化为约束最优化问题。&lt;/p&gt;
&lt;p&gt;给定训练数据集T已经特征函数&lt;span class="math"&gt;\(f_i(x,y)， i=1,2,...,n\)&lt;/span&gt;，最大熵模型的学习等价于约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$max_{P \in C} H(P)=-\sum_{x,y}\widetilde{P}(x)P(y|x)logP(y|x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. E_\widetilde{P}(f)=E_p(f)， i=1,2,...,n　并且　\sum_yP(y|x)=1$$&lt;/div&gt;
&lt;p&gt;
按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$min_{P \in C} -H(P)=\sum_{x,y}\widetilde{P}(x)P(y|x)logP(y|x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. E_\widetilde{P}(f)-E_p(f)=0， i=1,2,...,n　并且　\sum_yP(y|x)=1$$&lt;/div&gt;
&lt;p&gt;
求解以上最优化问题，所得出的解，就是最大熵模型学习的解。&lt;/p&gt;
&lt;p&gt;这里，将约束最优化问题的原始问题转换为无约束最优化的对偶问题，通过求解对偶问题求解原始问题。&lt;/p&gt;
&lt;p&gt;（1）引入拉格朗日乘子，定义拉格朗日函数&lt;span class="math"&gt;\(L(P,w)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;（2）首先求解&lt;span class="math"&gt;\(L(P,w)\)&lt;/span&gt;关于P的极小化问题，固定拉格朗日乘子&lt;span class="math"&gt;\(w_0,w_1,...,w_n\)&lt;/span&gt;，对P求偏导数&lt;/p&gt;
&lt;p&gt;（3）另各偏导数等于0，解出各个P，得到&lt;span class="math"&gt;\(min_PL(P,w)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）求解&lt;span class="math"&gt;\(L(P_w,w)\)&lt;/span&gt;关于w的极大化问题&lt;/p&gt;
&lt;p&gt;（5）令&lt;span class="math"&gt;\(L(P_w,w)\)&lt;/span&gt;对w的各偏导数为0&lt;/p&gt;
&lt;p&gt;（6）得到最大熵模型&lt;/p&gt;
&lt;p&gt;可以求解得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}exp(\sum_{i=1}^{n}w_if_i(x,y))$$&lt;/div&gt;
&lt;p&gt;
其中
&lt;/p&gt;
&lt;div class="math"&gt;$$Z_w(x)=\sum_{y}exp(\sum_{i=1}^{n}w_if_i(x,y))$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(Z_w(x)\)&lt;/span&gt;称为&lt;strong&gt;规范化因子&lt;/strong&gt;；&lt;span class="math"&gt;\(f_i(x,y)\)&lt;/span&gt;是特征函数；&lt;span class="math"&gt;\(w_i\)&lt;/span&gt;是特征的权值。有上式表示的模型&lt;span class="math"&gt;\(P_w=P_w(y|x)\)&lt;/span&gt;就是最大熵模型。最后，最大熵模型的学习归结为对偶函数的极大化。&lt;/p&gt;
&lt;h3&gt;极大似然函数&lt;/h3&gt;
&lt;p&gt;可以证明对偶函数的极大化等价于最大熵模型的极大似然估计。这样最大熵模型的学习问题就转化为具体求解对数似然函数极大化或对偶函数极大化问题。&lt;/p&gt;
&lt;p&gt;最大熵模型与逻辑斯谛回归模型有类似的形式，它们又称为&lt;strong&gt;对数线性模型(log linear model)&lt;/strong&gt;。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;模型学习的最优化选择&lt;/h2&gt;
&lt;p&gt;最大熵模型与逻辑斯谛回归模型学习归结为以似然函数为目标函数的最优化问题，通常通过迭代算法求解。这时的目标函数是光滑的凸函数，因此多种最优化的方法都适用，保证能找到全局最优解。常用的方法有改进的迭代尺度法、梯度下降法、牛顿法或拟牛顿法。牛顿法或拟牛顿法一般收敛速度更快。&lt;/p&gt;
&lt;h3&gt;改进的迭代尺度法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;改进的迭代尺度法（improved iterative scaling, IIS）&lt;/strong&gt;是一种最大熵模型学习的最优化算法。IIS的想法是：假设最大熵模型的当前的参数向量是&lt;span class="math"&gt;\(w\)&lt;/span&gt;，我们希望找到一个新的参数向量&lt;span class="math"&gt;\(w=w+\delta\)&lt;/span&gt;，使得模型的对数似然函数值增大。如果能有一种参数向量的更新方法&lt;span class="math"&gt;\(w \rightarrow w+\delta\)&lt;/span&gt;，那么就可以重复使用这一方法，直到找到对数似然函数的最大值。&lt;/p&gt;
&lt;h3&gt;拟牛顿法&lt;/h3&gt;
&lt;p&gt;最大熵模型还可以使用牛顿法或拟牛顿法。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第六章&lt;/p&gt;
&lt;p&gt;http://blog.csdn.net/lilyth_lilyth/article/details/10032993&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:log"&gt;
&lt;p&gt;对数线性模型是对线性模型的一个变形，使用原始数据的对数建模。&amp;#160;&lt;a class="footnote-backref" href="#fnref:log" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:odds"&gt;
&lt;p&gt;一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值。&amp;#160;&lt;a class="footnote-backref" href="#fnref:odds" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:gradient descent"&gt;
&lt;p&gt;参考我之前的另一篇文章&lt;a href="http://www.wengweitao.com/ti-du-xia-jiang-fa.html"&gt;梯度下降法&lt;/a&gt; &amp;#160;&lt;a class="footnote-backref" href="#fnref:gradient descent" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:newton method"&gt;
&lt;p&gt;参考我之前的另一篇文章&lt;a href="http://www.wengweitao.com/niu-dun-fa.html"&gt;牛顿法&lt;/a&gt;&amp;#160;&lt;a class="footnote-backref" href="#fnref:newton method" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 01 Aug 2014 09:53:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-08-01:luo-ji-si-di-hui-gui-yu-zui-da-shang-mo-xing.html</guid><category>读书笔记</category></item><item><title>牛顿法</title><link>http://www.wengweitao.com/niu-dun-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;牛顿法是近似求解方程的方法，方法是使用函数的泰勒级数的前面几项来寻找方程的根。在统计学习中，牛顿法（Newton method）和拟牛顿法（quasi Newton method）也是&lt;strong&gt;求解无约束最优化问题&lt;/strong&gt;的常用方法。有&lt;strong&gt;收敛速度快&lt;/strong&gt;的优点。牛顿法是&lt;strong&gt;迭代方法&lt;/strong&gt;，每一步需要求解目标函数的海森矩阵（Hessian matrix）的逆矩阵，计算比较复杂。拟牛顿法通过正定矩阵近似海赛矩阵的逆矩阵或海赛矩阵，简化了这一过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;牛顿法&lt;/h2&gt;
&lt;h3&gt;目标&lt;/h3&gt;
&lt;p&gt;考虑无约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$minf(x)$$&lt;/div&gt;
&lt;p&gt;其中&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;为目标函数的极小点。求出f(x)的极小点 &lt;span class="math"&gt;\(x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先，我们先了解下泰勒级数与海森矩阵。&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;泰勒级数&lt;/h4&gt;
&lt;p&gt;若函数f（x）在点的某一临域内具有直到（n+1）阶导数，则在该邻域内f（x）的n阶泰勒公式为
用无限项的级数连加式来表示一个函数，这些相加的项由函数在某一点的导数求得。在该点邻域内f（x）的n阶泰勒公式表示为&lt;img alt="泰勒级数" src="http://upload.wikimedia.org/math/0/2/8/02837e50dddb76c237328172e2040135.png" /&gt;。
对于二阶泰勒展开，二阶的项可以使用海森矩阵来表示。&lt;/p&gt;
&lt;h4&gt;海森矩阵&lt;/h4&gt;
&lt;p&gt;海森矩阵（Hessian matrix）是一个自变量为向量的实值函数的二阶偏导数组成的方块矩阵。可以表示为：
&lt;img alt="海森矩阵" src="http://upload.wikimedia.org/math/d/c/e/dce355e43fb1539863302f482da7e6f6.png" /&gt;&lt;/p&gt;
&lt;h3&gt;牛顿法算法&lt;/h3&gt;
&lt;p&gt;在中学的数学课本上，我们已经接触过牛顿法，它是一种近似求解方程的方法。&lt;/p&gt;
&lt;p&gt;我们先看下求解一元方程的牛顿法。假设要求f(x)=0的根，方法使用f(x)的泰勒级数的前面几项来寻找方程f(x)=0的根。&lt;/p&gt;
&lt;p&gt;（1）选择一个接近函数f(x)根的点&lt;span class="math"&gt;\(x_0\)&lt;/span&gt;，计算&lt;span class="math"&gt;\(x_0\)&lt;/span&gt;在该点的值&lt;span class="math"&gt;\(f(x_0)\)&lt;/span&gt;与切线斜率&lt;span class="math"&gt;\(f'(x_0)\)&lt;/span&gt;；&lt;/p&gt;
&lt;p&gt;（2）计算经过点&lt;span class="math"&gt;\((x_0, f(x_0))\)&lt;/span&gt;且斜率为&lt;span class="math"&gt;\(f'(x_0)\)&lt;/span&gt;的直线与x轴的交点，即方程&lt;span class="math"&gt;\(y=f'(x_0)(x - x_0) - f(x_0)\)&lt;/span&gt;与x轴的交点，也就是求如下方程的解：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x_0) = f'(x_0)(x_0 - x)$$&lt;/div&gt;
&lt;p&gt;（3）将所求的点的x坐标记为&lt;span class="math"&gt;\(x_1\)&lt;/span&gt;，通常&lt;span class="math"&gt;\(x_1\)&lt;/span&gt;会比&lt;span class="math"&gt;\(x_0\)&lt;/span&gt;更接近方程的根。我们利用&lt;span class="math"&gt;\(x_1\)&lt;/span&gt;继续迭代：
&lt;/p&gt;
&lt;div class="math"&gt;$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$&lt;/div&gt;
&lt;p&gt;（4）每次迭代，都将更接近最终的根。&lt;/p&gt;
&lt;p&gt;举一个例子，求&lt;span class="math"&gt;\(f(x) = x^2 - x - 2\)&lt;/span&gt;的根，对两边求导的&lt;span class="math"&gt;\(f'(x) = 2x - 1\)&lt;/span&gt;，假设&lt;span class="math"&gt;\(x_0 = 3\)&lt;/span&gt;。
&lt;/p&gt;
&lt;div class="math"&gt;$$x_1 = x_0 + \frac{f(x_0)}{f'(x_0)} = 2.2$$&lt;/div&gt;
&lt;div class="math"&gt;$$x_2 = x_1 + \frac{f(x_1)}{f'(x_1)} = 2.011764705882353$$&lt;/div&gt;
&lt;div class="math"&gt;$$x_3 = x_2 + \frac{f(x_2)}{f'(x_2)} = 2.00004577706569$$&lt;/div&gt;
&lt;p&gt;
可以看到&lt;span class="math"&gt;\(x_3\)&lt;/span&gt;已经非常接近函数的一个根2了。&lt;/p&gt;
&lt;p&gt;回到，我们在本文开头，提出的目标，求解的过程与上面的例子类似，所不同的是，这里的x是一个向量，而且求的是函数f(x)导数f'(x)的根。&lt;/p&gt;
&lt;p&gt;函数f(x)有极值的必要条件是在极值点处一阶导数为0，即梯度向量为0.特别是当&lt;span class="math"&gt;\(H(x^{(k)})\)&lt;/span&gt;是正定矩阵时，函数f(x)的极值为极小值。
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=0$$&lt;/div&gt;
&lt;p&gt;
假设f(x)具有二阶连续偏导数，则将f(x)在第k次迭代值&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;邻域内进行二阶展开。&lt;/p&gt;
&lt;p&gt;每次迭代从点&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;开始，求目标函数的极小点，作为第k+1次迭代值&lt;span class="math"&gt;\(x^{(k+1)}\)&lt;/span&gt;。对将f(x)在第k次迭代值&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;邻域内进行二阶展开，然后对x求导有：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=g_k + H_k(x-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;，&lt;span class="math"&gt;\(H_k\)&lt;/span&gt;是f(x)的海森矩阵在&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;的值。
假设&lt;span class="math"&gt;\(x^{(k+1)}\)&lt;/span&gt;满足：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x^{(k+1)})=0$$&lt;/div&gt;
&lt;p&gt;
由前面两个式子，可以得到：
&lt;/p&gt;
&lt;div class="math"&gt;$$g_k + H_k(x^{(k+1)}-x^{(k)})=0$$&lt;/div&gt;
&lt;p&gt;
因此可得
&lt;/p&gt;
&lt;div class="math"&gt;$$x^{(k+1)}=x^{(k)}+p_k  \; \; \; 其中H_kp_k=-g_k$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：目标函数f(x)，梯度&lt;span class="math"&gt;\(g(x)=\bigtriangledown f(x)\)&lt;/span&gt;矩阵,海森矩阵&lt;span class="math"&gt;\(H(x)\)&lt;/span&gt;，精度要求&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：f(x)的极小值点&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）取初始点&lt;span class="math"&gt;\(x^{(0)}\)&lt;/span&gt;，置k=0&lt;/p&gt;
&lt;p&gt;（2）计算&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）若&lt;span class="math"&gt;\(\left \| g_k \right \| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k)}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（4）计算&lt;span class="math"&gt;\(H_k=H(x^{(k)})\)&lt;/span&gt;，并求&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$p_k=-H_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;（5）置&lt;span class="math"&gt;\(x^{(k+1)}=x^{(k)}+p_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（6）置k=k+1，转（2）&lt;/p&gt;
&lt;p&gt;步骤（4）中求&lt;span class="math"&gt;\(p_k=-H_k^{-1}g_k\)&lt;/span&gt;，先求&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;计算比较复杂，所以有其他改进算法。&lt;/p&gt;
&lt;h2&gt;拟牛顿法思路&lt;/h2&gt;
&lt;p&gt;考虑用一个n阶矩阵&lt;span class="math"&gt;\(G_k=G(x^{(k)})\)&lt;/span&gt;来代替&lt;span class="math"&gt;\(H_k^{-1}=H^{-1}(x^{(k)})\)&lt;/span&gt;。这就是拟牛顿法的基本想法。&lt;/p&gt;
&lt;p&gt;将&lt;span class="math"&gt;\(x=x^{(k+1)}\)&lt;/span&gt;代入下式：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown f(x)=g_k + H_k(x-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
得到
&lt;/p&gt;
&lt;div class="math"&gt;$$g_{k+1} - g_k = H_k(x^{(k+1)}-x^{(k)})$$&lt;/div&gt;
&lt;p&gt;
记&lt;span class="math"&gt;\(y_k=g_{k+1} - g_k, \delta_k = x^{(k+1)}-x^{(k)}\)&lt;/span&gt;，则
&lt;/p&gt;
&lt;div class="math"&gt;$$y_k = H_k\delta_k$$&lt;/div&gt;
&lt;p&gt;
或
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta_k = H_k^{-1}y_k$$&lt;/div&gt;
&lt;p&gt;
上式就称为拟牛顿条件。&lt;/p&gt;
&lt;div class="math"&gt;$$x=x^{(k)}+\lambda p_k = x^{(k)}-\lambda H_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;
所以f(x)在&lt;span class="math"&gt;\(x^{(k)}\)&lt;/span&gt;的泰勒展开式可以近似写成：
&lt;/p&gt;
&lt;div class="math"&gt;$$ f(x) = f(x^{(k)})-\lambda g_k^TH_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;
因为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;是正定的，当&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;为一个充分小的正数时，总有&lt;span class="math"&gt;\(f(x)&amp;lt; f(x^{(k)})\)&lt;/span&gt;，也就是说&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;是下降方向。&lt;/p&gt;
&lt;p&gt;拟牛顿法将&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;的近似，要求矩阵&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;满足同样的条件。首先，&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;是正定的，同时&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;满足下面的拟牛顿条件：
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta_k = G_{k+1}y_k$$&lt;/div&gt;
&lt;p&gt;
按照拟牛顿条件选择将&lt;span class="math"&gt;\(G_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k^{-1}\)&lt;/span&gt;的近似或者将&lt;span class="math"&gt;\(B_k\)&lt;/span&gt;作为&lt;span class="math"&gt;\(H_k\)&lt;/span&gt;的近似的算法就称为&lt;strong&gt;拟牛顿法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;按照拟牛顿条件，在每次迭代中可以选择更新矩阵&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$G_{k+1} = G_{k} + \Delta G_{k} $$&lt;/div&gt;
&lt;p&gt;
这种选择有一定的灵活性，因此有多种具体实现方法。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DFP算法&lt;/strong&gt;：选择&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;的方法是，假设每一步迭代中矩阵&lt;span class="math"&gt;\(G_{k+1}\)&lt;/span&gt;是由&lt;span class="math"&gt;\(G_{k}加上两个附加项构成\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;BFGS算法&lt;/strong&gt;: 最流行的拟牛顿算法。BFGS算法与DFP算法类似，只是采用的B来近似H&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Broyden类算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;BFGS的详细算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时相应的拟牛顿条件是
&lt;/p&gt;
&lt;div class="math"&gt;$$B_{k+1}\delta_k = y_k$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$B_{k+1}=B_{k}+P_{k}+Q_{k}$$&lt;/div&gt;
&lt;p&gt;
找到适合条件的&lt;span class="math"&gt;\(P_{k}和Q_{k}\)&lt;/span&gt;可以求得&lt;span class="math"&gt;\(B_{k+1}\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;输入：目标函数f(x)，梯度&lt;span class="math"&gt;\(g(x)=\bigtriangledown f(x)\)&lt;/span&gt;矩阵，精度要求&lt;span class="math"&gt;\(\varepsilon\)&lt;/span&gt; （不需要输入海森矩阵）&lt;/p&gt;
&lt;p&gt;输出：f(x)的极小值点&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）取初始点&lt;span class="math"&gt;\(x^{(0)}\)&lt;/span&gt;，取&lt;span class="math"&gt;\(B_0\)&lt;/span&gt;为正定对称矩阵，置k=0&lt;/p&gt;
&lt;p&gt;（2）计算&lt;span class="math"&gt;\(g_k=\bigtriangledown f(x^{(k)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（3）若&lt;span class="math"&gt;\(|\left \| g_k \right \|| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k)}\)&lt;/span&gt; ，否则转向（4）&lt;/p&gt;
&lt;p&gt;（4）计算&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$p_k=-B_k^{-1}g_k$$&lt;/div&gt;
&lt;p&gt;（5）一维搜索：求&lt;span class="math"&gt;\(\lambda_k\)&lt;/span&gt;使得
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x^{(k)}+\lambda_k p_k) = min_{\lambda \geq 0}f(x^{(k)}+\lambda_k p_k)$$&lt;/div&gt;
&lt;p&gt;（6）置&lt;span class="math"&gt;\(x^{(k+1)}=x^{(k)}+\lambda_k p_k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（7）计算&lt;span class="math"&gt;\(g_{k+1} =g(x^{(k+1)})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（8）若&lt;span class="math"&gt;\(|\left \| g_{k+1} \right \|| &amp;lt; \varepsilon\)&lt;/span&gt;，则停止计算，得近似解&lt;span class="math"&gt;\(x^*=x^{(k+1)}\)&lt;/span&gt; ，否则计算出&lt;span class="math"&gt;\(B_{k+1}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（9）置k=k+1，转（4）&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 30 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-30:niu-dun-fa.html</guid><category>基本概念</category></item><item><title>拉格朗日对偶性（Lagrange Duality）</title><link>http://www.wengweitao.com/la-ge-lang-ri-dui-ou-xing-lagrange-duality.html</link><description>&lt;blockquote&gt;
&lt;p&gt;在求解约束优化问题的时候，常常利用拉格朗日对偶性（Lagrange Duality）将原始问题转化为对偶问题，通过求解对偶问题而得到原始问题的解。该方法用在许多统计学习方法中，如最大熵模型和SVM等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;原始问题&lt;/h2&gt;
&lt;h3&gt;原始最优化问题&lt;/h3&gt;
&lt;p&gt;考虑最优化问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$min_x f(x)$$&lt;/div&gt;
&lt;div class="math"&gt;$$s.t. c_i(x) \leq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$h_j(x) = 0   \:\:\:\:\: j=1,2,...,l$$&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;称此约束最优化问题为原始最优化问题或原始问题。&lt;/p&gt;
&lt;h3&gt;广义拉格朗日函数&lt;/h3&gt;
&lt;p&gt;为了解决原始问题，我们先引入&lt;strong&gt;广义拉格朗日（generalized Lagrangian）函数&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x, \alpha, \beta) = f(x) + \sum_{i=1}^{k}\alpha_i  c_i(x) + \sum_{j=1}^{l}\beta_j h_j(x)$$&lt;/div&gt;
&lt;p&gt;
这里的&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;和&lt;span class="math"&gt;\(\beta_j\)&lt;/span&gt;称为&lt;strong&gt;拉格朗日乘子&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;极小极大问题&lt;/h3&gt;
&lt;p&gt;现在考虑&lt;span class="math"&gt;\(L(x, \alpha, \beta)\)&lt;/span&gt;的最大值：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) = max_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
上式中的下标p代表“primal（原始问题）”。如果上式中的x不满足原始问题的约束条件（即存在某些i使得&lt;span class="math"&gt;\(c_i(x)&amp;gt;0\)&lt;/span&gt;或者&lt;span class="math"&gt;\(h_i(x) \neq 0\)&lt;/span&gt;），那么就有
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) =  f(x) + \sum_{i=1}^{k}\alpha_i  c_i(x) + \sum_{j=1}^{l}\beta_j h_j(x)= \infty$$&lt;/div&gt;
&lt;p&gt;
因为若&lt;span class="math"&gt;\(c_i(x)&amp;gt;0\)&lt;/span&gt;，可取&lt;span class="math"&gt;\(\alpha_i \rightarrow +\infty\)&lt;/span&gt;，或者&lt;span class="math"&gt;\(h_i(x) \neq 0\)&lt;/span&gt;，可令&lt;span class="math"&gt;\(\beta_j h_j(x) \rightarrow +\infty\)&lt;/span&gt;，而将其余的&lt;span class="math"&gt;\(\alpha_i ，\beta_j\)&lt;/span&gt;都取0.&lt;/p&gt;
&lt;p&gt;相反的，若满足原始优化问题的约束条件，那么有&lt;span class="math"&gt;\(\theta_p(x) = f(x)\)&lt;/span&gt;。所以有
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_p(x) = \left\{\begin{matrix}
f(x)   \:\:\:\:\: x满足约束条件\\
\infty  \:\:\:\:\: 其他
\end{matrix}\right.$$&lt;/div&gt;
&lt;p&gt;
因此，如果我们考虑极小化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$min_x\theta_p(x) = min_xmax_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
我们可以看到这与原始最优化问题是等价的，称为&lt;strong&gt;广义拉格朗日函数的极小极大问题&lt;/strong&gt;。这样就把原始最优化问题转化为求解拉格朗日函数的极小极大问题。我们定义原始最优化问题的最优值为
&lt;/p&gt;
&lt;div class="math"&gt;$$p^* = min_x\theta_p(x)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;原始问题的值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;对偶问题&lt;/h2&gt;
&lt;p&gt;定义
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_D(x) = min_xL(x, \alpha, \beta) $$&lt;/div&gt;
&lt;p&gt;
上式中的下标D代表“dual（对偶问题）”。与前面定义的原始问题不同的是，原始问题是通过参数&lt;span class="math"&gt;\(\alpha, \beta\)&lt;/span&gt;进行优化（极大化），而这里定义的问题是通过&lt;span class="math"&gt;\(x\)&lt;/span&gt;进行优化（极小化）。&lt;/p&gt;
&lt;p&gt;对&lt;span class="math"&gt;\(\theta_D(x)\)&lt;/span&gt;极大化，就可以得到&lt;strong&gt;对偶优化问题&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;
&lt;div class="math"&gt;$$max_{\alpha, \beta: \alpha_i \geq 0}\theta_D(\alpha, \beta) = max_{\alpha, \beta: \alpha_i \geq 0}min_xL(x, \alpha, \beta) $$&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;称为&lt;strong&gt;广义拉格朗日函数的极大极小问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对偶问题与原始问题除了交换式子中max和min的顺序外，是一样的。同样，我也定义&lt;strong&gt;对偶优化问题的最优值&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = max_{\alpha, \beta: \alpha_i \geq 0}\theta_D(\alpha, \beta)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;对偶问题的值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;原始问题和对偶问题的关系&lt;/h2&gt;
&lt;p&gt;容易得到（max min 小于等于 min max）：
&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = max_{\alpha, \beta: \alpha_i \geq 0}min_xL(x, \alpha, \beta) \leq min_xmax_{\alpha, \beta: \alpha_i \geq 0}L(x, \alpha, \beta)= p^*$$&lt;/div&gt;
&lt;p&gt;在某些条件下，原始问题和对偶问题的最优值相等即&lt;span class="math"&gt;\(d^* = p^*\)&lt;/span&gt;，这时可以&lt;strong&gt;用对偶问题替代原始问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理1：&lt;/strong&gt;考虑原始问题和对偶问题。假设&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;和&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;是凸函数（convex），&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt;是仿射函数（affine，与线性函数类似只是允许增加一个截距b）；并且存在x，对所有的i有&lt;span class="math"&gt;\(c_i(x) &amp;lt; 0\)&lt;/span&gt;. 则存在&lt;span class="math"&gt;\(x^* , \alpha^* ,\beta^*\)&lt;/span&gt;，使得在&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;是原始问题的解，&lt;span class="math"&gt;\(\alpha^* ,\beta^*\)&lt;/span&gt;是对偶问题的解，并且&lt;/p&gt;
&lt;div class="math"&gt;$$d^* = p^* = L(x^*, \alpha^*, \beta^*)$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定理2：&lt;/strong&gt;考虑原始问题和对偶问题。假设&lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;和&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;是凸函数（convex），&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt;是仿射函数（affine）；并且存在x，对所有的i有&lt;span class="math"&gt;\(c_i(x) &amp;lt; 0\)&lt;/span&gt;. 则&lt;span class="math"&gt;\(x^*\)&lt;/span&gt;是原始问题的解，并且&lt;span class="math"&gt;\(\alpha^*, \beta^*\)&lt;/span&gt;是对偶问题的解的充分必要条件是&lt;span class="math"&gt;\(x^* , \alpha^* ,\beta^*\)&lt;/span&gt; 满足下面的&lt;strong&gt;Karush-Kuhn-Tucker(KKT)条件&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$\bigtriangledown_x L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\alpha L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\bigtriangledown_\beta L(x^*, \alpha^*, \beta^*)=0$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^* c_i(x^*) = 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$c_i(x^*) \leq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$\alpha^* \geq 0  \:\:\:\:\: i=1,2,...,k$$&lt;/div&gt;
&lt;div class="math"&gt;$$h_j(x^*) = 0   \:\:\:\:\: j=1,2,...,l$$&lt;/div&gt;
&lt;p&gt;其中，上面的第4个式子，称为KKT的对偶互补条件，由此条件可得，若&lt;span class="math"&gt;\(\alpha^*&amp;gt;0\)&lt;/span&gt;那么&lt;span class="math"&gt;\(c_i(x^*) = 0\)&lt;/span&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Wed, 30 Jul 2014 09:56:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-30:la-ge-lang-ri-dui-ou-xing-lagrange-duality.html</guid><category>基础概念</category></item><item><title>决策树</title><link>http://www.wengweitao.com/jue-ce-shu.html</link><description>&lt;blockquote&gt;
&lt;p&gt;决策树（decision tree）是一种基本的分类与回归方法。它可以认为是if-then规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。其主要优点是模型可读性好，分类速度快。决策树的学习通常包含3个部分：特征选择、决策树生成和决策树的修剪。学习时，利用训练数据，根据损失函数最小化的原则建立决策树模型；预测时，对新的数据，利用决策树模型进行分类。常用的算法有ID3、C4.5和CART。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;决策树模型与学习&lt;/h2&gt;
&lt;h3&gt;决策树模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;决策树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分类决策树模型是一种描述对实例进行分类的树形结构。决策树由结点和有向边组成。结点有两种类型：内部结点和叶结点。&lt;strong&gt;内部结点&lt;/strong&gt;表示一个特征或者属性，&lt;strong&gt;叶节点&lt;/strong&gt;表示一个类。&lt;/p&gt;
&lt;p&gt;用决策树分类，从根结点开始，对实例的某一特征进行测试，根据测试结果，将实例分配到其子结点；这时，每一个子结点对应着该特征的一个取值。如此递归的对实例进行测试并分配，直至到达叶节点，最后将实例分配到叶节点的类中。&lt;/p&gt;
&lt;h3&gt;决策树与if-then规则&lt;/h3&gt;
&lt;p&gt;互斥且完备&lt;/p&gt;
&lt;h3&gt;决策树与条件概率分布&lt;/h3&gt;
&lt;p&gt;决策树还可以表示为&lt;strong&gt;给定特征条件下类的条件概率分布&lt;/strong&gt;。各叶节点上的条件概率往往偏向某一个类，决策树分类时将该结点的实例强行分到条件概率大的那一类去。&lt;/p&gt;
&lt;h3&gt;决策树学习&lt;/h3&gt;
&lt;p&gt;学习的目标：根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。&lt;/p&gt;
&lt;p&gt;决策树模型可以看成是由训练数据集估计条件概率模型。&lt;/p&gt;
&lt;p&gt;决策树的学习的策略是以损失函数为目标函数的最小化。决策树的损失函数通常是正则化的极大似然函数。&lt;strong&gt;学习的问题就变成了在损失函数意义下选择最优决策树的问题。&lt;/strong&gt;因为从所有可能的决策树中选取最优决策树是NP完全问题，所以现实中决策树的学习算法通常采用启发式方法，近似求解这一优化问题。这样得到的决策树是次最优（sub-optimal）的。&lt;/p&gt;
&lt;p&gt;决策树的学习算法通常是一个递归的选择最优特征，并根据该特征对训练数据进行分割，使得对各个子数据集有一个最好的分类过程。这一过程对应着对特征空间的划分，也对应着决策树的构建。&lt;/p&gt;
&lt;p&gt;（1）开始构建根结点，将所有的训练数据都放入根结点；&lt;/p&gt;
&lt;p&gt;（2）选择一个最优特征，按照这一特征将训练数据分割成子集，使得各个子集有一个在当前条件下最好的分类；&lt;/p&gt;
&lt;p&gt;（3）如果这些子集已经基本被正确分类，那么就把这些子集分到所对应的叶节点中去；&lt;/p&gt;
&lt;p&gt;（4）如果还有子集未能基本正确分类，那么就对这些子集选择新的最优特征，继续对其进行分割&lt;/p&gt;
&lt;p&gt;（5）如此递归下去，直到全部基本正确分类，最后每一个子集都被分配到叶节点上，即都有了明确的分类，这就生成了一棵决策树。&lt;/p&gt;
&lt;p&gt;以上生成的决策树对训练数据有很好的分类能力，但可能发生过拟合的情况。我们需要对生成的决策树进行自下而上的剪枝（去掉过于细分的叶结点，使其回退到父节点或者更高的结点，使树变得更简单），使其具有更好的泛化能力。&lt;/p&gt;
&lt;p&gt;如果特征数量过多，可以在决策树学习开始的时候，对特征进行选择，留下对训练数据有足够充分分类能力的特征。&lt;/p&gt;
&lt;p&gt;可以看出决策树的学习算法包含特征选择、决策树生成和决策树剪枝过程。由于决策树表示一个条件概率分布，所以深浅不同的决策树对应着不同复杂度的概率模型。决策树的生成对应于模型的局部选择，决策树的剪枝对应于模型的全局选择。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;特征选择&lt;/h2&gt;
&lt;h3&gt;特征选择问题&lt;/h3&gt;
&lt;p&gt;特征的选择在于选取对训练数据具有分类能力的特征，这样可以提高决策树学习的效率。&lt;strong&gt;通常特征选择的准则是信息增益或信息增益比&lt;/strong&gt;。特征选择是决定用哪个特征来划分特征空间。如果一个特征具有较强的分类能力，那么我们就应该选择这个特征（或者说一个特征能使划分后的子集在当前条件下有最好的分类）。信息增益（information gain）就能够很好的表示这一准则。&lt;/p&gt;
&lt;h3&gt;信息增益&lt;/h3&gt;
&lt;p&gt;先给出熵和条件熵的定义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;熵（entropy）&lt;/strong&gt;表示随机变量不确定性的度量。假设X是一个取有限个值的离散变量，X的熵定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$H(X)=-\sum_{i=1}^{n}p_ilogp_i$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(p_i\)&lt;/span&gt;为X取每一个可能值的概率，上式中的对数以2为底或者以e为底，这时熵的单位分别称作比特（bit）或纳特（nat）。可以看出X的熵只依赖于X的分布，而与X的取值无关，所以可以将X的熵记为
&lt;/p&gt;
&lt;div class="math"&gt;$$H(p)=-\sum_{i=1}^{n}p_ilogp_i$$&lt;/div&gt;
&lt;p&gt;
熵越大，随机变量的不确定性就越大。从定义可以验证：
&lt;/p&gt;
&lt;div class="math"&gt;$$0 \leq H(p) \leq logn$$&lt;/div&gt;
&lt;p&gt;
即熵达到最大值（所有可能的事件等概率时不确定性最高）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;条件熵H(Y|X)&lt;/strong&gt;表示在已知随机变量X的条件下随机变量Y的不确定性。定义为X给定条件下Y的条件概率分布的熵对X的数学期望
&lt;/p&gt;
&lt;div class="math"&gt;$$H(Y|X)=\sum_{i=1}^{n}p_iH(Y|X=x_i)$$&lt;/div&gt;
&lt;p&gt;
这里&lt;span class="math"&gt;\(p_i=P(X=x_i), i=1,2,...,n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当熵和条件熵中的概率由数据统计得到时，所对应的熵与条件熵分别称为&lt;strong&gt;经验熵（empirical entropy）和经验条件熵（empirical conditional entropy）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息增益（information gain）&lt;/strong&gt;表示得知特征X的信息而使得类Y的信息不确定性的&lt;strong&gt;减少&lt;/strong&gt;长度。&lt;/p&gt;
&lt;p&gt;特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的经验条件熵H(D|A)之差：
&lt;/p&gt;
&lt;div class="math"&gt;$$g(D|A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;p&gt;
一般地，熵H(Y)与条件熵H(Y|X)之差称为互信息（mutual information）。决策树学习中的信息增益等价于训练数据集中类与特征的互信息。
信息增益大的特征具有更强的分类能力。&lt;/p&gt;
&lt;p&gt;根据学习增益准则的特征选择方法：对训练数据集D，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;信息增益的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：训练数据集D和特征A；&lt;/p&gt;
&lt;p&gt;输出：特征A对训练数据集D的信息增益g(D,A)&lt;/p&gt;
&lt;p&gt;（1）计算数据集D的经验熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H(D)=-\sum_{k=1}^{K}\frac{C_k}{|D|}log_2\frac{C_k}{|D|}$$&lt;/div&gt;
&lt;p&gt;
（2）计算特征A对数据集D的经验条件熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H(D|A)=\sum_{i=1}^{n}\frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^{n}\frac{|D_i|}{|D|}\sum_{k=1}^{K}\frac{|D_{ik}|}{|D_i|}log_2\frac{|D_{ik}|}{|D_i|}$$&lt;/div&gt;
&lt;p&gt;
（3）计算信息增益
&lt;/p&gt;
&lt;div class="math"&gt;$$g(D|A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(|D|\)&lt;/span&gt;表示样本容量，设有K个类&lt;span class="math"&gt;\(C_k，|C_k|\)&lt;/span&gt;属于类&lt;span class="math"&gt;\(C_k\)&lt;/span&gt;的样本数量。特征A将D划分为n个子集&lt;span class="math"&gt;\(D_1,D_2,...,D_n，|D_i|\)&lt;/span&gt;为&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;的样本数。子集&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;中属于类&lt;span class="math"&gt;\(C_k\)&lt;/span&gt;的样本的集合为&lt;span class="math"&gt;\(D_{ik}\)&lt;/span&gt;。&lt;/p&gt;
&lt;h3&gt;信息增益比&lt;/h3&gt;
&lt;p&gt;以信息增益作为划分训练数据集的特征，存在&lt;strong&gt;偏向于选择取值较多的特征&lt;/strong&gt;的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正。这是特征选择的另一准则。&lt;/p&gt;
&lt;p&gt;特征A对训练数据集D的信息增益比&lt;span class="math"&gt;\(g_R(D,A)\)&lt;/span&gt;定义为其信息增益g(D,A)与训练数据集D关于特征A的值的熵&lt;span class="math"&gt;\(H_A(D)\)&lt;/span&gt;之比：
&lt;/p&gt;
&lt;div class="math"&gt;$$g_R(D,A)=\frac{g(D,A)}{H_A(D)}$$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(H_A(D)=-\sum_{i=1}^{n}\frac{|D_{i}|}{|D|}log_2\frac{|D_{i}|}{|D|}\)&lt;/span&gt;，n为特征A的取值个数，&lt;span class="math"&gt;\(D_i\)&lt;/span&gt;表示特征A将D分成的子集。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;决策树的生成&lt;/h2&gt;
&lt;h3&gt;ID3算法&lt;/h3&gt;
&lt;p&gt;ID3算法的核心是在决策树各个结点上应用信息增益准则选择特征，递归地构建决策树。具体的方法是：&lt;/p&gt;
&lt;p&gt;（1）从根结点开始，对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子节点&lt;/p&gt;
&lt;p&gt;（2）对子节点递归的调用以上方法，构建决策树&lt;/p&gt;
&lt;p&gt;（3）直到所有特征的信息增益均很小或没有特征选择为止。&lt;/p&gt;
&lt;p&gt;ID3算法相当于用极大似然估计法进行概率模型的选择。&lt;/p&gt;
&lt;h3&gt;C4.5的生成算法&lt;/h3&gt;
&lt;p&gt;C4.5算法与ID3算法类似，在生成的过程中，用信息增益比来选择特征。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;决策树的剪枝&lt;/h2&gt;
&lt;p&gt;决策树生成算法产生的决策树，会出现过拟合的现象。因为在学习的过程中过多地考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。解决这个问题的办法就是考虑决策树的复杂度，对已生成的决策树进行简化。对已生成的决策树进行简化的过程称为&lt;strong&gt;剪枝（pruning）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。决策树的损失函数可以定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=\sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中，树T的叶节点数为|T|，叶节点t有&lt;span class="math"&gt;\(|N_t|\)&lt;/span&gt;个样本点，其中属于k类的数目为&lt;span class="math"&gt;\(|N_{tk}|\)&lt;/span&gt;个，&lt;span class="math"&gt;\(H_t(T)\)&lt;/span&gt;为叶节点t的经验熵
&lt;/p&gt;
&lt;div class="math"&gt;$$H_t(T)=-\sum_{k=1}^{K}\frac{|N_{tk}|}{|N_t|}log_2\frac{|N_{tk}|}{|N_t|}$$&lt;/div&gt;
&lt;p&gt;
决策树的损失函数可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
这时C(T)表示模型对训练数据的预测误差，即模型与训练数据的拟合程度，|T|表示模型的复杂度，参数α控制二者直接的影响。较大的α促使选择较简答的模型，较小反之。&lt;/p&gt;
&lt;p&gt;剪枝，就是当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;确定时，选择损失函数最小的模型，即损失函数最小的子树。利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;树的剪枝算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：生成算法产生的整棵树T，参数&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：修剪后的子树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）计算每个结点的经验熵&lt;/p&gt;
&lt;p&gt;（2）递归地从叶节点向上回缩。设叶节点回到到其父节点之前与之后的整体树分别为&lt;span class="math"&gt;\(T_B\)&lt;/span&gt;和&lt;span class="math"&gt;\(T_A\)&lt;/span&gt;，如果其对应的损失函数有：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_A) \leq C_\alpha(T_B)$$&lt;/div&gt;
&lt;p&gt;
则进行剪枝，即将父节点变为新的叶结点。&lt;/p&gt;
&lt;p&gt;（3）返回（2）直至不能继续，得到损失函数最小的子树。&lt;/p&gt;
&lt;p&gt;上式只需考虑两棵树的损失函数的差，其计算可以在局部进行，所以决策树的剪枝算法可以由一种动态规划算法实现。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;CART算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;分类与回归树（classification and regression tree, CART）&lt;/strong&gt;是应用广泛的决策树学习方法。既可以用于分类也可以用于回归。CART假设决策树是&lt;strong&gt;二叉树&lt;/strong&gt;，内部结点的特征取值为“是”或“否”，左分支是取值为“是”的分支，右分支是取值为“否”的的分支。这样的决策树等于递归地二分每个特征，将输入空间划分为有限个单元，并在这些单元上确定预测的概率分布。&lt;/p&gt;
&lt;p&gt;CART算法由以下两步组成：&lt;/p&gt;
&lt;p&gt;（1）决策树的生成&lt;/p&gt;
&lt;p&gt;（2）决策树的剪枝&lt;/p&gt;
&lt;h3&gt;CART生成&lt;/h3&gt;
&lt;p&gt;决策树的生成就是递归地构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树&lt;strong&gt;用基尼指数（Gini index）最小化准则，进行特征选择&lt;/strong&gt;，生成二叉树。&lt;/p&gt;
&lt;h4&gt;回归树的生成&lt;/h4&gt;
&lt;p&gt;遍历所有输入变量，找到最优的切分变量j和切分点（可以用平方误差来表示回归树对于训练数据的预测误差，使预测误差最小），构成一个对（j,s）。依次将输入空间划分为两个区域，接着对每个区域重复上述划分过程，直到满足停止条件为止。这样就生成一棵回归树。这样的&lt;strong&gt;回归树通常称为最小二乘回归树（least squares regression tree）&lt;/strong&gt;。&lt;/p&gt;
&lt;h6&gt;分类树的生成&lt;/h6&gt;
&lt;p&gt;分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。&lt;/p&gt;
&lt;p&gt;在分类问题中，假设有K个类，样本点属于第k类的概率为&lt;span class="math"&gt;\(p_k\)&lt;/span&gt;，则概率分布的基尼指数定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(p)=\sum_{k=1}^{K}p_k(1-p_k)=1-\sum_{k=1}^{K}p_k^2$$&lt;/div&gt;
&lt;p&gt;
对于给定的样本集合D，其基尼指数为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(p)=1-\sum_{k=1}^{K}(\frac{|C_k|}{|D|})^2$$&lt;/div&gt;
&lt;p&gt;
假设样本集合D根据特征A是否取某一可能值a被分割成两个部分&lt;span class="math"&gt;\(D_1\)&lt;/span&gt;和&lt;span class="math"&gt;\(D_2\)&lt;/span&gt;，则在特征A的条件下，集合D的基尼系数定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$Gini(D,A)=\frac{|D_1|}{|D|}Gini(D_1)+\frac{|D_2|}{|D|}Gini(D_2)$$&lt;/div&gt;
&lt;p&gt;
&lt;strong&gt;基尼指数Gini(D)表示集合D的不确定性&lt;/strong&gt;，基尼指数Gini(D,A)表示经A=a分割后集合D的不确定性。基尼指数越大，样本集合的不确定性也就越大（与熵类似）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CART生成算法：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入：训练数据集D，停止计算的条件（如结点中样本个数小于预定阈值，或样本集的基尼指数小于预定阈值）&lt;/p&gt;
&lt;p&gt;输出：CART决策树&lt;/p&gt;
&lt;p&gt;从根结点开始，递归地对每个结点进行以下操作：&lt;/p&gt;
&lt;p&gt;（1）设结点的训练数据集为D，计算现有特征对该数据集的基尼指数，对每一个特征A，对其可能的每一个取值a，根据样本点对A=a的测试为“是”或“否”将D分割成&lt;span class="math"&gt;\(D_1\)&lt;/span&gt;和&lt;span class="math"&gt;\(D_2\)&lt;/span&gt;两部分，计算A=a时的基尼指数。&lt;/p&gt;
&lt;p&gt;（2）在所有的特征A以及它们所有可能的切分点a中，&lt;strong&gt;选择基尼指数最小的特征及其对应的切分点作为最优特征与最优切分点&lt;/strong&gt;。依最优特征与最优切分点，从现结点生成两个子结点，将训练数据集依特征分配到两个子结点中去。&lt;/p&gt;
&lt;h3&gt;CART剪枝&lt;/h3&gt;
&lt;p&gt;CART剪枝算法由两步组成：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）剪枝，形成一个子树序列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从生成算法产生的决策树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;低端开始不断剪枝，直到&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;的根结点，形成一个子树序列&lt;span class="math"&gt;\({T_0,T_1,...,T_n}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;在剪枝的过程中，计算子树的损失函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中，T为任意子树，C(T)为对训练数据的预测误差（如基尼指数），|T|为子树的叶结点个数。&lt;/p&gt;
&lt;p&gt;从整体树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;开始剪枝，对&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;的任意内部结点t，以t为单结点树的损失函数是（叶结点个数为0）
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(t)=C(t)+\alpha$$&lt;/div&gt;
&lt;p&gt;
以t为根结点的子树&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;的损失函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)=C(T_t)+\alpha|T_t|$$&lt;/div&gt;
&lt;p&gt;
当&lt;span class="math"&gt;\(\alpha=0及\alpha\)&lt;/span&gt;充分小时，有不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t) \leq C_\alpha(t)$$&lt;/div&gt;
&lt;p&gt;
当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;增大时，上面&lt;span class="math"&gt;\(C_\alpha(T_t) = C_\alpha(t)\)&lt;/span&gt;，当&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;再增大时，上面的不等式就反向了。只要&lt;span class="math"&gt;\(\alpha = \frac{C(t)-C(T_t)}{|T_t|-1}\)&lt;/span&gt;，&lt;span class="math"&gt;\(T_t与t\)&lt;/span&gt;有相同的损失函数值，而t的结点少，因此t比&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;更可取，对&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;进行剪枝。&lt;/p&gt;
&lt;p&gt;为此对&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;中每一内部结点t，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$g(t) = \frac{C(t)-C(T_t)}{|T_t|-1}$$&lt;/div&gt;
&lt;p&gt;
上式的分子可以表示误差的增加，分母部分表示剪枝后树叶数量的减小。它表示剪枝后整体损失函数减少的程度。在&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;中减去g(t)最小的&lt;span class="math"&gt;\(T_t\)&lt;/span&gt;，将得到子树作为&lt;span class="math"&gt;\(T_1\)&lt;/span&gt;，同时将最小的g(t)设为&lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;。&lt;span class="math"&gt;\(T_1\)&lt;/span&gt;为区间&lt;span class="math"&gt;\([\alpha_1,\alpha_2)\)&lt;/span&gt;的最优子树。&lt;/p&gt;
&lt;p&gt;如此剪枝下去，直至得到根结点。在这一过程中，不断增加&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的值，产生新的区间。&lt;/p&gt;
&lt;p&gt;（1）对于所有的子树t，我们想用合适的叶子节点来代替t，然后计算增加的误差E与t的叶子节点的比值（即g(t)）。我们选择比值最小的那个子树t，用合适的叶子节点代替之。&lt;/p&gt;
&lt;p&gt;（2）重复迭代以上步骤，每次都替换掉一棵子树。我们会得到从完全增长的树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;到只有根节点一个决策结点的树&lt;span class="math"&gt;\(T_n\)&lt;/span&gt;的一系列决策树：&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;。然后我们用独立的验证集(我们可以从可用数据集中抽取三分之一作为验证集，剩下的三分之二作为训练集)来验证各个决策树的分类准确性。选取准确性最高的决策树为最终的CART决策树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）在剪枝得到的子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中通过交叉验证选取最优子树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中各棵子树的平方误差或基尼指数。平方误差或基尼指数最小的决策树被认为是最优的决策树。在子树序列中每棵子树&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;都对应于一个参数&lt;span class="math"&gt;\(\alpha_0,\alpha_1,...,\alpha_n\)&lt;/span&gt;。所以当最优子树&lt;span class="math"&gt;\(T_k\)&lt;/span&gt;确定时，对应的&lt;span class="math"&gt;\(\alpha_k\)&lt;/span&gt;也确定了，即得到最优决策树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果一个结点是叶节点那么其g(t)为无穷大，如果不是叶节点那么按照以上的方法计算g(t)。每次从当前的树中选择一个g(t)最小的（因为该结点增加的误差率是最小的），然后删去该结点或结点集合，得到一棵新的树，然后递归上面的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CART剪枝算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：CART算法生成的决策树&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;输出：最优决策树&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（1）设k=0, T=&lt;span class="math"&gt;\(T_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）$\alpha = +\infty $&lt;/p&gt;
&lt;p&gt;（3）自下而上对各内部结点计算&lt;span class="math"&gt;\(C(T_t)\)&lt;/span&gt;，计算出g(t)，并且将各结点计算出的最小的g(t)保存在&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;中&lt;/p&gt;
&lt;p&gt;（4）自上而下访问内部结点，如果g(t)=&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;，剪去g(t)最小的T，并对叶节点t以多数表决法决定其类，得到树T&lt;/p&gt;
&lt;p&gt;（5）k=k+1,在&lt;span class="math"&gt;\(\alpha_k=\alpha, T_k=T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（6）T不是由根结点单独一个结点构成的树，就&lt;strong&gt;返回（4）（（2）？）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（7）采用交叉验证在剪枝得到的子树序列&lt;span class="math"&gt;\(T_0,T_1,...,T_n\)&lt;/span&gt;中选取最优子树&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第五章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Tue, 29 Jul 2014 10:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-29:jue-ce-shu.html</guid><category>读书笔记</category></item><item><title>朴素贝叶斯法</title><link>http://www.wengweitao.com/po-su-bei-xie-si-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;朴素贝叶斯法（naive Bayes）是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的训练数据集，利用特征条件独立假设学习输入/输出的联合概率分布；然后基于此模型，对给定的输入x，利用贝叶斯定理求出后验概率最大的输出y。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;朴素贝叶斯法的学习与分类&lt;/h2&gt;
&lt;h3&gt;基本方法&lt;/h3&gt;
&lt;p&gt;朴素贝叶斯法通过训练数据集学习联合概率分布P(X,Y).x为输入特征向量，y为输出的类标记。
先求先验概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k), k = 1,2,...,K$$&lt;/div&gt;
&lt;p&gt;
然后求条件概率分布
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;
于是学习到联合概率分布P(X,Y)。&lt;/p&gt;
&lt;p&gt;条件概率分布&lt;span class="math"&gt;\(P(X=x|Y=c_k)\)&lt;/span&gt;有指级数量的次数，其估计实际是不可行的。假设&lt;span class="math"&gt;\(x^{(j)}\)&lt;/span&gt;的可能有&lt;span class="math"&gt;\(S_j\)&lt;/span&gt;个，j=1,2,...,n，Y的取值有K个，那么参数的个数为&lt;span class="math"&gt;\(K\prod S_j\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;朴素贝叶斯法是典型的生成方法。之所以叫做朴素贝叶斯法是因为该方法&lt;strong&gt;对条件概率的分布作了条件独立性的假设&lt;/strong&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},...,X^{(n)}=x^{(n)}|Y=c_k)=\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;朴素贝叶斯分类时，对给定的输入x，通过学习到的模型计算后验概率分布&lt;span class="math"&gt;\(P(Y=c_k|X=x)\)&lt;/span&gt;，将后验概率最大的类作为x的类输出。&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|X)=\frac{P(X,Y)}{P(X)}=\frac{P(X|Y)P(Y)}{\sum P(Y)P(X|Y)}$$&lt;/div&gt;
&lt;p&gt;
这是朴实贝叶斯分类器的基本形式。因为分母对于所有的&lt;span class="math"&gt;\(c_k\)&lt;/span&gt;都是相同的，所以朴素贝叶斯的分类器可以表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$y=argmaxP(Y=c_k)\prod_{j=1}^{n}P(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;
将n维的输入向量x代入，求出y值最大的那个分类&lt;span class="math"&gt;\(c_k\)&lt;/span&gt;，就是输入x的类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是先验概率和后验概率？
先验概率P(h)：就是在事情尚未发生之前，我们对该事件发生概率的估计，是根据以往经验分析得到的概率；
后验概率P(h|D)：给定D时，h发生的概率。是表示在某事件已经发生的条件下，求该事件由某个元素引起的可能性大小。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;后验概率最大化的含义&lt;/h3&gt;
&lt;p&gt;朴素贝叶斯法将实例分到后验概率最大的类中，这等价于期望经验风险最小化。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;朴素贝叶斯法的参数估计&lt;/h2&gt;
&lt;h3&gt;极大似然估计&lt;/h3&gt;
&lt;p&gt;在朴素贝叶斯法中，学习意味着估计&lt;span class="math"&gt;\(P(Y=c_k)\)&lt;/span&gt;和&lt;span class="math"&gt;\(P(X^{(j)}=x^{(j)}|Y=c_k)\)&lt;/span&gt;。可以运用极大似然估计法估计相应的概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)}{N}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x^{(j)}=a_{jl}|y_i=c_k)}{N}$$&lt;/div&gt;
&lt;h3&gt;贝叶斯估计&lt;/h3&gt;
&lt;p&gt;用极大似然估计可能会出现所要估计的概率值为0的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k)=\frac{\sum_{i=1}^{N}I(y_i=c_k)+\lambda}{N+K\lambda}$$&lt;/div&gt;
&lt;div class="math"&gt;$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^{N}I(x^{(j)}=a_{jl}|y_i=c_k)+\lambda}{N+S_j\lambda}$$&lt;/div&gt;
&lt;p&gt;
等价于在随机变量各个取值的频数上赋予一个正数&lt;span class="math"&gt;\(\lambda\)&lt;/span&gt;。常取&lt;span class="math"&gt;\(\lambda=1\)&lt;/span&gt;成为拉普拉斯平滑。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第四章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Mon, 28 Jul 2014 14:06:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-28:po-su-bei-xie-si-fa.html</guid><category>读书笔记</category></item><item><title>k近邻法</title><link>http://www.wengweitao.com/kjin-lin-fa.html</link><description>&lt;blockquote&gt;
&lt;p&gt;k近邻法（k-nearest neighbor, k-NN）是一种基于分类与回归的方法。分类时，对新的待分类的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显示的学习过程。k值的选择、距离度量及分类决策规则是k近邻法的3个基本要素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;k近邻算法&lt;/h2&gt;
&lt;p&gt;k近邻算法简单、直观：对新的待分类的实例，根据其k个最近邻的训练实例的类别，通过多数表决等方式进行预测。&lt;/p&gt;
&lt;h2&gt;k近邻模型&lt;/h2&gt;
&lt;p&gt;k近邻法的使用的模型实际上对应于对特征空间的划分。模型由三个要素——距离度量、k值的选择和分类决策规则决定。&lt;/p&gt;
&lt;h3&gt;模型&lt;/h3&gt;
&lt;p&gt;当训练集、距离度量、k值以及分类决策规程确定后，对于任何一个新的输入实例，它所属的类唯一确定。k近邻法的模型对应特征空间的一个划分，将特征空间划分为一些子空间，确定子空间里的每一个点所属的类。&lt;/p&gt;
&lt;p&gt;在特征空间中，对每个训练实例点&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;，距离该点比其他点更近的所有点组成一个区域，叫做单元（cell）。最近邻将实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;的类作为类&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;作为其单元中所有点的类标记（class label）。&lt;/p&gt;
&lt;h3&gt;距离度量&lt;/h3&gt;
&lt;p&gt;特征空间中两个实例点的距离是两个实例点相似程度的反映。&lt;/p&gt;
&lt;p&gt;设特征空间是n维实数向量空间，对于&lt;span class="math"&gt;\(x_i,x_j\)&lt;/span&gt;的&lt;span class="math"&gt;\(L_p\)&lt;/span&gt;距离定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L_p(x_i,x_j)=(\sum_{l=1}^{n}|x_i^{(l)}-x_j^{(l)}|^p)^{\frac{1}{p}}$$&lt;/div&gt;
&lt;p&gt;
当p=2时，是欧氏距离；&lt;/p&gt;
&lt;p&gt;当p=1时，是曼哈顿距离；&lt;/p&gt;
&lt;p&gt;当p=&lt;span class="math"&gt;\(\infty\)&lt;/span&gt;时，它是各个坐标距离的最大值，即
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_i,x_j)=max|x_i^{(l)}-x_j^{(l)}|$$&lt;/div&gt;
&lt;h3&gt;k值的选择&lt;/h3&gt;
&lt;p&gt;k值的选择会对k近邻法的结果产生重大的影响。如果选择较小的k值，那么就相当于用较小的领域中的训练实例进行预测，“学习”的近似误差（approximation error）会减小，只有与输入实例较近的训练实例才会对预测结果有作用。但缺点是“学习”的估计误差（estimation error）会增大，预测结果对近邻的实例点非常敏感，如果近邻点切好是噪音，那么预测就会出错。也就是说，k值较小整体模型越复杂，容易发生拟合。k值较大则相反。&lt;/p&gt;
&lt;p&gt;实际中通常k值取一个较小的数，采用交叉验证法来选取最优的k值。&lt;/p&gt;
&lt;h3&gt;分类决策规则&lt;/h3&gt;
&lt;p&gt;由输入实例的k个近邻中的多数类来决定输入实例的类。其实多数表决的功能就等价于经验风险最小化。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;k近邻法的实现：kd树&lt;/h2&gt;
&lt;p&gt;实现k近邻法时，主要考虑的问题是如果对训练数据进行快速k近邻搜索。最简单的实现方法就是线性扫描，计算新的输入实例与每一个训练实例的距离。当训练集很大，计算非常耗时，不可行。&lt;/p&gt;
&lt;p&gt;为了提高k近邻搜索效率，可以考虑使用特殊的结构存储训练数据，以减少计算距离的次数。&lt;/p&gt;
&lt;h3&gt;构造kd树&lt;/h3&gt;
&lt;p&gt;kd树是一种对k维空间中的实例点进行存储以便对其进行快速检索的树形数据结构。kd树是二叉树，表示对k维空间的一个划分（partition）。构造kd树相当于不断地用垂直于坐标轴的超平面将k维空间切分，构成一系列的k维超矩形区域。kd树的每一个结点对应于一个k维超矩形区域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;构造平衡kd树的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：k维空间数据集&lt;span class="math"&gt;\(T={x_1,x_2,...,x_N}\)&lt;/span&gt;，其中&lt;span class="math"&gt;\(x_i=(x_i^{(1)},x_i^{(2)},...,x_i^{(k)})^T\)&lt;/span&gt;，i=1,2,...,N；&lt;/p&gt;
&lt;p&gt;输出：kd树&lt;/p&gt;
&lt;p&gt;（1）开始：构造根结点，根结点对应于包含T的k维空间的超矩形区域。
选择&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;为坐标轴，以T中所有实例的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。切分由通过切分点并与坐标轴&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;垂直的超平面实现。由根结点生成深度为1的左、右结点，左子结点区域的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标对应的值小于切分点的值；右子结点区域的&lt;span class="math"&gt;\(x^{(1)}\)&lt;/span&gt;坐标对应的值大于切分点的值。将落在切分超平面上的实例点保存在根结点。&lt;/p&gt;
&lt;p&gt;（2）重复：对于深度为j的结点，选择&lt;span class="math"&gt;\(x^{(l)}\)&lt;/span&gt;为切分的坐标轴，&lt;span class="math"&gt;\(l=j \mod k + 1\)&lt;/span&gt;（如对于2维空间，（0,1）、（1,2）、（2,1）、（3,2）...），以该结点区域中所有实例的&lt;span class="math"&gt;\(x^{(l)}\)&lt;/span&gt;坐标的中位数为切分点，将根结点对应的超矩形区域切分为两个子区域。&lt;/p&gt;
&lt;p&gt;（3）直到两个区域没有实例存在时停止（所有实例点都在超平面上）。&lt;/p&gt;
&lt;h3&gt;搜索kd树&lt;/h3&gt;
&lt;p&gt;kd树可以省去对大部分数据点的搜索，从而减少搜索的计算量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用kd树的最邻近搜索的算法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;输入：已构造的kd树；目标点x；&lt;/p&gt;
&lt;p&gt;输出：x的最近邻&lt;/p&gt;
&lt;p&gt;（1）在kd树中找到包含目标点x的叶结点&lt;/p&gt;
&lt;p&gt;（2）以此叶节点为“当前最近点”&lt;/p&gt;
&lt;p&gt;（3）递归向上回退&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;）如果该结点保存的实例点比当前最几点距离目标点更近，则以该实例点为“当前”最近点&lt;/span&gt;

&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt;）当前最近点一定存在于该结点一个子结点对应的区域。检查该子结点的父结点的另一子结点对应的区域是否有更近的点。即以目标点为球心，以目标点与当前最近点间的距离为半径的球体是否与另一子结点对应的区域相交。如果相交，可能在另一个子结点对应的区域中存在更近的点。移动到另一个子结点，接着递归地进行最邻近搜索。如果不相交，则向上回退。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;（4）当回退到根结点，搜索结束，此时的当前最近结点即为最邻近点&lt;/p&gt;
&lt;p&gt;如果实例点是均匀分布的，那么kd树的搜索的平均计算复杂度是O(logN)，N为训练实例数。kd树适用于训练实例远大于空间维数时的k近邻搜索。当空间维数接近训练实例的时候，几乎接近线性搜索，效率迅速下降。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第三章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 27 Jul 2014 16:18:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-27:kjin-lin-fa.html</guid><category>读书笔记</category></item><item><title>感知机</title><link>http://www.wengweitao.com/gan-zhi-ji.html</link><description>&lt;blockquote&gt;
&lt;p&gt;感知机（perceptron）是二类分类的线性分类模型，其输入为实例的特征向量，输出为实例的类别，取+1和-1二值。感知机对应于输入空间中将实例划分为正负两类的分离超平面，属于判别模型。感知机学习旨在求出将训练数据进行线性划分的分离超平面，为此导入了基于误分类的损失函数，利用梯度下降法对损失函数进行极小化，求得感知机模型。感知机学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机是神经网络与支持向量机的基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;感知机模型&lt;/h2&gt;
&lt;p&gt;由输入空间到输出空间的如下函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=sign(w.x+b)$$&lt;/div&gt;
&lt;p&gt;
称为&lt;strong&gt;感知机&lt;/strong&gt;。其中w和b称为感知机模型参数，&lt;strong&gt;w叫做权值&lt;/strong&gt;（weight）或权值向量，b叫做偏置（bias）。感知机（perceptron）是&lt;strong&gt;二类分类的线性分类模型&lt;/strong&gt;，属于判别模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感知机的几何解释&lt;/strong&gt;：线性方程
&lt;/p&gt;
&lt;div class="math"&gt;$$w.x+b=0$$&lt;/div&gt;
&lt;p&gt;
对应于特征空间&lt;span class="math"&gt;\(R^n\)&lt;/span&gt;中的一个超平面S，其中w是超平面的法向量，b是超平面的截距。这个超平面将特征空间划分为两个部分，位于两部分的点分别被分为正、负两类。因此，超平面S称为&lt;strong&gt;分离超平面（separating hyperplanes）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;感知机学习，就是通过训练数据集，求得感知机模型，即求的模型参数w，b。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感知机学习策略&lt;/h2&gt;
&lt;h3&gt;数据集的线性可分性&lt;/h3&gt;
&lt;p&gt;如果存在某个超平面S
&lt;/p&gt;
&lt;div class="math"&gt;$$w.x+b=0$$&lt;/div&gt;
&lt;p&gt;
能够将数据集的正实例点和负实例点完全正确地划分到超平面的两侧，即对所有&lt;span class="math"&gt;\(y_i=+1\)&lt;/span&gt;的实例i，有&lt;span class="math"&gt;\(w.x_i+b&amp;gt;0\)&lt;/span&gt;，对所有&lt;span class="math"&gt;\(y_i=-1\)&lt;/span&gt;的实例i，有&lt;span class="math"&gt;\(w.x_i+b&amp;lt;0\)&lt;/span&gt;，则称数据集T为&lt;strong&gt;线性可分数据集&lt;/strong&gt;；否则为线性不可分。&lt;/p&gt;
&lt;h3&gt;感知机学习策略&lt;/h3&gt;
&lt;p&gt;假设数据集线性可分，感知机的学习目标是求得一个能够将训练集正实例点和负实例点完全正确分开的超平面。为了找到这个超平面，即确定感知机模型参数w，b，需要确定一个学习策略，即定义（经验）损失函数并将损失函数极小化。&lt;/p&gt;
&lt;p&gt;损失函数的一个自然选择是误分类点的总数，但是损失函数不是w，b的连续可导函数，不易优化。损失函数的另一个选择是计算误分类点到超平面的总距离。
输入空间中任一点&lt;span class="math"&gt;\(x_0\)&lt;/span&gt;到超平面S的距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{\left \| w \right \|}|w.x_0+b|$$&lt;/div&gt;
&lt;p&gt;
对于误分类的数据点&lt;span class="math"&gt;\(-y_i(w.x_1+b)&amp;gt;0\)&lt;/span&gt;那么所有误分类点到超平面的距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$-\frac{1}{\left \| w \right \|}\sum y_i(w.x_1+b)$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;感知机&lt;span class="math"&gt;\(sign(w.x+b)\)&lt;/span&gt;学习的损失函数定义为&lt;/strong&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b)=-\sum y_i(w.x_1+b)$$&lt;/div&gt;
&lt;p&gt;
一个特定样本的损失函数，在误分类的时候该函数是w和b的线性函数，而正确分类的时候是0，因此损失函数时w和b的连续可导函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;感知机学习策略&lt;/strong&gt;就是在假设空间中选取使感知机的损失函数最小的模型参数w和b，即感知机模型。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;感知机学习算法&lt;/h2&gt;
&lt;p&gt;感知机学习算法转化为求解感知机损失函数的最优化问题，最优化的方法是随机梯度下降法。&lt;/p&gt;
&lt;h3&gt;感知机学习算法的原始形式&lt;/h3&gt;
&lt;p&gt;首先，任意选取一个超平面&lt;span class="math"&gt;\(w_0,b_0\)&lt;/span&gt;，然后用梯度下降法不断地极小化目标函数，极小化的过程不是一次使M中所有误分类点的梯度下降，而是&lt;strong&gt;一次随机选取一个误分类点使其梯度下降&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;假设误分类点集合M是固定的，那么损失函数L(w,b)的梯度由：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial L(w,b)}{\partial w}=-\sum_{x_i\in M}y_ix_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$\frac{\partial L(w,b)}{\partial b}=-\sum_{x_i\in M}y_i$$&lt;/div&gt;
&lt;p&gt;
给出。
随机选取一个误分类点&lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;，对w,b进行更新：
&lt;/p&gt;
&lt;div class="math"&gt;$$w \leftarrow  w + \eta y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b \leftarrow  b + \eta y_i $$&lt;/div&gt;
&lt;p&gt;
其中&lt;span class="math"&gt;\(\eta\)&lt;/span&gt;是步长，又称为学习速率。这样通过迭代可以期待损失函数L(w,b)不断减小，直到0. &lt;/p&gt;
&lt;p&gt;这种学习算法直观上解释：当一个实例类被误分类，即位于分离超平面的错误一侧时，则调整w,b的值，使分离超平面向该分类点的一侧移动，以减少该误分类点与超平面的距离，直至超平面越过该误分类点使其被正确分类。&lt;/p&gt;
&lt;p&gt;感知机学习算法的原始形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;输入：训练数据集T、学习率α
输出：w,b；感知机模型f(x)=sign(w.x + b)
(1)选取初值w0,b0
(2)在训练集中选取数据(xi,yi)
(3)如果yi(w.xi + b) &lt;span class="err"&gt;&amp;lt;&lt;/span&gt;= 0，使用随机梯度下降法更新w和b
(4)转至(2)，直至训练集中没有误分类点（重复的将误分类的点一直更新）
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当采用不同的初值或者选取不同的误分类点的顺序时，解可能不同。&lt;/p&gt;
&lt;p&gt;这种算法是感知机学习的基本算法，对应于后面的对偶形式，称为&lt;strong&gt;原始形式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;算法的收敛性&lt;/h3&gt;
&lt;p&gt;可以证明，对于&lt;strong&gt;线性可分数据集感知机学习算法原始形式收敛&lt;/strong&gt;，即经过有限次迭代可以得到一个将训练数据集完全正确划分的分割超平面及感知机模型。
可以证明：
&lt;/p&gt;
&lt;div class="math"&gt;$$k \leq (\frac{R}{\gamma})^2$$&lt;/div&gt;
&lt;p&gt;
其中k是误分类的次数，&lt;span class="math"&gt;\(R=max\left \| x_i \right \|\)&lt;/span&gt;，&lt;span class="math"&gt;\(\gamma &amp;gt; 0\)&lt;/span&gt;。
即误分类的次数k是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。感知机学习算法存在许多解，这些解依赖于初值的选择和迭代过程中误分类点的选择顺序。为了得到唯一的超平面，需要对分离超平面增加约束条件（这就是SVM的思想）。&lt;/p&gt;
&lt;h3&gt;感知机学习算法的对偶形式&lt;/h3&gt;
&lt;p&gt;感知机学习算法的原始形式和对偶形式与SVM中的原始形式和对偶形式相对应。&lt;/p&gt;
&lt;p&gt;对偶形式的基本想法是：把w和b表示成实例&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;与标记&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;的线性组合的形式，通过求解其系数而求得w和b。
误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;对w,b进行逐步更新：
&lt;/p&gt;
&lt;div class="math"&gt;$$w \leftarrow  w + \eta y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b \leftarrow  b + \eta y_i $$&lt;/div&gt;
&lt;p&gt;
假设误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;修改了n次w，b，则w,b关于误分类点&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;的增量分别是&lt;span class="math"&gt;\(\alpha_i y_i x_i\)&lt;/span&gt;和&lt;span class="math"&gt;\(\alpha_i y_i\)&lt;/span&gt;，这里&lt;span class="math"&gt;\(\alpha_i=n_i \eta\)&lt;/span&gt;。假设初始值&lt;span class="math"&gt;\(w_0,b_0\)&lt;/span&gt;均为0，那么最后可以学习到w,b的表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$w=\sum_{i=1}^{N}\alpha_i y_i x_i$$&lt;/div&gt;
&lt;div class="math"&gt;$$b=\sum_{i=1}^{N}\alpha_i y_i$$&lt;/div&gt;
&lt;p&gt;感知机学习算法的对偶形式：&lt;/p&gt;
&lt;p&gt;输入：训练数据集T、学习率η&lt;/p&gt;
&lt;p&gt;输出：α,b；感知机模型&lt;span class="math"&gt;\(f(x)=sign(\sum_{j=1}^{N}\alpha_j y_j x_j + b)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(1)选取初值&lt;span class="math"&gt;\(\alpha_0,b_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(2)在训练集中选取数据(xi,yi)&lt;/p&gt;
&lt;p&gt;(3)如果&lt;span class="math"&gt;\(yi(\sum_{j=1}^{N}\alpha_j y_j x_j + b) \leq 0\)&lt;/span&gt;，更新&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;和b&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_i = \alpha_i + \eta$$&lt;/div&gt;
&lt;div class="math"&gt;$$b = b + \eta y_i$$&lt;/div&gt;
&lt;p&gt;(4)转至(2)，直至训练集中没有误分类点（重复的将误分类的点一直更新）&lt;/p&gt;
&lt;p&gt;为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的Gram矩阵：
&lt;/p&gt;
&lt;div class="math"&gt;$$G=[x_i.x_j]_{N \times N}$$&lt;/div&gt;
&lt;p&gt;
如&lt;span class="math"&gt;\(G_{1,1}\)&lt;/span&gt;为向量&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;与&lt;span class="math"&gt;\(x_i\)&lt;/span&gt;的相乘结果。&lt;/p&gt;
&lt;p&gt;与原始形式一样，感知机学习算法的对偶形式是收敛的，存在多个解。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第二章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 26 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-26:gan-zhi-ji.html</guid><category>读书笔记</category></item><item><title>梯度下降法</title><link>http://www.wengweitao.com/ti-du-xia-jiang-fa.html</link><description>&lt;p&gt;&lt;strong&gt;梯度下降法（Gradient Descent）&lt;/strong&gt;是一种常见的最优化算法，用于求解函数的最大值或者最小值。&lt;/p&gt;
&lt;h2&gt;梯度的概念&lt;/h2&gt;
&lt;p&gt;一个函数&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;对它的一个变量&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的梯度定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial J(\theta))}{\partial \theta} = \lim_{\delta \theta\rightarrow 0}\frac{J(\theta + \delta \theta)-J(\theta ))}{\delta \theta}$$&lt;/div&gt;
&lt;p&gt;
某一点上的梯度指向标量场增长最快的方向，梯度的长度就是最大的变化率。&lt;/p&gt;
&lt;h2&gt;梯度下降&lt;/h2&gt;
&lt;p&gt;在高数中，我们求解一个函数的最小值时，最常用的方法就是求出它的导数为0的那个点，进而判断这个点是否能够取最小值。但是，在实际很多情况，我们很难求解出使函数的导数为0的方程，这个时候就可以使用梯度下降。我们知道对于一个函数沿着梯度的那个方向是下降是最快的。例如为了选取一个&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;使&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;最小，我们可以先随机选择&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;一个初始值，然后不断的修改&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;以减小&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;，直到&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;的值不再改变。对于梯度下降法，可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha \frac{\partial J(\theta))}{\partial \theta_j} $$&lt;/div&gt;
&lt;p&gt;
即不断地向梯度的那个方向（减小最快的方向）更新&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;，最终使得&lt;span class="math"&gt;\(J(\theta)\)&lt;/span&gt;最小。其中&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;称为学习速率（learning rate），取值太小会导致迭代过慢，取值太大可能错过最值点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举一个具体的例子，假如你在一座山的山顶准备下山，往哪一个方向走下山最快呢？下山最快的方向是最陡的那个方向，每一步你都应该朝最陡的那个方向走，直到到达山底，学习速率就表示你每一步迈的步伐有多大。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;为什么从函数的梯度方向下降可以得到函数的最小值&lt;/h2&gt;
&lt;p&gt;梯度下降法，基于这样的观察：如果实值函数F(x)在点a 处可微且有定义，那么函数 F(x)在a点沿着梯度相反的方向&lt;span class="math"&gt;\(-\bigtriangledown F(a)\)&lt;/span&gt;下降最快。&lt;/p&gt;
&lt;p&gt;因而，如果
&lt;/p&gt;
&lt;div class="math"&gt;$$b=a-\alpha\bigtriangledown F(a)$$&lt;/div&gt;
&lt;p&gt;
那么&lt;span class="math"&gt;\(F(b) \leq F(a)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;考虑如下序列&lt;span class="math"&gt;\(x_0,x_1,x_2,...\)&lt;/span&gt;使得
&lt;/p&gt;
&lt;div class="math"&gt;$$x_{n+1}=x_n-\alpha\bigtriangledown F(x_n)$$&lt;/div&gt;
&lt;p&gt;
因此可以得到：
&lt;span class="math"&gt;\(F(x_0) \geq F(x_1) \geq F(x_2) \geq ...\)&lt;/span&gt;
如果顺利的话序列最终可以收敛到期望的极值。&lt;/p&gt;
&lt;p&gt;&lt;img alt="梯度下降描述" src="http://upload.wikimedia.org/wikipedia/commons/thumb/7/79/Gradient_descent.png/350px-Gradient_descent.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：梯度下降得到的结果可能是局部最优值。如果&lt;span class="math"&gt;\(F(x)\)&lt;/span&gt;是凸函数，则可以保证梯度下降得到的是全局最优值。&lt;/p&gt;
&lt;h2&gt;批梯度下降法&lt;/h2&gt;
&lt;p&gt;批梯度下降法（batch gradient descent）的算法描述如下：&lt;/p&gt;
&lt;p&gt;对每一个j重复以下过程直到收敛 {
    &lt;/p&gt;
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha \sum_{i=1}^{m}\frac{\partial J(\theta , z))}{\partial \theta_j} $$&lt;/div&gt;
&lt;p&gt;
}&lt;/p&gt;
&lt;p&gt;其中假设训练样本数有m个，每个样本用&lt;span class="math"&gt;\(z_i\)&lt;/span&gt;可以表示为&lt;span class="math"&gt;\((x_i, y_i)\)&lt;/span&gt;。可以看出，使用批梯度下降法每一次更新&lt;span class="math"&gt;\(\theta_j\)&lt;/span&gt;都需要遍历训练样本中的所有样本。&lt;/p&gt;
&lt;h2&gt;随机梯度下降法&lt;/h2&gt;
&lt;p&gt;除了批梯度下降法之外，还有一种算法称为——&lt;strong&gt;随机梯度下降法（stochastic gradient descent，SGD）&lt;/strong&gt;。算法描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Loop {
for i=1 to m, {
&lt;div class="math"&gt;$$\theta_{j} = \theta_j - \alpha\frac{\partial J(\theta , z_i))}{\partial \theta_j} $$&lt;/div&gt;
}
}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一次更新只使用了一个训练样本，但更新了m次。&lt;/p&gt;
&lt;p&gt;批梯度下降法每更新一步都需要遍历所有的样本数据，如果样本数m很大的话，就会非常的耗时；而对于随机梯度下降，每一遇到一个样本数据，就可以马上更新。通常情况下，使用随机梯度下降法的速度会比批梯度下降法快很多。因此，当样本数很大的时候，我们通常都选择使用随机梯度下降法。&lt;/p&gt;
&lt;h2&gt;关于梯度下降法中学习速率的取值问题&lt;/h2&gt;
&lt;p&gt;前面提到&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;称为学习速率（learning rate），取值太小会导致迭代过慢，取值太大可能错过最值点。所以对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;还是非常重要的。最常见的对&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;的选择策略为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不变策略：&lt;span class="math"&gt;\(\alpha_k=\alpha_0\)&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;1/k策略：&lt;span class="math"&gt;\(\alpha_k=\alpha_0\frac{\tau}{\tau + k}\)&lt;/span&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体的取值方法，还是需要根据实际的数据进行实验得出。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;http://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95&lt;/li&gt;
&lt;li&gt;http://www.iro.umontreal.ca/~bengioy/ift6266/H12/html/gradient_en.html&lt;/li&gt;
&lt;/ol&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sat, 26 Jul 2014 16:18:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-26:ti-du-xia-jiang-fa.html</guid><category>基本概念</category></item><item><title>统计学习方法概论</title><link>http://www.wengweitao.com/tong-ji-xue-xi-fang-fa-gai-lun.html</link><description>&lt;blockquote&gt;
&lt;p&gt;本文主要介绍统计学习方法的一些基本概念。首先叙述统计学习的定义、研究对象与方法；然后叙述什么是监督学习；接着提出统计学习方法的三要素：模型、测量和算法；然后又介绍了模型选择的方法，包括：正则化与交叉验证；也介绍了学习方法的泛化能力；接着介绍了监督学习中的两种模型：生成模型和判别模型；最后介绍了监督学习方法的应用：分类问题、标注问题与回归问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;统计学习&lt;/h2&gt;
&lt;h3&gt;统计学习的特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;统计学习（statistical learning）&lt;/strong&gt;是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;研究对象：数据&lt;/li&gt;
&lt;li&gt;目的：对数据进行预测和分析&lt;/li&gt;
&lt;li&gt;以方法为中心，统计学习方法构建模型并运用模型进行预测与分析&lt;/li&gt;
&lt;li&gt;是概率论、统计学等多个学科的交叉&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;统计学习的对象&lt;/h3&gt;
&lt;p&gt;统计学习的对象是数据（data），并且假设同类数据具有一定的统计规律性，这是统计学习的前提。只有具有一定的统计规律性才能使用概率论的方法进行描述。&lt;/p&gt;
&lt;h3&gt;统计学习的目的&lt;/h3&gt;
&lt;p&gt;考虑学习什么样的模型和如何学习模型，以使模型能够对数据进行准确的预测与分析，同时也要尽可能考虑学习的效率。&lt;/p&gt;
&lt;h3&gt;统计学习的方法&lt;/h3&gt;
&lt;p&gt;统计学习由：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监督学习（supervised learning）&lt;/li&gt;
&lt;li&gt;非监督学习（unsupervised learning）&lt;/li&gt;
&lt;li&gt;半监督学习（semi-supervised learning）&lt;/li&gt;
&lt;li&gt;强化学习（reinforcement learning）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;等几种学习方法组成。这里主要讨论监督学习。这种情况下，统计学习方法可以概括如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从给定的、有限的、用于学习的&lt;strong&gt;训练数据（traning data）&lt;/strong&gt;集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称为&lt;strong&gt;假设空间（hypoth space）&lt;/strong&gt;；应用某个&lt;strong&gt;评价准则（evaluation criterion）&lt;/strong&gt;，从假设空间中选取一个&lt;strong&gt;最优的模型&lt;/strong&gt;，使得它对已知训练数据及未知&lt;strong&gt;测试数据（test data）&lt;/strong&gt;在给定的评价准则下有最优的预测；最优模型的选取由算法实现；利用最优模型对新数据进行预测或分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这样统计学习方法包括：模型的假设空间、模型选择的准则以及模型学习的算法。&lt;strong&gt;这也就是统计学习方法的三要素：模型、策略、算法。&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;监督学习&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;监督学习（supervised learning）&lt;/strong&gt;的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。
分类和回归都属于监督学习：必须知道预测什么，即目标变量的分类信息。&lt;/p&gt;
&lt;p&gt;而与此相对的是&lt;strong&gt;无监督学习（unsupervised learning）&lt;/strong&gt;，数据没有类别信息，也不会给定目标值。&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;输入空间、特征空间与输出空间&lt;/h4&gt;
&lt;p&gt;将输入与输出所有可能取值的集合分别称为&lt;strong&gt;输入空间（input space）&lt;/strong&gt;与&lt;strong&gt;输出空间（output space）&lt;/strong&gt;。
每个具体的输入是一个&lt;strong&gt;实例（instance）&lt;/strong&gt;，通常由&lt;strong&gt;特征向量（feature vector）&lt;/strong&gt;表示。这时，所有特征向量存在的空间称为&lt;strong&gt;特征空间（feature space）&lt;/strong&gt;。特征空间的每一维对应一个特征。&lt;/p&gt;
&lt;p&gt;输入变量X和输出变量Y有不同的类型，根据不同的类型，对预测任务给予不同的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;回归问题&lt;/strong&gt;：输入变量与输出变量均为连续变量的预测（房间面积预测房价）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分类问题&lt;/strong&gt;：输出变量为有限个离散变量的预测问题（新闻分类）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标注问题&lt;/strong&gt;：输入变量与输出变量均为变量序列的预测问题（词性标注）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;联合概率分布&lt;/h4&gt;
&lt;p&gt;假定我们知道Y的一些情况，包括它和X一起出现的概率，在数学上称作&lt;em&gt;联合概率分布(Joint Probabilily)&lt;/em&gt;。输入变量X和输出变量Y遵循联合概率分布P(X,Y)。P(X,Y)表示&lt;strong&gt;分布函数&lt;/strong&gt;，或&lt;strong&gt;分布密度函数&lt;/strong&gt;。X和Y具有联合概率分布的假设是监督学习关于数据的基本假设。&lt;/p&gt;
&lt;h4&gt;假设空间&lt;/h4&gt;
&lt;p&gt;由输入到输出的映射是由模型来表示的，学习的目的就是为了找到最好的一个模型。模型属于由输入空间到输出空间的映射的集合，这个集合就是&lt;strong&gt;假设空间（hypoth space）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;监督学习的模型可以是概率模型也可以是&lt;strong&gt;非概率模型&lt;/strong&gt;，由条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 或决策函数（decision function） &lt;span class="math"&gt;\(Y=f(x)\)&lt;/span&gt; 表示。&lt;/p&gt;
&lt;h3&gt;问题的形式化&lt;/h3&gt;
&lt;p&gt;监督学习分为学习和预测两个过程。学习的过程需要训练数据集，而训练数据集往往是人工给出的，所以称为监督学习。&lt;/p&gt;
&lt;p&gt;如果一个模型有很好的预测能力，训练样本输出&lt;span class="math"&gt;\(y_i\)&lt;/span&gt;和模型输出&lt;span class="math"&gt;\(f(x_i)\)&lt;/span&gt;之间的差就应该足够小。&lt;/p&gt;
&lt;h2&gt;统计学习3要素&lt;/h2&gt;
&lt;p&gt;方法 = 模型 + 策略 + 算法&lt;/p&gt;
&lt;h3&gt;模型&lt;/h3&gt;
&lt;p&gt;模型就是所要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。
假设空间通常是由一个&lt;strong&gt;参数向量&lt;span class="math"&gt;\(\theta\)&lt;/span&gt;决定&lt;/strong&gt;的族。&lt;/p&gt;
&lt;h3&gt;策略&lt;/h3&gt;
&lt;p&gt;有了模型的假设空间，接着需要考虑按照什么样的准则学习或者选择最优的模型。
需要引入损失函数与风险函数的概念。&lt;/p&gt;
&lt;h4&gt;损失函数和风险函数&lt;/h4&gt;
&lt;p&gt;用&lt;strong&gt;损失函数（loss function）或代价函数（cost function）&lt;/strong&gt;来度量预测错误的程度，记作&lt;span class="math"&gt;\(L(Y,f(X))\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;常用的损失函数有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;0-1损失函数
&lt;div class="math"&gt;$$L(Y, f(X))=\left\{\begin{matrix}
0, Y \neq f(X)\\ 
1, Y =  f(X)
\end{matrix}\right.$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方损失函数（quadratic loss function）
&lt;div class="math"&gt;$$L(Y, f(X))=(Y - f(X))^2$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝对损失函数
&lt;div class="math"&gt;$$L(Y, f(X))=|Y - f(X)|$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数损失函数或者对数似然损失函数
&lt;div class="math"&gt;$$L(Y, P(Y|X))=-log(P(Y|X))$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输出(X,Y)是随机变量，遵循联合概率分布，所以&lt;strong&gt;损失函数的期望&lt;/strong&gt;是：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{exp}(f)=E_p[L(Y, f(X))]=\int L(y,f(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;这是模型&lt;span class="math"&gt;\(f(X)\)&lt;/span&gt;在联合概率分布P(X, Y)的平均意义下的损失，称为&lt;strong&gt;风险函数（risk function）或期望损失（expected loss）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;学习的目标是选择期望风险最小的模型，由于联合分布P(X,Y)是未知的（已知那么可以直接同P(X)求出P(Y|X)了），所以风险函数无法直接计算。&lt;/p&gt;
&lt;p&gt;模型f(X)关于一个给定训练数据集的平均损失称为&lt;strong&gt;经验风险（empirical risk）或者经验损失（empirical loss）&lt;/strong&gt;，记作：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{emp}(f)=\frac{1}{N}\sum L(y,f(x))$$&lt;/div&gt;
&lt;p&gt;
根据大数定律，当N趋于无穷时，经验风险趋于期望风险。所以很自然的想到用经验风险估计期望风险。但是实际训练样本数目有限，用经验风险评估期望风险常常并不理想，要对经验风险进行一定的矫正，这就关系到监督学习中的两个基本策略：经验风险最小化和结构化风险最小化。&lt;/p&gt;
&lt;h4&gt;经验风险最小化和结构化风险最小化&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;经验风险最小化（empirical risk minimization， ERM）&lt;/strong&gt;的策略认为，经验风险最小的模型是最优的模型。
当样本容量足够大时，经营风险最小化能保证有很好的学习效果，比如极大似然估计就是一个例子。&lt;/p&gt;
&lt;p&gt;当样本容量很小时，经营风险最小化可能产生&lt;strong&gt;过拟合（over-fitting）&lt;/strong&gt;的现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结构风险最小化（structural risk minimization， SRM）&lt;/strong&gt;是为了防止过拟合而提出的策略，&lt;strong&gt;结构风险最小化等价于正则化（regularization）&lt;/strong&gt;。结构风险在经验风险上加上表示模型复杂度的正则化项或罚项。结构风险的定义是：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{srm}(f)=\frac{1}{N}\sum L(y_i,f(x_i))+\lambda J(f)$$&lt;/div&gt;
&lt;p&gt;
J(f)为模型的复杂度，模型f越复杂，复杂度J(f)就越大；反之越小。也就是说复杂度表示了对复杂模型的惩罚。$\lambda \geq 0 $用以权衡经验风险和模型复杂度。&lt;/p&gt;
&lt;p&gt;贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation, MAP）就是结构化风险最小化的例子。&lt;/p&gt;
&lt;p&gt;这样，&lt;strong&gt;监督学习问题就变成了经验风险或结构风险函数的最优化问题。这时经验或结构风险函数是最优化的目标函数&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;算法&lt;/h3&gt;
&lt;p&gt;最后需要考虑用什么样的计算方法求解最优模型。&lt;/p&gt;
&lt;p&gt;如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模型的假设空间（模型）、模型选择的准则（策略）以及模型学习的算法（算法），这3个确定了，统计学习的方法也就确定了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;模型评估与模型选择&lt;/h2&gt;
&lt;h3&gt;训练误差与测试误差&lt;/h3&gt;
&lt;p&gt;前者是基于训练数据集的平均损失，后者是根据测试数据集的平均损失。测试误差反映了学习方法对未知的测试数据集的预测能力，越小就代表预测能力越强。通常将学习方法对未知数据的预测能力称为&lt;strong&gt;泛化能力（generalization ability）&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;过拟合与模型选择&lt;/h3&gt;
&lt;p&gt;对于有多个模型，如果一味追求提高对训练数据的预测能力，所选模型的复杂度往往会比真模型更高，这种现象就称为&lt;strong&gt;过拟合（over-fitting）&lt;/strong&gt;。过拟合是指学习时选择的模型包含的参数过多，以致于出现这一模型对已知数据预测很好，但对未知数据预测得很差的现象。&lt;/p&gt;
&lt;p&gt;模型选择时，不仅要考虑对已知数据的预测能力，还要考虑对未知数据的预测能力。当训练数据拟合效果较好，模型也比较简单，是一个较好的选择。&lt;/p&gt;
&lt;p&gt;在多项式函数拟合中可以看到，随着多项式次数（模型复杂度）的增加，训练误差会减小，直至趋向于0，但测试误差却并不如此，会先减小，达到最小值，然后增大。
下面介绍两种常用的&lt;strong&gt;模型选择方法&lt;/strong&gt;：正则化与交叉验证。&lt;/p&gt;
&lt;h2&gt;正则化与交叉验证&lt;/h2&gt;
&lt;h3&gt;正则化&lt;/h3&gt;
&lt;p&gt;模型选择的典型方法是正则化（regularization），正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或惩罚项。正则化的作用就是选择经验风险与模型复杂度同时较小的模型。&lt;/p&gt;
&lt;p&gt;正则化符合奥卡姆剃刀（Occam's razor）原理：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;若无必要，勿增实体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在所有可能的选择汇总，能够很好的解释已知数据并且十分简单才是最好的模型，也就是应该选择的模型。从贝叶斯估计的角度看，正则化对应于模型的先验概率。复杂的模型有较小的先验概率，简单的模型有较大的先验概率。&lt;/p&gt;
&lt;h3&gt;交叉验证&lt;/h3&gt;
&lt;p&gt;如果样本充足，可以将数据集分为3个部分：训练集、验证集和测试集。训练集用来训练模型，验证集用于模型的选择，而测试集用于最终对学习方法的评估。
但是，在实际中，数据样本是不充足的，为了选择好的模型，可以采用交叉验证（cross validation）的方法。交叉验证的基本思想是重复地使用数据，将给定的数据集进行切分，将切分的数据集组合为训练集与测试集，反复进行训练、测试以及模型选择。&lt;/p&gt;
&lt;p&gt;1.简单交叉验证&lt;/p&gt;
&lt;p&gt;随机地将数据集分为两部分，一部分为训练集，一部分为测试集（如70%和30%的比例切分）。选出测试误差最小的模型。&lt;/p&gt;
&lt;p&gt;2.S折交叉验证&lt;/p&gt;
&lt;p&gt;应用最多的是S折交叉验证（S-fold cross validation）。随机地将数据集切分成S个互不相交的大小相同的子集；然后利用S-1个自己训练模型，利用余下的一个子集测试模型；重复这一过程S次，每次选择不同的一份子集作为测试集；最后选出S次评测中平均测试误差最小的模型。&lt;/p&gt;
&lt;p&gt;3.留一交叉验证&lt;/p&gt;
&lt;p&gt;S折交叉验证当S=N的特例，往往在数据缺乏的情况下使用。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;泛化能力&lt;/h2&gt;
&lt;h3&gt;泛化误差&lt;/h3&gt;
&lt;p&gt;泛化能力是指该方法学习到的模型对未知数据的预测能力，通常是通过测试误差来评价学习方法的泛化能力。
如果学到的模型是f，那么用这个模型对未知数据预测的误差即为泛化误差（generalization error）：
&lt;/p&gt;
&lt;div class="math"&gt;$$ R_{exp}(f)=E_p[L(Y, f(X))]=\int L(y,f(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;
事实上，泛化误差就是所学习到的模型的期望风险。&lt;/p&gt;
&lt;h3&gt;泛化误差的上界&lt;/h3&gt;
&lt;p&gt;学习方法的泛化能力往往都是通过研究泛化误差的上界进行的。泛化误差上界通常具有如下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是样本容量的函数，当样本容易增加，泛化上界趋向于0；&lt;/li&gt;
&lt;li&gt;它是假设空间容量的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于二类分类问题，当假设空间是有限个，对任意一个函数f，至少以概率&lt;span class="math"&gt;\(1-\sigma\)&lt;/span&gt;以下不等式成立：
&lt;/p&gt;
&lt;div class="math"&gt;$$R(f) \leq R’(f) + \epsilon (d, N, \sigma)$$&lt;/div&gt;
&lt;p&gt;
左端是泛化误差，右端即为泛化误差的上界。在泛化误差的上界中，第1项是训练误差，训练误差越小，泛化误差越小。第2项是N的单调递减函数，当N趋于无穷时趋于0；同时也是&lt;span class="math"&gt;\(\sqrt{logd}\)&lt;/span&gt;阶的函数（d是函数个数），假设空间中函数个数越多，其值越大。
可以证明以上不等式，需要用到Hoeffding不等式。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;生成模型与判别模型&lt;/h2&gt;
&lt;p&gt;监督学习方法可以分为&lt;strong&gt;生成方法（generative approach）和判别方法（discriminative approach）&lt;/strong&gt;。所学到的模型分别称为生成模型和判别模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成方法&lt;/strong&gt;由数据学习联合概率分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|X)=\frac{P(X,Y)}{P(X)}$$&lt;/div&gt;
&lt;p&gt;
这样的方法称为生成方法，是因为模型表示了给定输入X产生输出Y的生成关系。
典型的生成模型有：朴素贝叶斯法和隐马尔可夫模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判别方法&lt;/strong&gt;由数据直接学习决策函数f(X)或者条件概率分布P(Y|X)作为预测模型，即判别模型。判别方法关心的是对给定的输入X，应该预测什么样的输出Y。
典型的判别模型包括：k近邻法、感知机、决策树、逻辑斯谛回归模型、最大熵模型、支持向量机、提升方法和条件随机场等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生成方法的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以还原出P(X,Y)，而判别模型不能&lt;/li&gt;
&lt;li&gt;学习收敛速度更快，即样本容量增加，学到的模型能够更快收敛于真实模型&lt;/li&gt;
&lt;li&gt;当存在隐变量时，仍然可以用生成学习方法学习，此时判别方法就不能用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;判别方法的特点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接学习的是P(Y|X)或决策函数f(X)，直接面对预测，学习的效率更高&lt;/li&gt;
&lt;li&gt;由于是直接学习P(Y|X)或决策函数f(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;分类问题&lt;/h2&gt;
&lt;p&gt;当&lt;strong&gt;输出变量Y取有限个离散值&lt;/strong&gt;时，预测问题便成为分类问题。&lt;/p&gt;
&lt;p&gt;评价分类器性能的指标一般是分类&lt;strong&gt;准确率（accuracy）&lt;/strong&gt;，其定义是：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。&lt;/p&gt;
&lt;p&gt;对于二类分类问题常用的评价指标是&lt;strong&gt;精确率（precision）&lt;/strong&gt;与&lt;strong&gt;召回率（recall）&lt;/strong&gt;。通常以关注的类为正类，其他类为负类。预测的4种情况出现的总数分别记作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TP：将正类预测为正类数&lt;/li&gt;
&lt;li&gt;FN：将正类预测为负类数&lt;/li&gt;
&lt;li&gt;FP：将负类预测为正类数&lt;/li&gt;
&lt;li&gt;TN：将负类预测为负类数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精确率定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$P=\frac{TP}{TP+FP}$$&lt;/div&gt;
&lt;p&gt;
即预测结果为正类中的确是正类的概率。&lt;/p&gt;
&lt;p&gt;召回率定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$R=\frac{TP}{TP+FN}$$&lt;/div&gt;
&lt;p&gt;
即预测结果中与正类的概率占数据集中总的正类的概率。&lt;/p&gt;
&lt;p&gt;此外，还有&lt;span class="math"&gt;\(F_1\)&lt;/span&gt;值，是精确率和召回率的调和均值，即：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}$$&lt;/div&gt;
&lt;p&gt;
精确率和召回率都高时，&lt;span class="math"&gt;\(F_1\)&lt;/span&gt;值也会高。&lt;/p&gt;
&lt;p&gt;许多统计学习方法可以用于分类，包括k近邻法、感知机、朴素贝叶斯法、决策树、决策列表、逻辑斯谛回归模型、支持向量机、提升方法、贝叶斯网络、神经网络等。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;标注问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;标注（taggging）&lt;/strong&gt;也是一个监督学习问题，可以认为是分类问题的一个推广，标注问题是对更复杂的结构预测问题的简单形式。标注问题的输入是一个观察序列，输出是一个标记序列或状态序列。注意，可能的标记个数是有限的，但其组合缩成的标记序列的个数是依序列长度呈指数级增长。&lt;/p&gt;
&lt;p&gt;标注常用的统计学习方法有：隐马尔可夫模型、条件随机场。&lt;/p&gt;
&lt;p&gt;标注问题在信息抽取、自然语言处理等领域被广泛应用，如自然语言处理中的词性标注。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;回归问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;回归（regression）&lt;/strong&gt;是监督学习的另一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系。回归模型是表示从输入变量到输出变量之间的映射函数。回归问题的学习等价于函数拟合。&lt;/p&gt;
&lt;p&gt;回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间的关系的类型，分为线性回归和非线性回归。&lt;/p&gt;
&lt;p&gt;回归学习最常用的损失函数时平方损失函数，在此情况下，回归问题可以用著名的最小二乘法（least square）求解。&lt;/p&gt;
&lt;p&gt;回归问题可以用于预测股票，如将影响股票价格的各种因素作为自变量（输入特征），而将股价作为因变量（输出的值），将过去的数据作为训练数据，就可以学习一个回归模型，对未来的股价进行预测。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://book.douban.com/subject/10590856/"&gt;统计学习方法&lt;/a&gt;第一章&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }
    
    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); ";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Fri, 25 Jul 2014 20:12:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-25:tong-ji-xue-xi-fang-fa-gai-lun.html</guid><category>读书笔记</category></item><item><title>Hello, world</title><link>http://www.wengweitao.com/hello-world.html</link><description>&lt;p&gt;Hello, world!&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">wwt</dc:creator><pubDate>Sun, 20 Jul 2014 00:00:00 +0800</pubDate><guid>tag:www.wengweitao.com,2014-07-20:hello-world.html</guid><category>测试</category></item></channel></rss>